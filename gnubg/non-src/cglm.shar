# This is a shell archive.  Save it in a file, remove anything before
# this line, and then unpack it by entering "sh file".  Note, it may
# create directories; files and directories will be owned by you and
# have default permissions.
#
# This archive contains:
#
#	cglm
#	cglm/version.h
#	cglm/common.h
#	cglm/types.h
#	cglm/types-struct.h
#	cglm/cglm.h
#	cglm/call.h
#	cglm/struct.h
#	cglm/cam.h
#	cglm/io.h
#	cglm/mat4.h
#	cglm/mat4x2.h
#	cglm/mat4x3.h
#	cglm/mat3.h
#	cglm/mat3x2.h
#	cglm/mat3x4.h
#	cglm/mat2.h
#	cglm/mat2x3.h
#	cglm/mat2x4.h
#	cglm/affine-pre.h
#	cglm/affine-post.h
#	cglm/affine.h
#	cglm/affine-mat.h
#	cglm/vec2.h
#	cglm/vec2-ext.h
#	cglm/ivec2.h
#	cglm/vec3.h
#	cglm/vec3-ext.h
#	cglm/ivec3.h
#	cglm/vec4.h
#	cglm/vec4-ext.h
#	cglm/ivec4.h
#	cglm/euler.h
#	cglm/util.h
#	cglm/quat.h
#	cglm/plane.h
#	cglm/frustum.h
#	cglm/box.h
#	cglm/color.h
#	cglm/project.h
#	cglm/sphere.h
#	cglm/ease.h
#	cglm/curve.h
#	cglm/bezier.h
#	cglm/applesimd.h
#	cglm/ray.h
#	cglm/affine2d.h
#	cglm/call
#	cglm/call/mat4.h
#	cglm/call/mat4x2.h
#	cglm/call/mat4x3.h
#	cglm/call/mat3.h
#	cglm/call/mat3x2.h
#	cglm/call/mat3x4.h
#	cglm/call/mat2.h
#	cglm/call/mat2x3.h
#	cglm/call/mat2x4.h
#	cglm/call/vec2.h
#	cglm/call/vec3.h
#	cglm/call/vec4.h
#	cglm/call/ivec2.h
#	cglm/call/ivec3.h
#	cglm/call/ivec4.h
#	cglm/call/io.h
#	cglm/call/cam.h
#	cglm/call/quat.h
#	cglm/call/euler.h
#	cglm/call/plane.h
#	cglm/call/frustum.h
#	cglm/call/box.h
#	cglm/call/project.h
#	cglm/call/sphere.h
#	cglm/call/ease.h
#	cglm/call/curve.h
#	cglm/call/bezier.h
#	cglm/call/ray.h
#	cglm/call/affine.h
#	cglm/call/affine2d.h
#	cglm/call/clipspace
#	cglm/call/clipspace/persp_lh_no.h
#	cglm/call/clipspace/persp_lh_zo.h
#	cglm/call/clipspace/persp_rh_no.h
#	cglm/call/clipspace/persp_rh_zo.h
#	cglm/call/clipspace/ortho_lh_no.h
#	cglm/call/clipspace/ortho_lh_zo.h
#	cglm/call/clipspace/ortho_rh_no.h
#	cglm/call/clipspace/ortho_rh_zo.h
#	cglm/call/clipspace/view_lh_no.h
#	cglm/call/clipspace/view_lh_zo.h
#	cglm/call/clipspace/view_rh_no.h
#	cglm/call/clipspace/view_rh_zo.h
#	cglm/call/clipspace/project_no.h
#	cglm/call/clipspace/project_zo.h
#	cglm/clipspace
#	cglm/clipspace/persp.h
#	cglm/clipspace/persp_lh_no.h
#	cglm/clipspace/persp_lh_zo.h
#	cglm/clipspace/persp_rh_no.h
#	cglm/clipspace/persp_rh_zo.h
#	cglm/clipspace/ortho_lh_no.h
#	cglm/clipspace/ortho_lh_zo.h
#	cglm/clipspace/ortho_rh_no.h
#	cglm/clipspace/ortho_rh_zo.h
#	cglm/clipspace/view_lh.h
#	cglm/clipspace/view_rh.h
#	cglm/clipspace/view_lh_no.h
#	cglm/clipspace/view_lh_zo.h
#	cglm/clipspace/view_rh_no.h
#	cglm/clipspace/view_rh_zo.h
#	cglm/clipspace/project_no.h
#	cglm/clipspace/project_zo.h
#	cglm/simd
#	cglm/simd/intrin.h
#	cglm/simd/x86.h
#	cglm/simd/arm.h
#	cglm/simd/avx
#	cglm/simd/avx/mat4.h
#	cglm/simd/avx/affine.h
#	cglm/simd/neon
#	cglm/simd/neon/affine.h
#	cglm/simd/neon/mat2.h
#	cglm/simd/neon/mat4.h
#	cglm/simd/neon/quat.h
#	cglm/simd/sse2
#	cglm/simd/sse2/affine.h
#	cglm/simd/sse2/mat4.h
#	cglm/simd/sse2/mat3.h
#	cglm/simd/sse2/mat2.h
#	cglm/simd/sse2/quat.h
#	cglm/struct
#	cglm/struct/mat4.h
#	cglm/struct/mat4x2.h
#	cglm/struct/mat4x3.h
#	cglm/struct/mat3.h
#	cglm/struct/mat3x2.h
#	cglm/struct/mat3x4.h
#	cglm/struct/mat2.h
#	cglm/struct/mat2x3.h
#	cglm/struct/mat2x4.h
#	cglm/struct/affine-pre.h
#	cglm/struct/affine-post.h
#	cglm/struct/affine-mat.h
#	cglm/struct/affine.h
#	cglm/struct/affine2d.h
#	cglm/struct/vec2.h
#	cglm/struct/vec2-ext.h
#	cglm/struct/vec3.h
#	cglm/struct/vec3-ext.h
#	cglm/struct/vec4.h
#	cglm/struct/vec4-ext.h
#	cglm/struct/io.h
#	cglm/struct/cam.h
#	cglm/struct/quat.h
#	cglm/struct/euler.h
#	cglm/struct/plane.h
#	cglm/struct/frustum.h
#	cglm/struct/box.h
#	cglm/struct/project.h
#	cglm/struct/sphere.h
#	cglm/struct/color.h
#	cglm/struct/curve.h
#	cglm/struct/clipspace
#	cglm/struct/clipspace/persp_lh_no.h
#	cglm/struct/clipspace/persp_lh_zo.h
#	cglm/struct/clipspace/persp_rh_no.h
#	cglm/struct/clipspace/persp_rh_zo.h
#	cglm/struct/clipspace/ortho_lh_no.h
#	cglm/struct/clipspace/ortho_lh_zo.h
#	cglm/struct/clipspace/ortho_rh_no.h
#	cglm/struct/clipspace/ortho_rh_zo.h
#	cglm/struct/clipspace/view_lh_no.h
#	cglm/struct/clipspace/view_lh_zo.h
#	cglm/struct/clipspace/view_rh_no.h
#	cglm/struct/clipspace/view_rh_zo.h
#	cglm/struct/clipspace/project_no.h
#	cglm/struct/clipspace/project_zo.h
#
echo c - cglm
mkdir -p cglm > /dev/null 2>&1
echo x - cglm/version.h
sed 's/^X//' >cglm/version.h << '50b96efae597911eaecef81f66f605ed'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_version_h
X#define cglm_version_h
X
X#define CGLM_VERSION_MAJOR 0
X#define CGLM_VERSION_MINOR 9
X#define CGLM_VERSION_PATCH 2
X
X#endif /* cglm_version_h */
50b96efae597911eaecef81f66f605ed
echo x - cglm/common.h
sed 's/^X//' >cglm/common.h << 'f8694d16671dbd8b06cd994499637ea4'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_common_h
X#define cglm_common_h
X
X#ifndef _USE_MATH_DEFINES
X#  define _USE_MATH_DEFINES       /* for windows */
X#endif
X
X#ifndef _CRT_SECURE_NO_WARNINGS
X#  define _CRT_SECURE_NO_WARNINGS /* for windows */
X#endif
X
X#include <stdint.h>
X#include <stddef.h>
X#include <stdlib.h>
X#include <math.h>
X#include <float.h>
X#include <stdbool.h>
X
X#if defined(_MSC_VER)
X#  ifdef CGLM_STATIC
X#    define CGLM_EXPORT
X#  elif defined(CGLM_EXPORTS)
X#    define CGLM_EXPORT __declspec(dllexport)
X#  else
X#    define CGLM_EXPORT __declspec(dllimport)
X#  endif
X#  define CGLM_INLINE __forceinline
X#else
X#  define CGLM_EXPORT __attribute__((visibility("default")))
X#  define CGLM_INLINE static inline __attribute((always_inline))
X#endif
X
X#define GLM_SHUFFLE4(z, y, x, w) (((z) << 6) | ((y) << 4) | ((x) << 2) | (w))
X#define GLM_SHUFFLE3(z, y, x)    (((z) << 4) | ((y) << 2) | (x))
X
X#include "types.h"
X#include "simd/intrin.h"
X
X#ifndef CGLM_USE_DEFAULT_EPSILON
X#  ifndef GLM_FLT_EPSILON
X#    define GLM_FLT_EPSILON 1e-5f
X#  endif
X#else
X#  define GLM_FLT_EPSILON FLT_EPSILON
X#endif
X
X/*
X * Clip control: define CGLM_FORCE_DEPTH_ZERO_TO_ONE before including
X * CGLM to use a clip space between 0 to 1.
X * Coordinate system: define CGLM_FORCE_LEFT_HANDED before including
X * CGLM to use the left handed coordinate system by default.
X */
X
X#define CGLM_CLIP_CONTROL_ZO_BIT (1 << 0) /* ZERO_TO_ONE */
X#define CGLM_CLIP_CONTROL_NO_BIT (1 << 1) /* NEGATIVE_ONE_TO_ONE */
X#define CGLM_CLIP_CONTROL_LH_BIT (1 << 2) /* LEFT_HANDED, For DirectX, Metal, Vulkan */
X#define CGLM_CLIP_CONTROL_RH_BIT (1 << 3) /* RIGHT_HANDED, For OpenGL, default in GLM */
X
X#define CGLM_CLIP_CONTROL_LH_ZO (CGLM_CLIP_CONTROL_LH_BIT | CGLM_CLIP_CONTROL_ZO_BIT)
X#define CGLM_CLIP_CONTROL_LH_NO (CGLM_CLIP_CONTROL_LH_BIT | CGLM_CLIP_CONTROL_NO_BIT)
X#define CGLM_CLIP_CONTROL_RH_ZO (CGLM_CLIP_CONTROL_RH_BIT | CGLM_CLIP_CONTROL_ZO_BIT)
X#define CGLM_CLIP_CONTROL_RH_NO (CGLM_CLIP_CONTROL_RH_BIT | CGLM_CLIP_CONTROL_NO_BIT)
X
X#ifdef CGLM_FORCE_DEPTH_ZERO_TO_ONE
X#  ifdef CGLM_FORCE_LEFT_HANDED
X#    define CGLM_CONFIG_CLIP_CONTROL CGLM_CLIP_CONTROL_LH_ZO
X#  else
X#    define CGLM_CONFIG_CLIP_CONTROL CGLM_CLIP_CONTROL_RH_ZO
X#  endif
X#else
X#  ifdef CGLM_FORCE_LEFT_HANDED
X#    define CGLM_CONFIG_CLIP_CONTROL CGLM_CLIP_CONTROL_LH_NO
X#  else
X#    define CGLM_CONFIG_CLIP_CONTROL CGLM_CLIP_CONTROL_RH_NO
X#  endif
X#endif
X
X/* struct API configurator */
X/* TODO: move struct/common.h? */
X/* WARN: dont use concant helpers outside cglm headers, because they may be changed */
X
X#define CGLM_MACRO_CONCAT_HELPER(A, B, C, D, E, ...) A ## B ## C ## D ## E ## __VA_ARGS__
X#define CGLM_MACRO_CONCAT(A, B, C, D, E, ...) CGLM_MACRO_CONCAT_HELPER(A, B, C, D, E,__VA_ARGS__)
X
X#ifndef CGLM_OMIT_NS_FROM_STRUCT_API
X#  ifndef CGLM_STRUCT_API_NS
X#    define CGLM_STRUCT_API_NS glms
X#  endif
X#  ifndef CGLM_STRUCT_API_NS_SEPERATOR
X#    define CGLM_STRUCT_API_NS_SEPERATOR _
X#  endif
X#else
X#  define CGLM_STRUCT_API_NS
X#  define CGLM_STRUCT_API_NS_SEPERATOR
X#endif
X
X#ifndef CGLM_STRUCT_API_NAME_SUFFIX
X#  define CGLM_STRUCT_API_NAME_SUFFIX
X#endif
X
X#define CGLM_STRUCTAPI(A, ...) CGLM_MACRO_CONCAT(CGLM_STRUCT_API_NS,             \
X                                                 CGLM_STRUCT_API_NS_SEPERATOR,   \
X                                                 A,                              \
X                                                 CGLM_STRUCT_API_NAME_SUFFIX,    \
X                                                 _,                              \
X                                                 __VA_ARGS__)
X
X#endif /* cglm_common_h */
f8694d16671dbd8b06cd994499637ea4
echo x - cglm/types.h
sed 's/^X//' >cglm/types.h << '189468ec18902b3f4b3d9ac24c5866ed'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_types_h
X#define cglm_types_h
X
X#if (defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L)
X# include <stdalign.h>
X#endif
X
X#if defined(_MSC_VER)
X/* do not use alignment for older visual studio versions */
X#  if _MSC_VER < 1913 /*  Visual Studio 2017 version 15.6  */
X#    define CGLM_ALL_UNALIGNED
X#    define CGLM_ALIGN(X) /* no alignment */
X#  else
X#    define CGLM_ALIGN(X) __declspec(align(X))
X#  endif
X#else
X#  define CGLM_ALIGN(X) __attribute((aligned(X)))
X#endif
X
X#ifndef CGLM_ALL_UNALIGNED
X#  define CGLM_ALIGN_IF(X) CGLM_ALIGN(X)
X#else
X#  define CGLM_ALIGN_IF(X) /* no alignment */
X#endif
X
X#ifdef __AVX__
X#  define CGLM_ALIGN_MAT CGLM_ALIGN(32)
X#else
X#  define CGLM_ALIGN_MAT CGLM_ALIGN(16)
X#endif
X
X#ifndef CGLM_HAVE_BUILTIN_ASSUME_ALIGNED
X
X#  if defined(__has_builtin)
X#    if __has_builtin(__builtin_assume_aligned)
X#      define CGLM_HAVE_BUILTIN_ASSUME_ALIGNED 1
X#    endif
X#  elif defined(__GNUC__) && defined(__GNUC_MINOR__)
X#    if __GNUC__ >= 4 && __GNUC_MINOR__ >= 7
X#      define CGLM_HAVE_BUILTIN_ASSUME_ALIGNED 1
X#    endif
X#  endif
X
X#  ifndef CGLM_HAVE_BUILTIN_ASSUME_ALIGNED
X#    define CGLM_HAVE_BUILTIN_ASSUME_ALIGNED 0
X#  endif
X
X#endif
X
X#if CGLM_HAVE_BUILTIN_ASSUME_ALIGNED
X#  define CGLM_ASSUME_ALIGNED(expr, alignment) \
X     __builtin_assume_aligned((expr), (alignment))
X#else
X#  define CGLM_ASSUME_ALIGNED(expr, alignment) (expr)
X#endif
X
X#if (defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L)
X# define CGLM_CASTPTR_ASSUME_ALIGNED(expr, type) \
X   ((type*)CGLM_ASSUME_ALIGNED((expr), alignof(type)))
X#elif defined(_MSC_VER)
X# define CGLM_CASTPTR_ASSUME_ALIGNED(expr, type) \
X   ((type*)CGLM_ASSUME_ALIGNED((expr), __alignof(type)))
X#else
X# define CGLM_CASTPTR_ASSUME_ALIGNED(expr, type) \
X   ((type*)CGLM_ASSUME_ALIGNED((expr), __alignof__(type)))
X#endif
X
Xtypedef int                     ivec2[2];
Xtypedef int                     ivec3[3];
Xtypedef int                     ivec4[4];
X
Xtypedef float                   vec2[2];
Xtypedef float                   vec3[3];
Xtypedef CGLM_ALIGN_IF(16) float vec4[4];
Xtypedef vec4                    versor;     /* |x, y, z, w| -> w is the last */
Xtypedef vec3                    mat3[3];
Xtypedef vec2                    mat3x2[3];  /* [col (3), row (2)] */
Xtypedef vec4                    mat3x4[3];  /* [col (3), row (4)] */
Xtypedef CGLM_ALIGN_IF(16) vec2  mat2[2];
Xtypedef vec3                    mat2x3[2];  /* [col (2), row (3)] */
Xtypedef vec4                    mat2x4[2];  /* [col (2), row (4)] */
Xtypedef CGLM_ALIGN_MAT    vec4  mat4[4];
Xtypedef vec2                    mat4x2[4];  /* [col (4), row (2)] */
Xtypedef vec3                    mat4x3[4];  /* [col (4), row (3)] */
X
X/*
X  Important: cglm stores quaternion as [x, y, z, w] in memory since v0.4.0 
X  it was [w, x, y, z] before v0.4.0 ( v0.3.5 and earlier ). w is real part.
X*/
X
X#define GLM_E         2.71828182845904523536028747135266250   /* e           */
X#define GLM_LOG2E     1.44269504088896340735992468100189214   /* log2(e)     */
X#define GLM_LOG10E    0.434294481903251827651128918916605082  /* log10(e)    */
X#define GLM_LN2       0.693147180559945309417232121458176568  /* loge(2)     */
X#define GLM_LN10      2.30258509299404568401799145468436421   /* loge(10)    */
X#define GLM_PI        3.14159265358979323846264338327950288   /* pi          */
X#define GLM_PI_2      1.57079632679489661923132169163975144   /* pi/2        */
X#define GLM_PI_4      0.785398163397448309615660845819875721  /* pi/4        */
X#define GLM_1_PI      0.318309886183790671537767526745028724  /* 1/pi        */
X#define GLM_2_PI      0.636619772367581343075535053490057448  /* 2/pi        */
X#define GLM_2_SQRTPI  1.12837916709551257389615890312154517   /* 2/sqrt(pi)  */
X#define GLM_SQRT2     1.41421356237309504880168872420969808   /* sqrt(2)     */
X#define GLM_SQRT1_2   0.707106781186547524400844362104849039  /* 1/sqrt(2)   */
X
X#define GLM_Ef        ((float)GLM_E)
X#define GLM_LOG2Ef    ((float)GLM_LOG2E)
X#define GLM_LOG10Ef   ((float)GLM_LOG10E)
X#define GLM_LN2f      ((float)GLM_LN2)
X#define GLM_LN10f     ((float)GLM_LN10)
X#define GLM_PIf       ((float)GLM_PI)
X#define GLM_PI_2f     ((float)GLM_PI_2)
X#define GLM_PI_4f     ((float)GLM_PI_4)
X#define GLM_1_PIf     ((float)GLM_1_PI)
X#define GLM_2_PIf     ((float)GLM_2_PI)
X#define GLM_2_SQRTPIf ((float)GLM_2_SQRTPI)
X#define GLM_SQRT2f    ((float)GLM_SQRT2)
X#define GLM_SQRT1_2f  ((float)GLM_SQRT1_2)
X
X/* DEPRECATED! use GLM_PI and friends */
X#define CGLM_PI       GLM_PIf
X#define CGLM_PI_2     GLM_PI_2f
X#define CGLM_PI_4     GLM_PI_4f
X
X#endif /* cglm_types_h */
189468ec18902b3f4b3d9ac24c5866ed
echo x - cglm/types-struct.h
sed 's/^X//' >cglm/types-struct.h << 'dc70e5ed76127b1afd69a7aa1c4f9510'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_types_struct_h
X#define cglm_types_struct_h
X
X#include "types.h"
X
X/*
X * Anonymous structs are available since C11, but we'd like to be compatible
X * with C99 and C89 too. So let's figure out if we should be using them or not.
X * It's simply a convenience feature, you can e.g. build the library with
X * anonymous structs and your application without them and they'll still be
X * compatible, cglm doesn't use the anonymous structs internally.
X */
X#ifndef CGLM_USE_ANONYMOUS_STRUCT
X   /* If the user doesn't explicitly specify if they want anonymous structs or
X    * not, then we'll try to intuit an appropriate choice. */
X#  if defined(CGLM_NO_ANONYMOUS_STRUCT)
X     /* The user has defined CGLM_NO_ANONYMOUS_STRUCT. This used to be the
X      * only #define governing the use of anonymous structs, so for backward
X      * compatibility, we still honor that choice and disable them. */
X#    define CGLM_USE_ANONYMOUS_STRUCT 0
X#  elif (defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L) || \
X        (defined(__cplusplus)      && __cplusplus >= 201103L)
X     /* We're compiling for C11 or this is the MSVC compiler. In either
X      * case, anonymous structs are available, so use them. */
X#    define CGLM_USE_ANONYMOUS_STRUCT 1
X#  elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6))
X     /* GCC 4.6 and onwards support anonymous structs as an extension */
X#    define CGLM_USE_ANONYMOUS_STRUCT 1
X#  elif defined(__clang__) && __clang_major__ >= 3
X     /* Clang 3.0 and onwards support anonymous structs as an extension */
X#    define CGLM_USE_ANONYMOUS_STRUCT 1
X#  elif defined(_MSC_VER) && (_MSC_VER >= 1900) /*  Visual Studio 2015 */
X     /* We can support anonymous structs
X      * since Visual Studio 2015 or 2017 (1910) maybe? */
X#    define CGLM_USE_ANONYMOUS_STRUCT 1
X#  else
X     /* Otherwise, we're presumably building for C99 or C89 and can't rely
X      * on anonymous structs being available. Turn them off. */
X#    define CGLM_USE_ANONYMOUS_STRUCT 0
X#  endif
X#endif
X
Xtypedef union vec2s {
X  vec2 raw;
X#if CGLM_USE_ANONYMOUS_STRUCT
X  struct {
X    float x;
X    float y;
X  };
X  
X  struct {
X    float r;
X    float i;
X  };
X  
X  struct {
X    float u;
X    float v;
X  };
X  
X  struct {
X    float s;
X    float t;
X  };
X#endif
X} vec2s;
X
Xtypedef union vec3s {
X  vec3 raw;
X#if CGLM_USE_ANONYMOUS_STRUCT
X  struct {
X    float x;
X    float y;
X    float z;
X  };
X  
X  struct {
X    float r;
X    float g;
X    float b;
X  };
X#endif
X} vec3s;
X
Xtypedef union ivec2s {
X  ivec2 raw;
X#if CGLM_USE_ANONYMOUS_STRUCT
X  struct {
X    int x;
X    int y;
X  };
X  
X  struct {
X    int r;
X    int i;
X  };
X  
X  struct {
X    int u;
X    int v;
X  };
X  
X  struct {
X    int s;
X    int t;
X  };
X#endif
X} ivec2s;
X
Xtypedef union ivec3s {
X  ivec3 raw;
X#if CGLM_USE_ANONYMOUS_STRUCT
X  struct {
X    int x;
X    int y;
X    int z;
X  };
X  
X  struct {
X    int r;
X    int g;
X    int b;
X  };
X#endif
X} ivec3s;
X
Xtypedef union ivec4s {
X  ivec4 raw;
X#if CGLM_USE_ANONYMOUS_STRUCT
X  struct {
X    int x;
X    int y;
X    int z;
X    int w;
X  };
X  
X  struct {
X    int r;
X    int g;
X    int b;
X    int a;
X  };
X#endif
X} ivec4s;
X
Xtypedef union CGLM_ALIGN_IF(16) vec4s {
X  vec4 raw;
X#if CGLM_USE_ANONYMOUS_STRUCT
X  struct {
X    float x;
X    float y;
X    float z;
X    float w;
X  };
X  
X  struct {
X    float r;
X    float g;
X    float b;
X    float a;
X  };
X#endif
X} vec4s;
X
Xtypedef union CGLM_ALIGN_IF(16) versors {
X  vec4 raw;
X#if CGLM_USE_ANONYMOUS_STRUCT
X  struct {
X    float x;
X    float y;
X    float z;
X    float w;
X  };
X
X  struct {
X    vec3s imag;
X    float real;
X  };
X#endif
X} versors;
X
Xtypedef union mat2s {
X  mat2  raw;
X  vec2s col[2];
X#if CGLM_USE_ANONYMOUS_STRUCT
X  struct {
X    float m00, m01;
X    float m10, m11;
X  };
X#endif
X} mat2s;
X
Xtypedef union mat2x3s {
X  mat2x3 raw;
X  vec3s  col[2]; /* [col (2), row (3)] */
X#if CGLM_USE_ANONYMOUS_STRUCT
X  struct {
X    float m00, m01, m02;
X    float m10, m11, m12;
X  };
X#endif
X} mat2x3s;
X
Xtypedef union mat2x4s {
X  mat2x4 raw;
X  vec4s  col[2]; /* [col (2), row (4)] */
X#if CGLM_USE_ANONYMOUS_STRUCT
X  struct {
X    float m00, m01, m02, m03;
X    float m10, m11, m12, m13;
X  };
X#endif
X} mat2x4s;
X
Xtypedef union mat3s {
X  mat3  raw;
X  vec3s col[3];
X#if CGLM_USE_ANONYMOUS_STRUCT
X  struct {
X    float m00, m01, m02;
X    float m10, m11, m12;
X    float m20, m21, m22;
X  };
X#endif
X} mat3s;
X
Xtypedef union mat3x2s {
X  mat3x2 raw;
X  vec2s  col[3]; /* [col (3), row (2)] */
X#if CGLM_USE_ANONYMOUS_STRUCT
X  struct {
X    float m00, m01;
X    float m10, m11;
X    float m20, m21;
X  };
X#endif
X} mat3x2s;
X
Xtypedef union mat3x4s {
X  mat3x4 raw;
X  vec4s  col[3]; /* [col (3), row (4)] */
X#if CGLM_USE_ANONYMOUS_STRUCT
X  struct {
X    float m00, m01, m02, m03;
X    float m10, m11, m12, m13;
X    float m20, m21, m22, m23;
X  };
X#endif
X} mat3x4s;
X
Xtypedef union CGLM_ALIGN_MAT mat4s {
X  mat4  raw;
X  vec4s col[4];
X#if CGLM_USE_ANONYMOUS_STRUCT
X  struct {
X    float m00, m01, m02, m03;
X    float m10, m11, m12, m13;
X    float m20, m21, m22, m23;
X    float m30, m31, m32, m33;
X  };
X#endif
X} mat4s;
X
Xtypedef union mat4x2s {
X  mat4x2 raw;
X  vec2s  col[4]; /* [col (4), row (2)] */
X#if CGLM_USE_ANONYMOUS_STRUCT
X  struct {
X    float m00, m01;
X    float m10, m11;
X    float m20, m21;
X    float m30, m31;
X  };
X#endif
X} mat4x2s;
X
Xtypedef union mat4x3s {
X  mat4x3 raw;
X  vec3s  col[4]; /* [col (4), row (3)] */
X#if CGLM_USE_ANONYMOUS_STRUCT
X  struct {
X    float m00, m01, m02;
X    float m10, m11, m12;
X    float m20, m21, m22;
X    float m30, m31, m32;
X  };
X#endif
X} mat4x3s;
X
X#endif /* cglm_types_struct_h */
dc70e5ed76127b1afd69a7aa1c4f9510
echo x - cglm/cglm.h
sed 's/^X//' >cglm/cglm.h << 'a5fcc937e4d34d183c96ec7c4bd88a0f'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_h
X#define cglm_h
X
X#include "common.h"
X#include "vec2.h"
X#include "vec3.h"
X#include "vec4.h"
X#include "ivec2.h"
X#include "ivec3.h"
X#include "ivec4.h"
X#include "mat4.h"
X#include "mat4x2.h"
X#include "mat4x3.h"
X#include "mat3.h"
X#include "mat3x2.h"
X#include "mat3x4.h"
X#include "mat2.h"
X#include "mat2x3.h"
X#include "mat2x4.h"
X#include "affine.h"
X#include "cam.h"
X#include "frustum.h"
X#include "quat.h"
X#include "euler.h"
X#include "plane.h"
X#include "aabb2d.h"
X#include "box.h"
X#include "color.h"
X#include "util.h"
X#include "io.h"
X#include "project.h"
X#include "sphere.h"
X#include "ease.h"
X#include "curve.h"
X#include "bezier.h"
X#include "ray.h"
X#include "affine2d.h"
X
X#endif /* cglm_h */
a5fcc937e4d34d183c96ec7c4bd88a0f
echo x - cglm/call.h
sed 's/^X//' >cglm/call.h << 'ac58acf258a0b9cdcb9f5734227a7165'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_call_h
X#define cglm_call_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "cglm.h"
X#include "call/vec2.h"
X#include "call/vec3.h"
X#include "call/vec4.h"
X#include "call/ivec2.h"
X#include "call/ivec3.h"
X#include "call/ivec4.h"
X#include "call/mat2.h"
X#include "call/mat2x3.h"
X#include "call/mat2x4.h"
X#include "call/mat3.h"
X#include "call/mat3x2.h"
X#include "call/mat3x4.h"
X#include "call/mat4.h"
X#include "call/mat4x2.h"
X#include "call/mat4x3.h"
X#include "call/affine.h"
X#include "call/cam.h"
X#include "call/quat.h"
X#include "call/euler.h"
X#include "call/plane.h"
X#include "call/frustum.h"
X#include "call/aabb2d.h"
X#include "call/box.h"
X#include "call/io.h"
X#include "call/project.h"
X#include "call/sphere.h"
X#include "call/ease.h"
X#include "call/curve.h"
X#include "call/bezier.h"
X#include "call/ray.h"
X#include "call/affine2d.h"
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglm_call_h */
ac58acf258a0b9cdcb9f5734227a7165
echo x - cglm/struct.h
sed 's/^X//' >cglm/struct.h << 'a683b829014b67a33bc0c25da4c9f05b'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_structs_h
X#define cglm_structs_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "cglm.h"
X#include "types-struct.h"
X#include "struct/vec2.h"
X#include "struct/vec3.h"
X#include "struct/vec4.h"
X#include "struct/mat2.h"
X#include "struct/mat2x3.h"
X#include "struct/mat2x4.h"
X#include "struct/mat3.h"
X#include "struct/mat3x2.h"
X#include "struct/mat3x4.h"
X#include "struct/mat4.h"
X#include "struct/mat4x2.h"
X#include "struct/mat4x3.h"
X#include "struct/affine.h"
X#include "struct/frustum.h"
X#include "struct/plane.h"
X#include "struct/box.h"
X#include "struct/color.h"
X#include "struct/io.h"
X#include "struct/cam.h"
X#include "struct/quat.h"
X#include "struct/euler.h"
X#include "struct/project.h"
X#include "struct/sphere.h"
X#include "struct/curve.h"
X#include "struct/affine2d.h"
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglm_structs_h */
a683b829014b67a33bc0c25da4c9f05b
echo x - cglm/cam.h
sed 's/^X//' >cglm/cam.h << 'c05f36a363c9ccfab46c96ce5e53d161'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Functions:
X   CGLM_INLINE void  glm_frustum(float left,   float right,
X                                 float bottom, float top,
X                                 float nearZ,  float farZ,
X                                 mat4  dest)
X   CGLM_INLINE void  glm_ortho(float left,   float right,
X                               float bottom, float top,
X                               float nearZ,  float farZ,
X                               mat4  dest)
X   CGLM_INLINE void  glm_ortho_aabb(vec3 box[2], mat4 dest)
X   CGLM_INLINE void  glm_ortho_aabb_p(vec3 box[2],  float padding, mat4 dest)
X   CGLM_INLINE void  glm_ortho_aabb_pz(vec3 box[2], float padding, mat4 dest)
X   CGLM_INLINE void  glm_ortho_default(float aspect, mat4  dest)
X   CGLM_INLINE void  glm_ortho_default_s(float aspect, float size, mat4 dest)
X   CGLM_INLINE void  glm_perspective(float fovy,
X                                     float aspect,
X                                     float nearZ,
X                                     float farZ,
X                                     mat4  dest)
X   CGLM_INLINE void  glm_perspective_default(float aspect, mat4 dest)
X   CGLM_INLINE void  glm_perspective_resize(float aspect, mat4 proj)
X   CGLM_INLINE void  glm_lookat(vec3 eye, vec3 center, vec3 up, mat4 dest)
X   CGLM_INLINE void  glm_look(vec3 eye, vec3 dir, vec3 up, mat4 dest)
X   CGLM_INLINE void  glm_look_anyup(vec3 eye, vec3 dir, mat4 dest)
X   CGLM_INLINE void  glm_persp_decomp(mat4   proj,
X                                      float *nearZ, float *farZ,
X                                      float *top,   float *bottom,
X                                      float *left,  float *right)
X   CGLM_INLINE void  glm_persp_decompv(mat4 proj, float dest[6])
X   CGLM_INLINE void  glm_persp_decomp_x(mat4 proj, float *left, float *right)
X   CGLM_INLINE void  glm_persp_decomp_y(mat4 proj, float *top,  float *bottom)
X   CGLM_INLINE void  glm_persp_decomp_z(mat4 proj, float *nearv, float *farv)
X   CGLM_INLINE void  glm_persp_decomp_far(mat4 proj, float *farZ)
X   CGLM_INLINE void  glm_persp_decomp_near(mat4 proj, float *nearZ)
X   CGLM_INLINE float glm_persp_fovy(mat4 proj)
X   CGLM_INLINE float glm_persp_aspect(mat4 proj)
X   CGLM_INLINE void  glm_persp_sizes(mat4 proj, float fovy, vec4 dest)
X */
X
X#ifndef cglm_cam_h
X#define cglm_cam_h
X
X#include "common.h"
X#include "plane.h"
X
X#include "clipspace/persp.h"
X
X#ifndef CGLM_CLIPSPACE_INCLUDE_ALL
X#  if CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_ZO
X#    include "clipspace/ortho_lh_zo.h"
X#    include "clipspace/persp_lh_zo.h"
X#    include "clipspace/view_lh_zo.h"
X#  elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_NO
X#    include "clipspace/ortho_lh_no.h"
X#    include "clipspace/persp_lh_no.h"
X#    include "clipspace/view_lh_no.h"
X#  elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_ZO
X#    include "clipspace/ortho_rh_zo.h"
X#    include "clipspace/persp_rh_zo.h"
X#    include "clipspace/view_rh_zo.h"
X#  elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_NO
X#    include "clipspace/ortho_rh_no.h"
X#    include "clipspace/persp_rh_no.h"
X#    include "clipspace/view_rh_no.h"
X#  endif
X#else
X#  include "clipspace/ortho_lh_zo.h"
X#  include "clipspace/persp_lh_zo.h"
X#  include "clipspace/ortho_lh_no.h"
X#  include "clipspace/persp_lh_no.h"
X#  include "clipspace/ortho_rh_zo.h"
X#  include "clipspace/persp_rh_zo.h"
X#  include "clipspace/ortho_rh_no.h"
X#  include "clipspace/persp_rh_no.h"
X#  include "clipspace/view_lh_zo.h"
X#  include "clipspace/view_lh_no.h"
X#  include "clipspace/view_rh_zo.h"
X#  include "clipspace/view_rh_no.h"
X#endif
X
X/*!
X * @brief set up perspective peprojection matrix
X *
X * @param[in]  left    viewport.left
X * @param[in]  right   viewport.right
X * @param[in]  bottom  viewport.bottom
X * @param[in]  top     viewport.top
X * @param[in]  nearZ   near clipping plane
X * @param[in]  farZ    far clipping plane
X * @param[out] dest    result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_frustum(float left,    float right,
X            float bottom,  float top,
X            float nearZ,   float farZ,
X            mat4  dest) {
X#if CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_ZO
X  glm_frustum_lh_zo(left, right, bottom, top, nearZ, farZ, dest);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_NO
X  glm_frustum_lh_no(left, right, bottom, top, nearZ, farZ, dest);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_ZO
X  glm_frustum_rh_zo(left, right, bottom, top, nearZ, farZ, dest);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_NO
X  glm_frustum_rh_no(left, right, bottom, top, nearZ, farZ, dest);
X#endif
X}
X
X/*!
X * @brief set up orthographic projection matrix
X *
X * @param[in]  left    viewport.left
X * @param[in]  right   viewport.right
X * @param[in]  bottom  viewport.bottom
X * @param[in]  top     viewport.top
X * @param[in]  nearZ   near clipping plane
X * @param[in]  farZ    far clipping plane
X * @param[out] dest    result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_ortho(float left,    float right,
X          float bottom,  float top,
X          float nearZ,   float farZ,
X          mat4  dest) {
X#if CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_ZO
X  glm_ortho_lh_zo(left, right, bottom, top, nearZ, farZ, dest);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_NO
X  glm_ortho_lh_no(left, right, bottom, top, nearZ, farZ, dest);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_ZO
X  glm_ortho_rh_zo(left, right, bottom, top, nearZ, farZ, dest);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_NO
X  glm_ortho_rh_no(left, right, bottom, top, nearZ, farZ, dest);
X#endif
X}
X
X/*!
X * @brief set up orthographic projection matrix using bounding box
X *
X * bounding box (AABB) must be in view space
X *
X * @param[in]  box   AABB
X * @param[out] dest  result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_ortho_aabb(vec3 box[2], mat4 dest) {
X#if CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_ZO
X  glm_ortho_aabb_lh_zo(box, dest);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_NO
X  glm_ortho_aabb_lh_no(box, dest);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_ZO
X  glm_ortho_aabb_rh_zo(box, dest);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_NO
X  glm_ortho_aabb_rh_no(box, dest);
X#endif
X}
X
X/*!
X * @brief set up orthographic projection matrix using bounding box
X *
X * bounding box (AABB) must be in view space
X *
X * @param[in]  box     AABB
X * @param[in]  padding padding
X * @param[out] dest    result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_ortho_aabb_p(vec3 box[2], float padding, mat4 dest) {
X#if CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_ZO
X  glm_ortho_aabb_p_lh_zo(box, padding, dest);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_NO
X  glm_ortho_aabb_p_lh_no(box, padding, dest);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_ZO
X  glm_ortho_aabb_p_rh_zo(box, padding, dest);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_NO
X  glm_ortho_aabb_p_rh_no(box, padding, dest);
X#endif
X}
X
X/*!
X * @brief set up orthographic projection matrix using bounding box
X *
X * bounding box (AABB) must be in view space
X *
X * @param[in]  box     AABB
X * @param[in]  padding padding for near and far
X * @param[out] dest    result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_ortho_aabb_pz(vec3 box[2], float padding, mat4 dest) {
X#if CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_ZO
X  glm_ortho_aabb_pz_lh_zo(box, padding, dest);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_NO
X  glm_ortho_aabb_pz_lh_no(box, padding, dest);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_ZO
X  glm_ortho_aabb_pz_rh_zo(box, padding, dest);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_NO
X  glm_ortho_aabb_pz_rh_no(box, padding, dest);
X#endif
X}
X
X/*!
X * @brief set up unit orthographic projection matrix
X *
X * @param[in]  aspect aspect ration ( width / height )
X * @param[out] dest   result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_ortho_default(float aspect, mat4 dest) {
X#if CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_ZO
X  glm_ortho_default_lh_zo(aspect, dest);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_NO
X  glm_ortho_default_lh_no(aspect, dest);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_ZO
X  glm_ortho_default_rh_zo(aspect, dest);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_NO
X  glm_ortho_default_rh_no(aspect, dest);
X#endif
X}
X
X/*!
X * @brief set up orthographic projection matrix with given CUBE size
X *
X * @param[in]  aspect aspect ratio ( width / height )
X * @param[in]  size   cube size
X * @param[out] dest   result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_ortho_default_s(float aspect, float size, mat4 dest) {
X#if CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_ZO
X  glm_ortho_default_s_lh_zo(aspect, size, dest);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_NO
X  glm_ortho_default_s_lh_no(aspect, size, dest);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_ZO
X  glm_ortho_default_s_rh_zo(aspect, size, dest);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_NO
X  glm_ortho_default_s_rh_no(aspect, size, dest);
X#endif
X}
X
X/*!
X * @brief set up perspective projection matrix
X *
X * @param[in]  fovy    field of view angle
X * @param[in]  aspect  aspect ratio ( width / height )
X * @param[in]  nearZ   near clipping plane
X * @param[in]  farZ    far clipping planes
X * @param[out] dest    result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_perspective(float fovy, float aspect, float nearZ, float farZ, mat4 dest) {
X#if CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_ZO
X  glm_perspective_lh_zo(fovy, aspect, nearZ, farZ, dest);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_NO
X  glm_perspective_lh_no(fovy, aspect, nearZ, farZ, dest);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_ZO
X  glm_perspective_rh_zo(fovy, aspect, nearZ, farZ, dest);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_NO
X  glm_perspective_rh_no(fovy, aspect, nearZ, farZ, dest);
X#endif
X}
X
X/*!
X * @brief extend perspective projection matrix's far distance
X *
X * this function does not guarantee far >= near, be aware of that!
X *
X * @param[in, out] proj      projection matrix to extend
X * @param[in]      deltaFar  distance from existing far (negative to shink)
X */
XCGLM_INLINE
Xvoid
Xglm_persp_move_far(mat4 proj, float deltaFar) {
X#if CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_ZO
X  glm_persp_move_far_lh_zo(proj, deltaFar);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_NO
X  glm_persp_move_far_lh_no(proj, deltaFar);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_ZO
X  glm_persp_move_far_rh_zo(proj, deltaFar);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_NO
X  glm_persp_move_far_rh_no(proj, deltaFar);
X#endif
X}
X
X/*!
X * @brief set up perspective projection matrix with default near/far
X *        and angle values
X *
X * @param[in]  aspect aspect ratio ( width / height )
X * @param[out] dest   result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_perspective_default(float aspect, mat4 dest) {
X#if CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_ZO
X  glm_perspective_default_lh_zo(aspect, dest);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_NO
X  glm_perspective_default_lh_no(aspect, dest);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_ZO
X  glm_perspective_default_rh_zo(aspect, dest);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_NO
X  glm_perspective_default_rh_no(aspect, dest);
X#endif
X}
X
X/*!
X * @brief resize perspective matrix by aspect ratio ( width / height )
X *        this makes very easy to resize proj matrix when window /viewport
X *        reized
X *
X * @param[in]      aspect aspect ratio ( width / height )
X * @param[in, out] proj   perspective projection matrix
X */
XCGLM_INLINE
Xvoid
Xglm_perspective_resize(float aspect, mat4 proj) {
X  if (proj[0][0] == 0.0f)
X    return;
X
X  proj[0][0] = proj[1][1] / aspect;
X}
X
X/*!
X * @brief set up view matrix
X *
X * NOTE: The UP vector must not be parallel to the line of sight from
X *       the eye point to the reference point
X *
X * @param[in]  eye    eye vector
X * @param[in]  center center vector
X * @param[in]  up     up vector
X * @param[out] dest   result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_lookat(vec3 eye, vec3 center, vec3 up, mat4 dest) {
X#if CGLM_CONFIG_CLIP_CONTROL & CGLM_CLIP_CONTROL_LH_BIT
X  glm_lookat_lh(eye, center, up, dest);
X#elif CGLM_CONFIG_CLIP_CONTROL & CGLM_CLIP_CONTROL_RH_BIT
X  glm_lookat_rh(eye, center, up, dest);
X#endif
X}
X
X/*!
X * @brief set up view matrix
X *
X * convenient wrapper for lookat: if you only have direction not target self
X * then this might be useful. Because you need to get target from direction.
X *
X * NOTE: The UP vector must not be parallel to the line of sight from
X *       the eye point to the reference point
X *
X * @param[in]  eye    eye vector
X * @param[in]  dir    direction vector
X * @param[in]  up     up vector
X * @param[out] dest   result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_look(vec3 eye, vec3 dir, vec3 up, mat4 dest) {
X#if CGLM_CONFIG_CLIP_CONTROL & CGLM_CLIP_CONTROL_LH_BIT
X  glm_look_lh(eye, dir, up, dest);
X#elif CGLM_CONFIG_CLIP_CONTROL & CGLM_CLIP_CONTROL_RH_BIT
X  glm_look_rh(eye, dir, up, dest);
X#endif
X}
X
X/*!
X * @brief set up view matrix
X *
X * convenient wrapper for look: if you only have direction and if you don't
X * care what UP vector is then this might be useful to create view matrix
X *
X * @param[in]  eye    eye vector
X * @param[in]  dir    direction vector
X * @param[out] dest   result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_look_anyup(vec3 eye, vec3 dir, mat4 dest) {
X#if CGLM_CONFIG_CLIP_CONTROL & CGLM_CLIP_CONTROL_LH_BIT
X  glm_look_anyup_lh(eye, dir, dest);
X#elif CGLM_CONFIG_CLIP_CONTROL & CGLM_CLIP_CONTROL_RH_BIT
X  glm_look_anyup_rh(eye, dir, dest);
X#endif
X}
X
X/*!
X * @brief decomposes frustum values of perspective projection.
X *
X * @param[in]  proj    perspective projection matrix
X * @param[out] nearZ   near
X * @param[out] farZ    far
X * @param[out] top     top
X * @param[out] bottom  bottom
X * @param[out] left    left
X * @param[out] right   right
X */
XCGLM_INLINE
Xvoid
Xglm_persp_decomp(mat4 proj,
X                 float * __restrict nearZ, float * __restrict farZ,
X                 float * __restrict top,   float * __restrict bottom,
X                 float * __restrict left,  float * __restrict right) {
X#if CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_ZO
X  glm_persp_decomp_lh_zo(proj, nearZ, farZ, top, bottom, left, right);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_NO
X  glm_persp_decomp_lh_no(proj, nearZ, farZ, top, bottom, left, right);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_ZO
X  glm_persp_decomp_rh_zo(proj, nearZ, farZ, top, bottom, left, right);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_NO
X  glm_persp_decomp_rh_no(proj, nearZ, farZ, top, bottom, left, right);
X#endif
X}
X
X/*!
X * @brief decomposes frustum values of perspective projection.
X *        this makes easy to get all values at once
X *
X * @param[in]  proj   perspective projection matrix
X * @param[out] dest   array
X */
XCGLM_INLINE
Xvoid
Xglm_persp_decompv(mat4 proj, float dest[6]) {
X#if CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_ZO
X  glm_persp_decompv_lh_zo(proj, dest);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_NO
X  glm_persp_decompv_lh_no(proj, dest);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_ZO
X  glm_persp_decompv_rh_zo(proj, dest);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_NO
X  glm_persp_decompv_rh_no(proj, dest);
X#endif
X}
X
X/*!
X * @brief decomposes left and right values of perspective projection.
X *        x stands for x axis (left / right axis)
X *
X * @param[in]  proj  perspective projection matrix
X * @param[out] left  left
X * @param[out] right right
X */
XCGLM_INLINE
Xvoid
Xglm_persp_decomp_x(mat4 proj,
X                   float * __restrict left,
X                   float * __restrict right) {
X#if CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_ZO
X  glm_persp_decomp_x_lh_zo(proj, left, right);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_NO
X  glm_persp_decomp_x_lh_no(proj, left, right);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_ZO
X  glm_persp_decomp_x_rh_zo(proj, left, right);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_NO
X  glm_persp_decomp_x_rh_no(proj, left, right);
X#endif
X}
X
X/*!
X * @brief decomposes top and bottom values of perspective projection.
X *        y stands for y axis (top / botom axis)
X *
X * @param[in]  proj   perspective projection matrix
X * @param[out] top    top
X * @param[out] bottom bottom
X */
XCGLM_INLINE
Xvoid
Xglm_persp_decomp_y(mat4 proj,
X                   float * __restrict top,
X                   float * __restrict bottom) {
X#if CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_ZO
X  glm_persp_decomp_y_lh_zo(proj, top, bottom);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_NO
X  glm_persp_decomp_y_lh_no(proj, top, bottom);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_ZO
X  glm_persp_decomp_y_rh_zo(proj, top, bottom);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_NO
X  glm_persp_decomp_y_rh_no(proj, top, bottom);
X#endif
X}
X
X/*!
X * @brief decomposes near and far values of perspective projection.
X *        z stands for z axis (near / far axis)
X *
X * @param[in]  proj    perspective projection matrix
X * @param[out] nearZ   near
X * @param[out] farZ    far
X */
XCGLM_INLINE
Xvoid
Xglm_persp_decomp_z(mat4 proj, float * __restrict nearZ, float * __restrict farZ) {
X#if CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_ZO
X  glm_persp_decomp_z_lh_zo(proj, nearZ, farZ);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_NO
X  glm_persp_decomp_z_lh_no(proj, nearZ, farZ);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_ZO
X  glm_persp_decomp_z_rh_zo(proj, nearZ, farZ);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_NO
X  glm_persp_decomp_z_rh_no(proj, nearZ, farZ);
X#endif
X}
X
X/*!
X * @brief decomposes far value of perspective projection.
X *
X * @param[in]  proj   perspective projection matrix
X * @param[out] farZ   far
X */
XCGLM_INLINE
Xvoid
Xglm_persp_decomp_far(mat4 proj, float * __restrict farZ) {
X#if CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_ZO
X  glm_persp_decomp_far_lh_zo(proj, farZ);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_NO
X  glm_persp_decomp_far_lh_no(proj, farZ);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_ZO
X  glm_persp_decomp_far_rh_zo(proj, farZ);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_NO
X  glm_persp_decomp_far_rh_no(proj, farZ);
X#endif
X}
X
X/*!
X * @brief decomposes near value of perspective projection.
X *
X * @param[in]  proj   perspective projection matrix
X * @param[out] nearZ  near
X */
XCGLM_INLINE
Xvoid
Xglm_persp_decomp_near(mat4 proj, float * __restrict nearZ) {
X#if CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_ZO
X  glm_persp_decomp_near_lh_zo(proj, nearZ);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_NO
X  glm_persp_decomp_near_lh_no(proj, nearZ);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_ZO
X  glm_persp_decomp_near_rh_zo(proj, nearZ);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_NO
X  glm_persp_decomp_near_rh_no(proj, nearZ);
X#endif
X}
X
X/*!
X * @brief returns sizes of near and far planes of perspective projection
X *
X * @param[in]  proj perspective projection matrix
X * @param[in]  fovy fovy (see brief)
X * @param[out] dest sizes order: [Wnear, Hnear, Wfar, Hfar]
X */
XCGLM_INLINE
Xvoid
Xglm_persp_sizes(mat4 proj, float fovy, vec4 dest) {
X#if CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_ZO
X  glm_persp_sizes_lh_zo(proj, fovy, dest);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_NO
X  glm_persp_sizes_lh_no(proj, fovy, dest);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_ZO
X  glm_persp_sizes_rh_zo(proj, fovy, dest);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_NO
X  glm_persp_sizes_rh_no(proj, fovy, dest);
X#endif
X}
X
X#endif /* cglm_cam_h */
c05f36a363c9ccfab46c96ce5e53d161
echo x - cglm/io.h
sed 's/^X//' >cglm/io.h << '63693ed6831842533808e4e88fabc9d9'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Functions:
X   CGLM_INLINE void glm_mat4_print(mat4 matrix, FILE *ostream);
X   CGLM_INLINE void glm_mat3_print(mat3 matrix, FILE *ostream);
X   CGLM_INLINE void glm_vec4_print(vec4 vec, FILE *ostream);
X   CGLM_INLINE void glm_ivec4_print(ivec4 vec, FILE *ostream);
X   CGLM_INLINE void glm_vec3_print(vec3 vec, FILE *ostream);
X   CGLM_INLINE void glm_ivec3_print(ivec3 vec, FILE *ostream);
X   CGLM_INLINE void glm_vec2_print(vec2 vec, FILE *ostream);
X   CGLM_INLINE void glm_ivec2_print(ivec2 vec, FILE *ostream);
X   CGLM_INLINE void glm_versor_print(versor vec, FILE *ostream);
X   CGLM_INLINE void glm_arch_print(FILE *ostream);
X */
X
X/*
X cglm tried to enable print functions in debug mode and disable them in
X release/production mode to eliminate printing costs.
X 
X if you need to force enable then define CGLM_DEFINE_PRINTS macro not DEBUG one
X 
X Print functions are enabled if:
X 
X - DEBUG or _DEBUG macro is defined (mostly defined automatically in debugging)
X - CGLM_DEFINE_PRINTS macro is defined including release/production
X   which makes enabled printing always
X - glmc_ calls for io are always prints
X
X */
X
X/* DEPRECATED: CGLM_NO_PRINTS_NOOP (use CGLM_DEFINE_PRINTS) */
X
X#ifndef cglm_io_h
X#define cglm_io_h
X#if defined(DEBUG) || defined(_DEBUG) \
X   || defined(CGLM_DEFINE_PRINTS) || defined(CGLM_LIB_SRC) \
X   || defined(CGLM_NO_PRINTS_NOOP)
X
X#include "common.h"
X#include "util.h"
X
X#include <stdio.h>
X#include <stdlib.h>
X
X#ifndef CGLM_PRINT_PRECISION
X#  define CGLM_PRINT_PRECISION    5
X#endif
X
X#ifndef CGLM_PRINT_MAX_TO_SHORT
X#  define CGLM_PRINT_MAX_TO_SHORT 1e5f
X#endif
X
X#ifndef GLM_TESTS_NO_COLORFUL_OUTPUT
X#  ifndef CGLM_PRINT_COLOR
X#    define CGLM_PRINT_COLOR        "\033[36m"
X#  endif
X#  ifndef CGLM_PRINT_COLOR_RESET
X#    define CGLM_PRINT_COLOR_RESET  "\033[0m"
X#  endif
X#else
X#  ifndef CGLM_PRINT_COLOR
X#    define CGLM_PRINT_COLOR
X#  endif
X#  ifndef CGLM_PRINT_COLOR_RESET
X#    define CGLM_PRINT_COLOR_RESET
X#  endif
X#endif
X
X/*!
X * @brief prints current SIMD path in general
X *
X * @param[in] ostream    stream to print e.g. stdout, stderr, FILE ...
X */
XCGLM_INLINE
Xvoid
Xglm_arch_print(FILE* __restrict ostream) {
X  fprintf(ostream, CGLM_PRINT_COLOR "arch: "
X#if defined(CGLM_SIMD_WASM)
X  "wasm SIMD128"
X#elif defined(CGLM_SIMD_x86)
X  "x86 SSE* "
X#  ifdef __AVX__
X  " AVX"
X#  endif
X#elif defined(CGLM_SIMD_ARM)
X  "arm"
X#  ifndef __ARM_NEON_FP
X    " NEON_FP"
X#  endif
X#  ifdef CGLM_ARM64
X    " ARM64"
X#  endif
X#else
X  "uncommon"
X#endif
X  CGLM_PRINT_COLOR_RESET);
X}
X
X/*!
X * @brief prints current SIMD path in general
X *
X * @param[in] ostream    stream to print e.g. stdout, stderr, FILE ...
X */
XCGLM_INLINE
Xvoid
Xglm_arch_print_name(FILE* __restrict ostream) {
X  fprintf(ostream, CGLM_PRINT_COLOR "\ncglm ");
X  glm_arch_print(ostream);
X  fprintf(ostream, "\n\n" CGLM_PRINT_COLOR_RESET);
X}
X
XCGLM_INLINE
Xvoid
Xglm_mat4_print(mat4              matrix,
X               FILE * __restrict ostream) {
X  char buff[16];
X  int  i, j, cw[4], cwi;
X
X#define m 4
X#define n 4
X
X  fprintf(ostream, "Matrix (float%dx%d): " CGLM_PRINT_COLOR "\n" , m, n);
X
X  cw[0] = cw[1] = cw[2] = cw[3] = 0;
X
X  for (i = 0; i < m; i++) {
X    for (j = 0; j < n; j++) {
X      if (matrix[i][j] < CGLM_PRINT_MAX_TO_SHORT)
X        cwi = sprintf(buff, "% .*f", CGLM_PRINT_PRECISION, (double)matrix[i][j]);
X      else
X        cwi = sprintf(buff, "% g", (double)matrix[i][j]);
X      cw[i] = GLM_MAX(cw[i], cwi);
X    }
X  }
X
X  for (i = 0; i < m; i++) {
X    fprintf(ostream, "  |");
X
X    for (j = 0; j < n; j++)
X      if (matrix[i][j] < CGLM_PRINT_MAX_TO_SHORT)
X        fprintf(ostream, " % *.*f", cw[j], CGLM_PRINT_PRECISION, (double)matrix[j][i]);
X      else
X        fprintf(ostream, " % *g", cw[j], (double)matrix[j][i]);
X
X    fprintf(ostream, "  |\n");
X  }
X
X  fprintf(ostream, CGLM_PRINT_COLOR_RESET "\n");
X
X#undef m
X#undef n
X}
X
X
XCGLM_INLINE
Xvoid
Xglm_mat3_print(mat3              matrix,
X               FILE * __restrict ostream) {
X  char buff[16];
X  int  i, j, cw[4], cwi;
X
X#define m 3
X#define n 3
X
X  fprintf(ostream, "Matrix (float%dx%d): " CGLM_PRINT_COLOR "\n", m, n);
X
X  cw[0] = cw[1] = cw[2] = 0;
X
X  for (i = 0; i < m; i++) {
X    for (j = 0; j < n; j++) {
X      if (matrix[i][j] < CGLM_PRINT_MAX_TO_SHORT)
X        cwi = sprintf(buff, "% .*f", CGLM_PRINT_PRECISION, (double)matrix[i][j]);
X      else
X        cwi = sprintf(buff, "% g", (double)matrix[i][j]);
X      cw[i] = GLM_MAX(cw[i], cwi);
X    }
X  }
X
X  for (i = 0; i < m; i++) {
X    fprintf(ostream, "  |");
X
X    for (j = 0; j < n; j++)
X      if (matrix[i][j] < CGLM_PRINT_MAX_TO_SHORT)
X        fprintf(ostream, " % *.*f", cw[j], CGLM_PRINT_PRECISION, (double)matrix[j][i]);
X      else
X        fprintf(ostream, " % *g", cw[j], (double)matrix[j][i]);
X
X    fprintf(ostream, "  |\n");
X  }
X
X  fprintf(ostream, CGLM_PRINT_COLOR_RESET "\n");
X
X#undef m
X#undef n
X}
X
XCGLM_INLINE
Xvoid
Xglm_mat2_print(mat2              matrix,
X               FILE * __restrict ostream) {
X  char buff[16];
X  int  i, j, cw[4], cwi;
X
X#define m 2
X#define n 2
X
X  fprintf(ostream, "Matrix (float%dx%d): " CGLM_PRINT_COLOR "\n", m, n);
X
X  cw[0] = cw[1] = 0;
X
X  for (i = 0; i < m; i++) {
X    for (j = 0; j < n; j++) {
X      if (matrix[i][j] < CGLM_PRINT_MAX_TO_SHORT)
X        cwi = sprintf(buff, "% .*f", CGLM_PRINT_PRECISION, (double)matrix[i][j]);
X      else
X        cwi = sprintf(buff, "% g", (double)matrix[i][j]);
X      cw[i] = GLM_MAX(cw[i], cwi);
X    }
X  }
X
X  for (i = 0; i < m; i++) {
X    fprintf(ostream, "  |");
X
X    for (j = 0; j < n; j++)
X      if (matrix[i][j] < CGLM_PRINT_MAX_TO_SHORT)
X        fprintf(ostream, " % *.*f", cw[j], CGLM_PRINT_PRECISION, (double)matrix[j][i]);
X      else
X        fprintf(ostream, " % *g", cw[j], (double)matrix[j][i]);
X
X    fprintf(ostream, "  |\n");
X  }
X
X  fprintf(ostream, CGLM_PRINT_COLOR_RESET "\n");
X
X#undef m
X#undef n
X}
X
XCGLM_INLINE
Xvoid
Xglm_vec4_print(vec4              vec,
X               FILE * __restrict ostream) {
X  int i;
X
X#define m 4
X
X  fprintf(ostream, "Vector (float%d): " CGLM_PRINT_COLOR "\n  (", m);
X
X  for (i = 0; i < m; i++) {
X    if (vec[i] < CGLM_PRINT_MAX_TO_SHORT)
X      fprintf(ostream, " % .*f", CGLM_PRINT_PRECISION, (double)vec[i]);
X    else
X      fprintf(ostream, " % g", (double)vec[i]);
X  }
X
X  fprintf(ostream, "  )" CGLM_PRINT_COLOR_RESET "\n\n");
X
X#undef m
X}
X
XCGLM_INLINE
Xvoid
Xglm_ivec4_print(ivec4             vec,
X                FILE * __restrict ostream) {
X  int i;
X
X#define m 4
X
X  fprintf(ostream, "Vector (int%d): " CGLM_PRINT_COLOR "\n  (", m);
X
X  for (i = 0; i < m; i++)
X    fprintf(ostream, " % d", vec[i]);
X
X  fprintf(ostream, "  )" CGLM_PRINT_COLOR_RESET "\n\n");
X
X#undef m
X}
X
XCGLM_INLINE
Xvoid
Xglm_vec3_print(vec3              vec,
X               FILE * __restrict ostream) {
X  int i;
X
X#define m 3
X
X  fprintf(ostream, "Vector (float%d): " CGLM_PRINT_COLOR "\n  (", m);
X
X  for (i = 0; i < m; i++) {
X    if (vec[i] < CGLM_PRINT_MAX_TO_SHORT)
X      fprintf(ostream, " % .*f", CGLM_PRINT_PRECISION, (double)vec[i]);
X    else
X      fprintf(ostream, " % g", (double)vec[i]);
X  }
X
X  fprintf(ostream, "  )" CGLM_PRINT_COLOR_RESET "\n\n");
X
X#undef m
X}
X
XCGLM_INLINE
Xvoid
Xglm_ivec3_print(ivec3             vec,
X                FILE * __restrict ostream) {
X  int i;
X
X#define m 3
X
X  fprintf(ostream, "Vector (int%d): " CGLM_PRINT_COLOR "\n  (", m);
X
X  for (i = 0; i < m; i++)
X    fprintf(ostream, " % d", vec[i]);
X
X  fprintf(ostream, "  )" CGLM_PRINT_COLOR_RESET "\n\n");
X
X#undef m
X}
X
XCGLM_INLINE
Xvoid
Xglm_vec2_print(vec2              vec,
X               FILE * __restrict ostream) {
X  int i;
X
X#define m 2
X
X  fprintf(ostream, "Vector (float%d): " CGLM_PRINT_COLOR "\n  (", m);
X
X  for (i = 0; i < m; i++) {
X    if (vec[i] < CGLM_PRINT_MAX_TO_SHORT)
X      fprintf(ostream, " % .*f", CGLM_PRINT_PRECISION, (double)vec[i]);
X    else
X      fprintf(ostream, " % g", (double)vec[i]);
X  }
X
X  fprintf(ostream, "  )" CGLM_PRINT_COLOR_RESET "\n\n");
X
X#undef m
X}
X
XCGLM_INLINE
Xvoid
Xglm_ivec2_print(ivec2             vec,
X                FILE * __restrict ostream) {
X  int i;
X
X#define m 2
X
X  fprintf(ostream, "Vector (int%d): " CGLM_PRINT_COLOR "\n  (", m);
X
X  for (i = 0; i < m; i++)
X    fprintf(ostream, " % d", vec[i]);
X
X  fprintf(ostream, "  )" CGLM_PRINT_COLOR_RESET "\n\n");
X
X#undef m
X}
X
XCGLM_INLINE
Xvoid
Xglm_versor_print(versor            vec,
X                 FILE * __restrict ostream) {
X  int i;
X
X#define m 4
X
X  fprintf(ostream, "Quaternion (float%d): " CGLM_PRINT_COLOR "\n  (", m);
X
X  for (i = 0; i < m; i++) {
X    if (vec[i] < CGLM_PRINT_MAX_TO_SHORT)
X      fprintf(ostream, " % .*f", CGLM_PRINT_PRECISION, (double)vec[i]);
X    else
X      fprintf(ostream, " % g", (double)vec[i]);
X  }
X
X
X  fprintf(ostream, "  )" CGLM_PRINT_COLOR_RESET "\n\n");
X
X#undef m
X}
X
XCGLM_INLINE
Xvoid
Xglm_aabb_print(vec3                    bbox[2],
X               const char * __restrict tag,
X               FILE       * __restrict ostream) {
X  int i, j;
X
X#define m 3
X
X  fprintf(ostream, "AABB (%s): " CGLM_PRINT_COLOR "\n", tag ? tag: "float");
X
X  for (i = 0; i < 2; i++) {
X    fprintf(ostream, "  (");
X
X    for (j = 0; j < m; j++) {
X      if (bbox[i][j] < CGLM_PRINT_MAX_TO_SHORT)
X        fprintf(ostream, " % .*f", CGLM_PRINT_PRECISION, (double)bbox[i][j]);
X      else
X        fprintf(ostream, " % g", (double)bbox[i][j]);
X    }
X
X    fprintf(ostream, "  )\n");
X  }
X
X  fprintf(ostream, CGLM_PRINT_COLOR_RESET "\n");
X
X#undef m
X}
X
X#else
X
X#include "common.h"
X
X#include <stdio.h>
X#include <stdlib.h>
X
X/* NOOP: Remove print from DEBUG */
X#define glm_mat4_print(v, s) (void)v; (void)s;
X#define glm_mat3_print(v, s) (void)v; (void)s;
X#define glm_mat2_print(v, s) (void)v; (void)s;
X#define glm_vec4_print(v, s) (void)v; (void)s;
X#define glm_ivec4_print(v, s) (void)v; (void)s;
X#define glm_vec3_print(v, s) (void)v; (void)s;
X#define glm_ivec3_print(v, s) (void)v; (void)s;
X#define glm_vec2_print(v, s) (void)v; (void)s;
X#define glm_ivec2_print(v, s) (void)v; (void)s;
X#define glm_versor_print(v, s) (void)v; (void)s;
X#define glm_aabb_print(v, t, s) (void)v; (void)t; (void)s;
X#define glm_arch_print(s) (void)s;
X#define glm_arch_print_name(s) (void)s;
X
X#endif
X#endif /* cglm_io_h */
63693ed6831842533808e4e88fabc9d9
echo x - cglm/mat4.h
sed 's/^X//' >cglm/mat4.h << '774cfd8e89178f3fdb72f4057ad163f9'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*!
X * Most of functions in this header are optimized manually with SIMD
X * if available. You dont need to call/incude SIMD headers manually
X */
X
X/*
X Macros:
X   GLM_MAT4_IDENTITY_INIT
X   GLM_MAT4_ZERO_INIT
X   GLM_MAT4_IDENTITY
X   GLM_MAT4_ZERO
X
X Functions:
X   CGLM_INLINE void  glm_mat4_ucopy(mat4 mat, mat4 dest);
X   CGLM_INLINE void  glm_mat4_copy(mat4 mat, mat4 dest);
X   CGLM_INLINE void  glm_mat4_identity(mat4 mat);
X   CGLM_INLINE void  glm_mat4_identity_array(mat4 * restrict mat, size_t count);
X   CGLM_INLINE void  glm_mat4_zero(mat4 mat);
X   CGLM_INLINE void  glm_mat4_pick3(mat4 mat, mat3 dest);
X   CGLM_INLINE void  glm_mat4_pick3t(mat4 mat, mat3 dest);
X   CGLM_INLINE void  glm_mat4_ins3(mat3 mat, mat4 dest);
X   CGLM_INLINE void  glm_mat4_mul(mat4 m1, mat4 m2, mat4 dest);
X   CGLM_INLINE void  glm_mat4_mulN(mat4 *matrices[], int len, mat4 dest);
X   CGLM_INLINE void  glm_mat4_mulv(mat4 m, vec4 v, vec4 dest);
X   CGLM_INLINE void  glm_mat4_mulv3(mat4 m, vec3 v, float last, vec3 dest);
X   CGLM_INLINE float glm_mat4_trace(mat4 m);
X   CGLM_INLINE float glm_mat4_trace3(mat4 m);
X   CGLM_INLINE void  glm_mat4_quat(mat4 m, versor dest) ;
X   CGLM_INLINE void  glm_mat4_transpose_to(mat4 m, mat4 dest);
X   CGLM_INLINE void  glm_mat4_transpose(mat4 m);
X   CGLM_INLINE void  glm_mat4_scale_p(mat4 m, float s);
X   CGLM_INLINE void  glm_mat4_scale(mat4 m, float s);
X   CGLM_INLINE float glm_mat4_det(mat4 mat);
X   CGLM_INLINE void  glm_mat4_inv(mat4 mat, mat4 dest);
X   CGLM_INLINE void  glm_mat4_inv_fast(mat4 mat, mat4 dest);
X   CGLM_INLINE void  glm_mat4_swap_col(mat4 mat, int col1, int col2);
X   CGLM_INLINE void  glm_mat4_swap_row(mat4 mat, int row1, int row2);
X   CGLM_INLINE float glm_mat4_rmc(vec4 r, mat4 m, vec4 c);
X   CGLM_INLINE void  glm_mat4_make(float * restrict src, mat4 dest);
X */
X
X#ifndef cglm_mat_h
X#define cglm_mat_h
X
X#include "common.h"
X#include "vec4.h"
X#include "vec3.h"
X
X#ifdef CGLM_SSE_FP
X#  include "simd/sse2/mat4.h"
X#endif
X
X#ifdef CGLM_AVX_FP
X#  include "simd/avx/mat4.h"
X#endif
X
X#ifdef CGLM_NEON_FP
X#  include "simd/neon/mat4.h"
X#endif
X
X#ifdef CGLM_SIMD_WASM
X#  include "simd/wasm/mat4.h"
X#endif
X
X#ifdef DEBUG
X# include <assert.h>
X#endif
X
X#define GLM_MAT4_IDENTITY_INIT  {{1.0f, 0.0f, 0.0f, 0.0f},                    \
X                                 {0.0f, 1.0f, 0.0f, 0.0f},                    \
X                                 {0.0f, 0.0f, 1.0f, 0.0f},                    \
X                                 {0.0f, 0.0f, 0.0f, 1.0f}}
X
X#define GLM_MAT4_ZERO_INIT      {{0.0f, 0.0f, 0.0f, 0.0f},                    \
X                                 {0.0f, 0.0f, 0.0f, 0.0f},                    \
X                                 {0.0f, 0.0f, 0.0f, 0.0f},                    \
X                                 {0.0f, 0.0f, 0.0f, 0.0f}}
X
X/* for C only */
X#define GLM_MAT4_IDENTITY ((mat4)GLM_MAT4_IDENTITY_INIT)
X#define GLM_MAT4_ZERO     ((mat4)GLM_MAT4_ZERO_INIT)
X
X/* DEPRECATED! use _copy, _ucopy versions */
X#define glm_mat4_udup(mat, dest) glm_mat4_ucopy(mat, dest)
X#define glm_mat4_dup(mat, dest)  glm_mat4_copy(mat, dest)
X
X/* DEPRECATED! default is precise now. */
X#define glm_mat4_inv_precise(mat, dest) glm_mat4_inv(mat, dest)
X
X/*!
X * @brief copy all members of [mat] to [dest]
X *
X * matrix may not be aligned, u stands for unaligned, this may be useful when
X * copying a matrix from external source e.g. asset importer...
X *
X * @param[in]  mat  source
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_mat4_ucopy(mat4 mat, mat4 dest) {
X  dest[0][0] = mat[0][0];  dest[1][0] = mat[1][0];
X  dest[0][1] = mat[0][1];  dest[1][1] = mat[1][1];
X  dest[0][2] = mat[0][2];  dest[1][2] = mat[1][2];
X  dest[0][3] = mat[0][3];  dest[1][3] = mat[1][3];
X
X  dest[2][0] = mat[2][0];  dest[3][0] = mat[3][0];
X  dest[2][1] = mat[2][1];  dest[3][1] = mat[3][1];
X  dest[2][2] = mat[2][2];  dest[3][2] = mat[3][2];
X  dest[2][3] = mat[2][3];  dest[3][3] = mat[3][3];
X}
X
X/*!
X * @brief copy all members of [mat] to [dest]
X *
X * @param[in]  mat  source
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_mat4_copy(mat4 mat, mat4 dest) {
X#if defined(__wasm__) && defined(__wasm_simd128__)
X  glmm_store(dest[0], glmm_load(mat[0]));
X  glmm_store(dest[1], glmm_load(mat[1]));
X  glmm_store(dest[2], glmm_load(mat[2]));
X  glmm_store(dest[3], glmm_load(mat[3]));
X#elif defined(__AVX__)
X  glmm_store256(dest[0], glmm_load256(mat[0]));
X  glmm_store256(dest[2], glmm_load256(mat[2]));
X#elif defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(dest[0], glmm_load(mat[0]));
X  glmm_store(dest[1], glmm_load(mat[1]));
X  glmm_store(dest[2], glmm_load(mat[2]));
X  glmm_store(dest[3], glmm_load(mat[3]));
X#elif defined(CGLM_NEON_FP)
X  vst1q_f32(dest[0], vld1q_f32(mat[0]));
X  vst1q_f32(dest[1], vld1q_f32(mat[1]));
X  vst1q_f32(dest[2], vld1q_f32(mat[2]));
X  vst1q_f32(dest[3], vld1q_f32(mat[3]));
X#else
X  glm_mat4_ucopy(mat, dest);
X#endif
X}
X
X/*!
X * @brief make given matrix identity. It is identical with below, 
X *        but it is more easy to do that with this func especially for members
X *        e.g. glm_mat4_identity(aStruct->aMatrix);
X *
X * @code
X * glm_mat4_copy(GLM_MAT4_IDENTITY, mat); // C only
X *
X * // or
X * mat4 mat = GLM_MAT4_IDENTITY_INIT;
X * @endcode
X *
X * @param[in, out]  mat  destination
X */
XCGLM_INLINE
Xvoid
Xglm_mat4_identity(mat4 mat) {
X  CGLM_ALIGN_MAT mat4 t = GLM_MAT4_IDENTITY_INIT;
X  glm_mat4_copy(t, mat);
X}
X
X/*!
X * @brief make given matrix array's each element identity matrix
X *
X * @param[in, out]  mat   matrix array (must be aligned (16/32)
X *                        if alignment is not disabled)
X *
X * @param[in]       count count of matrices
X */
XCGLM_INLINE
Xvoid
Xglm_mat4_identity_array(mat4 * __restrict mat, size_t count) {
X  CGLM_ALIGN_MAT mat4 t = GLM_MAT4_IDENTITY_INIT;
X  size_t i;
X
X  for (i = 0; i < count; i++) {
X    glm_mat4_copy(t, mat[i]);
X  }
X}
X
X/*!
X * @brief make given matrix zero.
X *
X * @param[in, out]  mat  matrix
X */
XCGLM_INLINE
Xvoid
Xglm_mat4_zero(mat4 mat) {
X#if defined(__wasm__) && defined(__wasm_simd128__)
X  glmm_128 x0;
X  x0 = wasm_f32x4_const_splat(0.f);
X  glmm_store(mat[0], x0);
X  glmm_store(mat[1], x0);
X  glmm_store(mat[2], x0);
X  glmm_store(mat[3], x0);
X#elif defined(__AVX__)
X  __m256 y0;
X  y0 = _mm256_setzero_ps();
X  glmm_store256(mat[0], y0);
X  glmm_store256(mat[2], y0);
X#elif defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_128 x0;
X  x0 = _mm_setzero_ps();
X  glmm_store(mat[0], x0);
X  glmm_store(mat[1], x0);
X  glmm_store(mat[2], x0);
X  glmm_store(mat[3], x0);
X#elif defined(CGLM_NEON_FP)
X  glmm_128 x0;
X  x0 = vdupq_n_f32(0.0f);
X  vst1q_f32(mat[0], x0);
X  vst1q_f32(mat[1], x0);
X  vst1q_f32(mat[2], x0);
X  vst1q_f32(mat[3], x0);
X#else
X  CGLM_ALIGN_MAT mat4 t = GLM_MAT4_ZERO_INIT;
X  glm_mat4_copy(t, mat);
X#endif
X}
X
X/*!
X * @brief copy upper-left of mat4 to mat3
X *
X * @param[in]  mat  source
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_mat4_pick3(mat4 mat, mat3 dest) {
X  dest[0][0] = mat[0][0];
X  dest[0][1] = mat[0][1];
X  dest[0][2] = mat[0][2];
X
X  dest[1][0] = mat[1][0];
X  dest[1][1] = mat[1][1];
X  dest[1][2] = mat[1][2];
X
X  dest[2][0] = mat[2][0];
X  dest[2][1] = mat[2][1];
X  dest[2][2] = mat[2][2];
X}
X
X/*!
X * @brief copy upper-left of mat4 to mat3 (transposed)
X *
X * the postfix t stands for transpose
X *
X * @param[in]  mat  source
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_mat4_pick3t(mat4 mat, mat3 dest) {
X  dest[0][0] = mat[0][0];
X  dest[0][1] = mat[1][0];
X  dest[0][2] = mat[2][0];
X
X  dest[1][0] = mat[0][1];
X  dest[1][1] = mat[1][1];
X  dest[1][2] = mat[2][1];
X
X  dest[2][0] = mat[0][2];
X  dest[2][1] = mat[1][2];
X  dest[2][2] = mat[2][2];
X}
X
X/*!
X * @brief copy mat3 to mat4's upper-left
X *
X * @param[in]  mat  source
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_mat4_ins3(mat3 mat, mat4 dest) {
X  dest[0][0] = mat[0][0];
X  dest[0][1] = mat[0][1];
X  dest[0][2] = mat[0][2];
X
X  dest[1][0] = mat[1][0];
X  dest[1][1] = mat[1][1];
X  dest[1][2] = mat[1][2];
X
X  dest[2][0] = mat[2][0];
X  dest[2][1] = mat[2][1];
X  dest[2][2] = mat[2][2];
X}
X
X/*!
X * @brief multiply m1 and m2 to dest
X *
X * m1, m2 and dest matrices can be same matrix, it is possible to write this:
X *
X * @code
X * mat4 m = GLM_MAT4_IDENTITY_INIT;
X * glm_mat4_mul(m, m, m);
X * @endcode
X *
X * @param[in]  m1   left matrix
X * @param[in]  m2   right matrix
X * @param[out] dest destination matrix
X */
XCGLM_INLINE
Xvoid
Xglm_mat4_mul(mat4 m1, mat4 m2, mat4 dest) {
X#if defined(__wasm__) && defined(__wasm_simd128__)
X  glm_mat4_mul_wasm(m1, m2, dest);
X#elif defined(__AVX__)
X  glm_mat4_mul_avx(m1, m2, dest);
X#elif defined( __SSE__ ) || defined( __SSE2__ )
X  glm_mat4_mul_sse2(m1, m2, dest);
X#elif defined(CGLM_NEON_FP)
X  glm_mat4_mul_neon(m1, m2, dest);
X#else
X  float a00 = m1[0][0], a01 = m1[0][1], a02 = m1[0][2], a03 = m1[0][3],
X        a10 = m1[1][0], a11 = m1[1][1], a12 = m1[1][2], a13 = m1[1][3],
X        a20 = m1[2][0], a21 = m1[2][1], a22 = m1[2][2], a23 = m1[2][3],
X        a30 = m1[3][0], a31 = m1[3][1], a32 = m1[3][2], a33 = m1[3][3],
X
X        b00 = m2[0][0], b01 = m2[0][1], b02 = m2[0][2], b03 = m2[0][3],
X        b10 = m2[1][0], b11 = m2[1][1], b12 = m2[1][2], b13 = m2[1][3],
X        b20 = m2[2][0], b21 = m2[2][1], b22 = m2[2][2], b23 = m2[2][3],
X        b30 = m2[3][0], b31 = m2[3][1], b32 = m2[3][2], b33 = m2[3][3];
X
X  dest[0][0] = a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03;
X  dest[0][1] = a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03;
X  dest[0][2] = a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03;
X  dest[0][3] = a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03;
X  dest[1][0] = a00 * b10 + a10 * b11 + a20 * b12 + a30 * b13;
X  dest[1][1] = a01 * b10 + a11 * b11 + a21 * b12 + a31 * b13;
X  dest[1][2] = a02 * b10 + a12 * b11 + a22 * b12 + a32 * b13;
X  dest[1][3] = a03 * b10 + a13 * b11 + a23 * b12 + a33 * b13;
X  dest[2][0] = a00 * b20 + a10 * b21 + a20 * b22 + a30 * b23;
X  dest[2][1] = a01 * b20 + a11 * b21 + a21 * b22 + a31 * b23;
X  dest[2][2] = a02 * b20 + a12 * b21 + a22 * b22 + a32 * b23;
X  dest[2][3] = a03 * b20 + a13 * b21 + a23 * b22 + a33 * b23;
X  dest[3][0] = a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33;
X  dest[3][1] = a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33;
X  dest[3][2] = a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33;
X  dest[3][3] = a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33;
X#endif
X}
X
X/*!
X * @brief mupliply N mat4 matrices and store result in dest
X *
X * this function lets you multiply multiple (more than two or more...) matrices
X * <br><br>multiplication will be done in loop, this may reduce instructions
X * size but if <b>len</b> is too small then compiler may unroll whole loop,
X * usage:
X * @code
X * mat m1, m2, m3, m4, res;
X *
X * glm_mat4_mulN((mat4 *[]){&m1, &m2, &m3, &m4}, 4, res);
X * @endcode
X *
X * @warning matrices parameter is pointer array not mat4 array!
X *
X * @param[in]  matrices mat4 * array
X * @param[in]  len      matrices count
X * @param[out] dest     result
X */
XCGLM_INLINE
Xvoid
Xglm_mat4_mulN(mat4 * __restrict matrices[], uint32_t len, mat4 dest) {
X  uint32_t i;
X
X#ifdef DEBUG
X  assert(len > 1 && "there must be least 2 matrices to go!");
X#endif
X
X  glm_mat4_mul(*matrices[0], *matrices[1], dest);
X
X  for (i = 2; i < len; i++)
X    glm_mat4_mul(dest, *matrices[i], dest);
X}
X
X/*!
X * @brief multiply mat4 with vec4 (column vector) and store in dest vector
X *
X * @param[in]  m    mat4 (left)
X * @param[in]  v    vec4 (right, column vector)
X * @param[out] dest vec4 (result, column vector)
X */
XCGLM_INLINE
Xvoid
Xglm_mat4_mulv(mat4 m, vec4 v, vec4 dest) {
X#if defined(__wasm__) && defined(__wasm_simd128__)
X  glm_mat4_mulv_wasm(m, v, dest);
X#elif defined( __SSE__ ) || defined( __SSE2__ )
X  glm_mat4_mulv_sse2(m, v, dest);
X#elif defined(CGLM_NEON_FP)
X  glm_mat4_mulv_neon(m, v, dest);
X#else
X  vec4 res;
X  res[0] = m[0][0] * v[0] + m[1][0] * v[1] + m[2][0] * v[2] + m[3][0] * v[3];
X  res[1] = m[0][1] * v[0] + m[1][1] * v[1] + m[2][1] * v[2] + m[3][1] * v[3];
X  res[2] = m[0][2] * v[0] + m[1][2] * v[1] + m[2][2] * v[2] + m[3][2] * v[3];
X  res[3] = m[0][3] * v[0] + m[1][3] * v[1] + m[2][3] * v[2] + m[3][3] * v[3];
X  glm_vec4_copy(res, dest);
X#endif
X}
X
X/*!
X * @brief trace of matrix
X *
X * sum of the elements on the main diagonal from upper left to the lower right
X *
X * @param[in]  m matrix
X */
XCGLM_INLINE
Xfloat
Xglm_mat4_trace(mat4 m) {
X  return m[0][0] + m[1][1] + m[2][2] + m[3][3];
X}
X
X/*!
X * @brief trace of matrix (rotation part)
X *
X * sum of the elements on the main diagonal from upper left to the lower right
X *
X * @param[in]  m matrix
X */
XCGLM_INLINE
Xfloat
Xglm_mat4_trace3(mat4 m) {
X  return m[0][0] + m[1][1] + m[2][2];
X}
X
X/*!
X * @brief convert mat4's rotation part to quaternion
X *
X * @param[in]  m    affine matrix
X * @param[out] dest destination quaternion
X */
XCGLM_INLINE
Xvoid
Xglm_mat4_quat(mat4 m, versor dest) {
X  float trace, r, rinv;
X
X  /* it seems using like m12 instead of m[1][2] causes extra instructions */
X
X  trace = m[0][0] + m[1][1] + m[2][2];
X  if (trace >= 0.0f) {
X    r       = sqrtf(1.0f + trace);
X    rinv    = 0.5f / r;
X
X    dest[0] = rinv * (m[1][2] - m[2][1]);
X    dest[1] = rinv * (m[2][0] - m[0][2]);
X    dest[2] = rinv * (m[0][1] - m[1][0]);
X    dest[3] = r    * 0.5f;
X  } else if (m[0][0] >= m[1][1] && m[0][0] >= m[2][2]) {
X    r       = sqrtf(1.0f - m[1][1] - m[2][2] + m[0][0]);
X    rinv    = 0.5f / r;
X
X    dest[0] = r    * 0.5f;
X    dest[1] = rinv * (m[0][1] + m[1][0]);
X    dest[2] = rinv * (m[0][2] + m[2][0]);
X    dest[3] = rinv * (m[1][2] - m[2][1]);
X  } else if (m[1][1] >= m[2][2]) {
X    r       = sqrtf(1.0f - m[0][0] - m[2][2] + m[1][1]);
X    rinv    = 0.5f / r;
X
X    dest[0] = rinv * (m[0][1] + m[1][0]);
X    dest[1] = r    * 0.5f;
X    dest[2] = rinv * (m[1][2] + m[2][1]);
X    dest[3] = rinv * (m[2][0] - m[0][2]);
X  } else {
X    r       = sqrtf(1.0f - m[0][0] - m[1][1] + m[2][2]);
X    rinv    = 0.5f / r;
X
X    dest[0] = rinv * (m[0][2] + m[2][0]);
X    dest[1] = rinv * (m[1][2] + m[2][1]);
X    dest[2] = r    * 0.5f;
X    dest[3] = rinv * (m[0][1] - m[1][0]);
X  }
X}
X
X/*!
X * @brief multiply vector with mat4
X *
X * actually the result is vec4, after multiplication the last component
X * is trimmed. if you need it don't use this func.
X *
X * @param[in]  m    mat4(affine transform)
X * @param[in]  v    vec3
X * @param[in]  last 4th item to make it vec4
X * @param[out] dest result vector (vec3)
X */
XCGLM_INLINE
Xvoid
Xglm_mat4_mulv3(mat4 m, vec3 v, float last, vec3 dest) {
X  vec4 res;
X  glm_vec4(v, last, res);
X  glm_mat4_mulv(m, res, res);
X  glm_vec3(res, dest);
X}
X
X/*!
X * @brief transpose mat4 and store in dest
X *
X * source matrix will not be transposed unless dest is m
X *
X * @param[in]  m    matrix
X * @param[out] dest result
X */
XCGLM_INLINE
Xvoid
Xglm_mat4_transpose_to(mat4 m, mat4 dest) {
X#if defined(__wasm__) && defined(__wasm_simd128__)
X  glm_mat4_transp_wasm(m, dest);
X#elif defined( __SSE__ ) || defined( __SSE2__ )
X  glm_mat4_transp_sse2(m, dest);
X#elif defined(CGLM_NEON_FP)
X  glm_mat4_transp_neon(m, dest);
X#else
X  dest[0][0] = m[0][0]; dest[1][0] = m[0][1];
X  dest[0][1] = m[1][0]; dest[1][1] = m[1][1];
X  dest[0][2] = m[2][0]; dest[1][2] = m[2][1];
X  dest[0][3] = m[3][0]; dest[1][3] = m[3][1];
X  dest[2][0] = m[0][2]; dest[3][0] = m[0][3];
X  dest[2][1] = m[1][2]; dest[3][1] = m[1][3];
X  dest[2][2] = m[2][2]; dest[3][2] = m[2][3];
X  dest[2][3] = m[3][2]; dest[3][3] = m[3][3];
X#endif
X}
X
X/*!
X * @brief tranpose mat4 and store result in same matrix
X *
X * @param[in, out] m source and dest
X */
XCGLM_INLINE
Xvoid
Xglm_mat4_transpose(mat4 m) {
X#if defined(__wasm__) && defined(__wasm_simd128__)
X  glm_mat4_transp_wasm(m, m);
X#elif defined( __SSE__ ) || defined( __SSE2__ )
X  glm_mat4_transp_sse2(m, m);
X#elif defined(CGLM_NEON_FP)
X  glm_mat4_transp_neon(m, m);
X#else
X  mat4 d;
X  glm_mat4_transpose_to(m, d);
X  glm_mat4_ucopy(d, m);
X#endif
X}
X
X/*!
X * @brief scale (multiply with scalar) matrix without simd optimization
X *
X * multiply matrix with scalar
X *
X * @param[in, out] m matrix
X * @param[in]      s scalar
X */
XCGLM_INLINE
Xvoid
Xglm_mat4_scale_p(mat4 m, float s) {
X  m[0][0] *= s; m[0][1] *= s; m[0][2] *= s; m[0][3] *= s;
X  m[1][0] *= s; m[1][1] *= s; m[1][2] *= s; m[1][3] *= s;
X  m[2][0] *= s; m[2][1] *= s; m[2][2] *= s; m[2][3] *= s;
X  m[3][0] *= s; m[3][1] *= s; m[3][2] *= s; m[3][3] *= s;
X}
X
X/*!
X * @brief scale (multiply with scalar) matrix
X *
X * multiply matrix with scalar
X *
X * @param[in, out] m matrix
X * @param[in]      s scalar
X */
XCGLM_INLINE
Xvoid
Xglm_mat4_scale(mat4 m, float s) {
X#if defined(__wasm__) && defined(__wasm_simd128__)
X  glm_mat4_scale_wasm(m, s);
X#elif defined(__AVX__)
X  glm_mat4_scale_avx(m, s);
X#elif defined( __SSE__ ) || defined( __SSE2__ )
X  glm_mat4_scale_sse2(m, s);
X#elif defined(CGLM_NEON_FP)
X  glm_mat4_scale_neon(m, s);
X#else
X  glm_mat4_scale_p(m, s);
X#endif
X}
X
X/*!
X * @brief mat4 determinant
X *
X * @param[in] mat matrix
X *
X * @return determinant
X */
XCGLM_INLINE
Xfloat
Xglm_mat4_det(mat4 mat) {
X#if defined(__wasm__) && defined(__wasm_simd128__)
X  return glm_mat4_det_wasm(mat);
X#elif defined( __SSE__ ) || defined( __SSE2__ )
X  return glm_mat4_det_sse2(mat);
X#elif defined(CGLM_NEON_FP)
X  return glm_mat4_det_neon(mat);
X#else
X  /* [square] det(A) = det(At) */
X  float t[6];
X  float a = mat[0][0], b = mat[0][1], c = mat[0][2], d = mat[0][3],
X        e = mat[1][0], f = mat[1][1], g = mat[1][2], h = mat[1][3],
X        i = mat[2][0], j = mat[2][1], k = mat[2][2], l = mat[2][3],
X        m = mat[3][0], n = mat[3][1], o = mat[3][2], p = mat[3][3];
X
X  t[0] = k * p - o * l;
X  t[1] = j * p - n * l;
X  t[2] = j * o - n * k;
X  t[3] = i * p - m * l;
X  t[4] = i * o - m * k;
X  t[5] = i * n - m * j;
X
X  return a * (f * t[0] - g * t[1] + h * t[2])
X       - b * (e * t[0] - g * t[3] + h * t[4])
X       + c * (e * t[1] - f * t[3] + h * t[5])
X       - d * (e * t[2] - f * t[4] + g * t[5]);
X#endif
X}
X
X/*!
X * @brief inverse mat4 and store in dest
X *
X * @param[in]  mat  matrix
X * @param[out] dest inverse matrix
X */
XCGLM_INLINE
Xvoid
Xglm_mat4_inv(mat4 mat, mat4 dest) {
X#if defined( __SSE__ ) || defined( __SSE2__ )
X  glm_mat4_inv_sse2(mat, dest);
X#elif defined(CGLM_NEON_FP)
X  glm_mat4_inv_neon(mat, dest);
X#else
X  float t[6];
X  float det;
X  float a = mat[0][0], b = mat[0][1], c = mat[0][2], d = mat[0][3],
X        e = mat[1][0], f = mat[1][1], g = mat[1][2], h = mat[1][3],
X        i = mat[2][0], j = mat[2][1], k = mat[2][2], l = mat[2][3],
X        m = mat[3][0], n = mat[3][1], o = mat[3][2], p = mat[3][3];
X
X  t[0] = k * p - o * l; t[1] = j * p - n * l; t[2] = j * o - n * k;
X  t[3] = i * p - m * l; t[4] = i * o - m * k; t[5] = i * n - m * j;
X
X  dest[0][0] =  f * t[0] - g * t[1] + h * t[2];
X  dest[1][0] =-(e * t[0] - g * t[3] + h * t[4]);
X  dest[2][0] =  e * t[1] - f * t[3] + h * t[5];
X  dest[3][0] =-(e * t[2] - f * t[4] + g * t[5]);
X
X  dest[0][1] =-(b * t[0] - c * t[1] + d * t[2]);
X  dest[1][1] =  a * t[0] - c * t[3] + d * t[4];
X  dest[2][1] =-(a * t[1] - b * t[3] + d * t[5]);
X  dest[3][1] =  a * t[2] - b * t[4] + c * t[5];
X
X  t[0] = g * p - o * h; t[1] = f * p - n * h; t[2] = f * o - n * g;
X  t[3] = e * p - m * h; t[4] = e * o - m * g; t[5] = e * n - m * f;
X
X  dest[0][2] =  b * t[0] - c * t[1] + d * t[2];
X  dest[1][2] =-(a * t[0] - c * t[3] + d * t[4]);
X  dest[2][2] =  a * t[1] - b * t[3] + d * t[5];
X  dest[3][2] =-(a * t[2] - b * t[4] + c * t[5]);
X
X  t[0] = g * l - k * h; t[1] = f * l - j * h; t[2] = f * k - j * g;
X  t[3] = e * l - i * h; t[4] = e * k - i * g; t[5] = e * j - i * f;
X
X  dest[0][3] =-(b * t[0] - c * t[1] + d * t[2]);
X  dest[1][3] =  a * t[0] - c * t[3] + d * t[4];
X  dest[2][3] =-(a * t[1] - b * t[3] + d * t[5]);
X  dest[3][3] =  a * t[2] - b * t[4] + c * t[5];
X
X  det = 1.0f / (a * dest[0][0] + b * dest[1][0]
X              + c * dest[2][0] + d * dest[3][0]);
X
X  glm_mat4_scale_p(dest, det);
X#endif
X}
X
X/*!
X * @brief inverse mat4 and store in dest
X *
X * this func uses reciprocal approximation without extra corrections
X * e.g Newton-Raphson. this should work faster than normal,
X * to get more precise use glm_mat4_inv version.
X *
X * NOTE: You will lose precision, glm_mat4_inv is more accurate
X *
X * @param[in]  mat  matrix
X * @param[out] dest inverse matrix
X */
XCGLM_INLINE
Xvoid
Xglm_mat4_inv_fast(mat4 mat, mat4 dest) {
X#if defined(__wasm__) && defined(__wasm_simd128__)
X  glm_mat4_inv_fast_wasm(mat, dest);
X#elif defined( __SSE__ ) || defined( __SSE2__ )
X  glm_mat4_inv_fast_sse2(mat, dest);
X#else
X  glm_mat4_inv(mat, dest);
X#endif
X}
X
X/*!
X * @brief swap two matrix columns
X *
X * @param[in,out] mat  matrix
X * @param[in]     col1 col1
X * @param[in]     col2 col2
X */
XCGLM_INLINE
Xvoid
Xglm_mat4_swap_col(mat4 mat, int col1, int col2) {
X  CGLM_ALIGN(16) vec4 tmp;
X  glm_vec4_copy(mat[col1], tmp);
X  glm_vec4_copy(mat[col2], mat[col1]);
X  glm_vec4_copy(tmp, mat[col2]);
X}
X
X/*!
X * @brief swap two matrix rows
X *
X * @param[in,out] mat  matrix
X * @param[in]     row1 row1
X * @param[in]     row2 row2
X */
XCGLM_INLINE
Xvoid
Xglm_mat4_swap_row(mat4 mat, int row1, int row2) {
X  CGLM_ALIGN(16) vec4 tmp;
X  tmp[0] = mat[0][row1];
X  tmp[1] = mat[1][row1];
X  tmp[2] = mat[2][row1];
X  tmp[3] = mat[3][row1];
X
X  mat[0][row1] = mat[0][row2];
X  mat[1][row1] = mat[1][row2];
X  mat[2][row1] = mat[2][row2];
X  mat[3][row1] = mat[3][row2];
X
X  mat[0][row2] = tmp[0];
X  mat[1][row2] = tmp[1];
X  mat[2][row2] = tmp[2];
X  mat[3][row2] = tmp[3];
X}
X
X/*!
X * @brief helper for  R (row vector) * M (matrix) * C (column vector)
X *
X * rmc stands for Row * Matrix * Column
X *
X * the result is scalar because R * M = Matrix1x4 (row vector),
X * then Matrix1x4 * Vec4 (column vector) = Matrix1x1 (Scalar)
X *
X * @param[in]  r   row vector or matrix1x4
X * @param[in]  m   matrix4x4
X * @param[in]  c   column vector or matrix4x1
X *
X * @return scalar value e.g. B(s)
X */
XCGLM_INLINE
Xfloat
Xglm_mat4_rmc(vec4 r, mat4 m, vec4 c) {
X  vec4 tmp;
X  glm_mat4_mulv(m, c, tmp);
X  return glm_vec4_dot(r, tmp);
X}
X
X/*!
X * @brief Create mat4 matrix from pointer
X *
X * @param[in]  src  pointer to an array of floats
X * @param[out] dest matrix
X */
XCGLM_INLINE
Xvoid
Xglm_mat4_make(float * __restrict src, mat4 dest) {
X  dest[0][0] = src[0];   dest[1][0] = src[4];
X  dest[0][1] = src[1];   dest[1][1] = src[5];
X  dest[0][2] = src[2];   dest[1][2] = src[6];
X  dest[0][3] = src[3];   dest[1][3] = src[7];
X
X  dest[2][0] = src[8];   dest[3][0] = src[12];
X  dest[2][1] = src[9];   dest[3][1] = src[13];
X  dest[2][2] = src[10];  dest[3][2] = src[14];
X  dest[2][3] = src[11];  dest[3][3] = src[15];
X}
X
X#endif /* cglm_mat_h */
774cfd8e89178f3fdb72f4057ad163f9
echo x - cglm/mat4x2.h
sed 's/^X//' >cglm/mat4x2.h << 'fd9386da48790e2c563263c7f8ed2714'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Macros:
X   GLM_MAT4X2_ZERO_INIT
X   GLM_MAT4X2_ZERO
X
X Functions:
X   CGLM_INLINE void glm_mat4x2_copy(mat4x2 mat, mat4x2 dest);
X   CGLM_INLINE void glm_mat4x2_zero(mat4x2 mat);
X   CGLM_INLINE void glm_mat4x2_make(float * __restrict src, mat4x2 dest);
X   CGLM_INLINE void glm_mat4x2_mul(mat4x2 m1, mat2x4 m2, mat4 dest);
X   CGLM_INLINE void glm_mat4x2_mulv(mat4x2 m, vec2 v, vec4 dest);
X   CGLM_INLINE void glm_mat4x2_transpose(mat4x2 m, mat2x4 dest);
X   CGLM_INLINE void glm_mat4x2_scale(mat4x2 m, float s);
X */
X
X#ifndef cglm_mat4x2_h
X#define cglm_mat4x2_h
X
X#include "common.h"
X
X#define GLM_MAT4X2_ZERO_INIT {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}
X
X/* for C only */
X#define GLM_MAT4X2_ZERO GLM_MAT4X2_ZERO_INIT
X
X/*!
X * @brief copy all members of [mat] to [dest]
X *
X * @param[in]  mat  source
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_mat4x2_copy(mat4x2 mat, mat4x2 dest) {
X  dest[0][0] = mat[0][0];
X  dest[0][1] = mat[0][1];
X
X  dest[1][0] = mat[1][0];
X  dest[1][1] = mat[1][1];
X
X  dest[2][0] = mat[2][0];
X  dest[2][1] = mat[2][1];
X
X  dest[3][0] = mat[3][0];
X  dest[3][1] = mat[3][1];
X}
X
X/*!
X * @brief make given matrix zero.
X *
X * @param[in, out]  mat  matrix
X */
XCGLM_INLINE
Xvoid
Xglm_mat4x2_zero(mat4x2 mat) {
X  CGLM_ALIGN_MAT mat4x2 t = GLM_MAT4X2_ZERO_INIT;
X  glm_mat4x2_copy(t, mat);
X}
X
X/*!
X * @brief Create mat4x2 matrix from pointer
X *
X * @param[in]  src  pointer to an array of floats
X * @param[out] dest matrix
X */
XCGLM_INLINE
Xvoid
Xglm_mat4x2_make(float * __restrict src, mat4x2 dest) {
X  dest[0][0] = src[0];
X  dest[0][1] = src[1];
X
X  dest[1][0] = src[2];
X  dest[1][1] = src[3];
X
X  dest[2][0] = src[4];
X  dest[2][1] = src[5];
X
X  dest[3][0] = src[6];
X  dest[3][1] = src[7];
X}
X
X/*!
X * @brief multiply m1 and m2 to dest
X *
X * @code
X * glm_mat4x2_mul(mat4x2, mat2x4, mat4);
X * @endcode
X *
X * @param[in]  m1   left matrix (mat4x2)
X * @param[in]  m2   right matrix (mat2x4)
X * @param[out] dest destination matrix (mat4)
X */
XCGLM_INLINE
Xvoid
Xglm_mat4x2_mul(mat4x2 m1, mat2x4 m2, mat4 dest) {
X  float a00 = m1[0][0], a01 = m1[0][1],
X        a10 = m1[1][0], a11 = m1[1][1],
X        a20 = m1[2][0], a21 = m1[2][1],
X        a30 = m1[3][0], a31 = m1[3][1],
X
X        b00 = m2[0][0], b01 = m2[0][1], b02 = m2[0][2], b03 = m2[0][3],
X        b10 = m2[1][0], b11 = m2[1][1], b12 = m2[1][2], b13 = m2[1][3];
X
X  dest[0][0] = a00 * b00 + a01 * b10;
X  dest[0][1] = a00 * b01 + a01 * b11;
X  dest[0][2] = a00 * b02 + a01 * b12;
X  dest[0][3] = a00 * b03 + a01 * b13;
X
X  dest[1][0] = a10 * b00 + a11 * b10;
X  dest[1][1] = a10 * b01 + a11 * b11;
X  dest[1][2] = a10 * b02 + a11 * b12;
X  dest[1][3] = a10 * b03 + a11 * b13;
X
X  dest[2][0] = a20 * b00 + a21 * b10;
X  dest[2][1] = a20 * b01 + a21 * b11;
X  dest[2][2] = a20 * b02 + a21 * b12;
X  dest[2][3] = a20 * b03 + a21 * b13;
X
X  dest[3][0] = a30 * b00 + a31 * b10;
X  dest[3][1] = a30 * b01 + a31 * b11;
X  dest[3][2] = a30 * b02 + a31 * b12;
X  dest[3][3] = a30 * b03 + a31 * b13;
X}
X
X/*!
X * @brief multiply matrix with column vector and store in dest vector
X *
X * @param[in]  m    matrix (left)
X * @param[in]  v    vector (right, column vector)
X * @param[out] dest result vector
X */
XCGLM_INLINE
Xvoid
Xglm_mat4x2_mulv(mat4x2 m, vec2 v, vec4 dest) {
X  float v0 = v[0], v1 = v[1];
X
X  dest[0] = m[0][0] * v0 + m[0][1] * v1;
X  dest[1] = m[1][0] * v0 + m[1][1] * v1;
X  dest[2] = m[2][0] * v0 + m[2][1] * v1;
X  dest[3] = m[3][0] * v0 + m[3][1] * v1;
X}
X
X/*!
X * @brief transpose matrix and store in dest
X *
X * @param[in]  m     matrix
X * @param[out] dest  result
X */
XCGLM_INLINE
Xvoid
Xglm_mat4x2_transpose(mat4x2 m, mat2x4 dest) {
X  dest[0][0] = m[0][0];
X  dest[0][1] = m[1][0];
X  dest[0][2] = m[2][0];
X  dest[0][3] = m[3][0];
X  dest[1][0] = m[0][1];
X  dest[1][1] = m[1][1];
X  dest[1][2] = m[2][1];
X  dest[1][3] = m[3][1];
X}
X
X/*!
X * @brief scale (multiply with scalar) matrix
X *
X * multiply matrix with scalar
X *
X * @param[in, out] m matrix
X * @param[in]    s scalar
X */
XCGLM_INLINE
Xvoid
Xglm_mat4x2_scale(mat4x2 m, float s) {
X  m[0][0] *= s;  m[0][1] *= s;  m[1][0] *= s;  m[1][1] *= s;
X  m[2][0] *= s;  m[2][1] *= s;  m[3][0] *= s;  m[3][1] *= s;
X}
X
X#endif
fd9386da48790e2c563263c7f8ed2714
echo x - cglm/mat4x3.h
sed 's/^X//' >cglm/mat4x3.h << 'f6cf8510bef98f9dec12aa6fa1401e78'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Macros:
X   GLM_MAT4X3_ZERO_INIT
X   GLM_MAT4X3_ZERO
X
X Functions:
X   CGLM_INLINE void glm_mat4x3_copy(mat4x3 mat, mat4x3 dest);
X   CGLM_INLINE void glm_mat4x3_zero(mat4x3 mat);
X   CGLM_INLINE void glm_mat4x3_make(float * __restrict src, mat4x3 dest);
X   CGLM_INLINE void glm_mat4x3_mul(mat4x3 m1, mat3x4 m2, mat4 dest);
X   CGLM_INLINE void glm_mat4x3_mulv(mat4x3 m, vec3 v, vec4 dest);
X   CGLM_INLINE void glm_mat4x3_transpose(mat4x3 m, mat3x4 dest);
X   CGLM_INLINE void glm_mat4x3_scale(mat4x3 m, float s);
X */
X
X#ifndef cglm_mat4x3_h
X#define cglm_mat4x3_h
X
X#include "common.h"
X
X#define GLM_MAT4X3_ZERO_INIT {{0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}, \
X                              {0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}}
X
X/* for C only */
X#define GLM_MAT4X3_ZERO GLM_MAT4X3_ZERO_INIT
X
X/*!
X * @brief copy all members of [mat] to [dest]
X *
X * @param[in]  mat  source
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_mat4x3_copy(mat4x3 mat, mat4x3 dest) {
X  dest[0][0] = mat[0][0];
X  dest[0][1] = mat[0][1];
X  dest[0][2] = mat[0][2];
X
X  dest[1][0] = mat[1][0];
X  dest[1][1] = mat[1][1];
X  dest[1][2] = mat[1][2];
X
X  dest[2][0] = mat[2][0];
X  dest[2][1] = mat[2][1];
X  dest[2][2] = mat[2][2];
X
X  dest[3][0] = mat[3][0];
X  dest[3][1] = mat[3][1];
X  dest[3][2] = mat[3][2];
X}
X
X/*!
X * @brief make given matrix zero.
X *
X * @param[in, out]  mat  matrix
X */
XCGLM_INLINE
Xvoid
Xglm_mat4x3_zero(mat4x3 mat) {
X  CGLM_ALIGN_MAT mat4x3 t = GLM_MAT4X3_ZERO_INIT;
X  glm_mat4x3_copy(t, mat);
X}
X
X/*!
X * @brief Create mat4x3 matrix from pointer
X *
X * @param[in]  src  pointer to an array of floats
X * @param[out] dest matrix
X */
XCGLM_INLINE
Xvoid
Xglm_mat4x3_make(float * __restrict src, mat4x3 dest) {
X  dest[0][0] = src[0];
X  dest[0][1] = src[1];
X  dest[0][2] = src[2];
X
X  dest[1][0] = src[3];
X  dest[1][1] = src[4];
X  dest[1][2] = src[5];
X
X  dest[2][0] = src[6];
X  dest[2][1] = src[7];
X  dest[2][2] = src[8];
X
X  dest[3][0] = src[9];
X  dest[3][1] = src[10];
X  dest[3][2] = src[11];
X}
X
X/*!
X * @brief multiply m1 and m2 to dest
X *
X * @code
X * glm_mat4x3_mul(mat4x3, mat3x4, mat4);
X * @endcode
X *
X * @param[in]  m1   left matrix (mat4x3)
X * @param[in]  m2   right matrix (mat3x4)
X * @param[out] dest destination matrix (mat4)
X */
XCGLM_INLINE
Xvoid
Xglm_mat4x3_mul(mat4x3 m1, mat3x4 m2, mat4 dest) {
X  float a00 = m1[0][0], a01 = m1[0][1], a02 = m1[0][2],
X        a10 = m1[1][0], a11 = m1[1][1], a12 = m1[1][2],
X        a20 = m1[2][0], a21 = m1[2][1], a22 = m1[2][2],
X        a30 = m1[3][0], a31 = m1[3][1], a32 = m1[3][2],
X
X        b00 = m2[0][0], b01 = m2[0][1], b02 = m2[0][2], b03 = m2[0][3],
X        b10 = m2[1][0], b11 = m2[1][1], b12 = m2[1][2], b13 = m2[1][3],
X        b20 = m2[2][0], b21 = m2[2][1], b22 = m2[2][2], b23 = m2[2][3];
X
X  dest[0][0] = a00 * b00 + a01 * b10 + a02 * b20;
X  dest[0][1] = a00 * b01 + a01 * b11 + a02 * b21;
X  dest[0][2] = a00 * b02 + a01 * b12 + a02 * b22;
X  dest[0][3] = a00 * b03 + a01 * b13 + a02 * b23;
X
X  dest[1][0] = a10 * b00 + a11 * b10 + a12 * b20;
X  dest[1][1] = a10 * b01 + a11 * b11 + a12 * b21;
X  dest[1][2] = a10 * b02 + a11 * b12 + a12 * b22;
X  dest[1][3] = a10 * b03 + a11 * b13 + a12 * b23;
X
X  dest[2][0] = a20 * b00 + a21 * b10 + a22 * b20;
X  dest[2][1] = a20 * b01 + a21 * b11 + a22 * b21;
X  dest[2][2] = a20 * b02 + a21 * b12 + a22 * b22;
X  dest[2][3] = a20 * b03 + a21 * b13 + a22 * b23;
X
X  dest[3][0] = a30 * b00 + a31 * b10 + a32 * b20;
X  dest[3][1] = a30 * b01 + a31 * b11 + a32 * b21;
X  dest[3][2] = a30 * b02 + a31 * b12 + a32 * b22;
X  dest[3][3] = a30 * b03 + a31 * b13 + a32 * b23;
X}
X
X/*!
X * @brief multiply matrix with column vector and store in dest vector
X *
X * @param[in]  m    matrix (left)
X * @param[in]  v    vector (right, column vector)
X * @param[out] dest result vector
X */
XCGLM_INLINE
Xvoid
Xglm_mat4x3_mulv(mat4x3 m, vec3 v, vec4 dest) {
X  float v0 = v[0], v1 = v[1], v2 = v[2];
X
X  dest[0] = m[0][0] * v0 + m[0][1] * v1 + m[0][2] * v2;
X  dest[1] = m[1][0] * v0 + m[1][1] * v1 + m[1][2] * v2;
X  dest[2] = m[2][0] * v0 + m[2][1] * v1 + m[2][2] * v2;
X  dest[3] = m[3][0] * v0 + m[3][1] * v1 + m[3][2] * v2;
X}
X
X/*!
X * @brief transpose matrix and store in dest
X *
X * @param[in]  m     matrix
X * @param[out] dest  result
X */
XCGLM_INLINE
Xvoid
Xglm_mat4x3_transpose(mat4x3 m, mat3x4 dest) {
X  dest[0][0] = m[0][0];
X  dest[0][1] = m[1][0];
X  dest[0][2] = m[2][0];
X  dest[0][3] = m[3][0];
X
X  dest[1][0] = m[0][1];
X  dest[1][1] = m[1][1];
X  dest[1][2] = m[2][1];
X  dest[1][3] = m[3][1];
X
X  dest[2][0] = m[0][2];
X  dest[2][1] = m[1][2];
X  dest[2][2] = m[2][2];
X  dest[2][3] = m[3][2];
X}
X
X/*!
X * @brief scale (multiply with scalar) matrix
X *
X * multiply matrix with scalar
X *
X * @param[in, out] m matrix
X * @param[in]    s scalar
X */
XCGLM_INLINE
Xvoid
Xglm_mat4x3_scale(mat4x3 m, float s) {
X  m[0][0] *= s;  m[0][1] *= s;  m[0][2] *= s;  m[1][0] *= s;
X  m[1][1] *= s;  m[1][2] *= s;  m[2][0] *= s;  m[2][1] *= s;
X  m[2][2] *= s;  m[3][0] *= s;  m[3][1] *= s;  m[3][2] *= s;
X}
X
X#endif
f6cf8510bef98f9dec12aa6fa1401e78
echo x - cglm/mat3.h
sed 's/^X//' >cglm/mat3.h << '7b299bcaf63cee6af26f15e451462141'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Macros:
X   GLM_MAT3_IDENTITY_INIT
X   GLM_MAT3_ZERO_INIT
X   GLM_MAT3_IDENTITY
X   GLM_MAT3_ZERO
X   glm_mat3_dup(mat, dest)
X
X Functions:
X   CGLM_INLINE void  glm_mat3_copy(mat3 mat, mat3 dest);
X   CGLM_INLINE void  glm_mat3_identity(mat3 mat);
X   CGLM_INLINE void  glm_mat3_identity_array(mat3 * restrict mat, size_t count);
X   CGLM_INLINE void  glm_mat3_zero(mat3 mat);
X   CGLM_INLINE void  glm_mat3_mul(mat3 m1, mat3 m2, mat3 dest);
X   CGLM_INLINE void  glm_mat3_transpose_to(mat3 m, mat3 dest);
X   CGLM_INLINE void  glm_mat3_transpose(mat3 m);
X   CGLM_INLINE void  glm_mat3_mulv(mat3 m, vec3 v, vec3 dest);
X   CGLM_INLINE float glm_mat3_trace(mat3 m);
X   CGLM_INLINE void  glm_mat3_quat(mat3 m, versor dest);
X   CGLM_INLINE void  glm_mat3_scale(mat3 m, float s);
X   CGLM_INLINE float glm_mat3_det(mat3 mat);
X   CGLM_INLINE void  glm_mat3_inv(mat3 mat, mat3 dest);
X   CGLM_INLINE void  glm_mat3_swap_col(mat3 mat, int col1, int col2);
X   CGLM_INLINE void  glm_mat3_swap_row(mat3 mat, int row1, int row2);
X   CGLM_INLINE float glm_mat3_rmc(vec3 r, mat3 m, vec3 c);
X   CGLM_INLINE void  glm_mat3_make(float * restrict src, mat3 dest);
X */
X
X#ifndef cglm_mat3_h
X#define cglm_mat3_h
X
X#include "common.h"
X#include "vec3.h"
X
X#ifdef CGLM_SSE_FP
X#  include "simd/sse2/mat3.h"
X#endif
X
X#ifdef CGLM_SIMD_WASM
X#  include "simd/wasm/mat3.h"
X#endif
X
X#define GLM_MAT3_IDENTITY_INIT  {{1.0f, 0.0f, 0.0f},                          \
X                                 {0.0f, 1.0f, 0.0f},                          \
X                                 {0.0f, 0.0f, 1.0f}}
X#define GLM_MAT3_ZERO_INIT      {{0.0f, 0.0f, 0.0f},                          \
X                                 {0.0f, 0.0f, 0.0f},                          \
X                                 {0.0f, 0.0f, 0.0f}}
X
X
X/* for C only */
X#define GLM_MAT3_IDENTITY ((mat3)GLM_MAT3_IDENTITY_INIT)
X#define GLM_MAT3_ZERO     ((mat3)GLM_MAT3_ZERO_INIT)
X
X/* DEPRECATED! use _copy, _ucopy versions */
X#define glm_mat3_dup(mat, dest) glm_mat3_copy(mat, dest)
X
X/*!
X * @brief copy all members of [mat] to [dest]
X *
X * @param[in]  mat  source
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_mat3_copy(mat3 mat, mat3 dest) {
X  dest[0][0] = mat[0][0];
X  dest[0][1] = mat[0][1];
X  dest[0][2] = mat[0][2];
X
X  dest[1][0] = mat[1][0];
X  dest[1][1] = mat[1][1];
X  dest[1][2] = mat[1][2];
X
X  dest[2][0] = mat[2][0];
X  dest[2][1] = mat[2][1];
X  dest[2][2] = mat[2][2];
X}
X
X/*!
X * @brief make given matrix identity. It is identical with below,
X *        but it is more easy to do that with this func especially for members
X *        e.g. glm_mat3_identity(aStruct->aMatrix);
X *
X * @code
X * glm_mat3_copy(GLM_MAT3_IDENTITY, mat); // C only
X *
X * // or
X * mat3 mat = GLM_MAT3_IDENTITY_INIT;
X * @endcode
X *
X * @param[in, out]  mat  destination
X */
XCGLM_INLINE
Xvoid
Xglm_mat3_identity(mat3 mat) {
X  CGLM_ALIGN_MAT mat3 t = GLM_MAT3_IDENTITY_INIT;
X  glm_mat3_copy(t, mat);
X}
X
X/*!
X * @brief make given matrix array's each element identity matrix
X *
X * @param[in, out]  mat   matrix array (must be aligned (16/32)
X *                        if alignment is not disabled)
X *
X * @param[in]       count count of matrices
X */
XCGLM_INLINE
Xvoid
Xglm_mat3_identity_array(mat3 * __restrict mat, size_t count) {
X  CGLM_ALIGN_MAT mat3 t = GLM_MAT3_IDENTITY_INIT;
X  size_t i;
X
X  for (i = 0; i < count; i++) {
X    glm_mat3_copy(t, mat[i]);
X  }
X}
X
X/*!
X * @brief make given matrix zero.
X *
X * @param[in, out]  mat  matrix
X */
XCGLM_INLINE
Xvoid
Xglm_mat3_zero(mat3 mat) {
X  CGLM_ALIGN_MAT mat3 t = GLM_MAT3_ZERO_INIT;
X  glm_mat3_copy(t, mat);
X}
X
X/*!
X * @brief multiply m1 and m2 to dest
X *
X * m1, m2 and dest matrices can be same matrix, it is possible to write this:
X *
X * @code
X * mat3 m = GLM_MAT3_IDENTITY_INIT;
X * glm_mat3_mul(m, m, m);
X * @endcode
X *
X * @param[in]  m1   left matrix
X * @param[in]  m2   right matrix
X * @param[out] dest destination matrix
X */
XCGLM_INLINE
Xvoid
Xglm_mat3_mul(mat3 m1, mat3 m2, mat3 dest) {
X#if defined(__wasm__) && defined(__wasm_simd128__)
X  glm_mat3_mul_wasm(m1, m2, dest);
X#elif defined( __SSE__ ) || defined( __SSE2__ )
X  glm_mat3_mul_sse2(m1, m2, dest);
X#else
X  float a00 = m1[0][0], a01 = m1[0][1], a02 = m1[0][2],
X        a10 = m1[1][0], a11 = m1[1][1], a12 = m1[1][2],
X        a20 = m1[2][0], a21 = m1[2][1], a22 = m1[2][2],
X
X        b00 = m2[0][0], b01 = m2[0][1], b02 = m2[0][2],
X        b10 = m2[1][0], b11 = m2[1][1], b12 = m2[1][2],
X        b20 = m2[2][0], b21 = m2[2][1], b22 = m2[2][2];
X
X  dest[0][0] = a00 * b00 + a10 * b01 + a20 * b02;
X  dest[0][1] = a01 * b00 + a11 * b01 + a21 * b02;
X  dest[0][2] = a02 * b00 + a12 * b01 + a22 * b02;
X  dest[1][0] = a00 * b10 + a10 * b11 + a20 * b12;
X  dest[1][1] = a01 * b10 + a11 * b11 + a21 * b12;
X  dest[1][2] = a02 * b10 + a12 * b11 + a22 * b12;
X  dest[2][0] = a00 * b20 + a10 * b21 + a20 * b22;
X  dest[2][1] = a01 * b20 + a11 * b21 + a21 * b22;
X  dest[2][2] = a02 * b20 + a12 * b21 + a22 * b22;
X#endif
X}
X
X/*!
X * @brief transpose mat3 and store in dest
X *
X * source matrix will not be transposed unless dest is m
X *
X * @param[in]  m     matrix
X * @param[out] dest  result
X */
XCGLM_INLINE
Xvoid
Xglm_mat3_transpose_to(mat3 m, mat3 dest) {
X  dest[0][0] = m[0][0];
X  dest[0][1] = m[1][0];
X  dest[0][2] = m[2][0];
X  dest[1][0] = m[0][1];
X  dest[1][1] = m[1][1];
X  dest[1][2] = m[2][1];
X  dest[2][0] = m[0][2];
X  dest[2][1] = m[1][2];
X  dest[2][2] = m[2][2];
X}
X
X/*!
X * @brief tranpose mat3 and store result in same matrix
X *
X * @param[in, out] m source and dest
X */
XCGLM_INLINE
Xvoid
Xglm_mat3_transpose(mat3 m) {
X  CGLM_ALIGN_MAT mat3 tmp;
X
X  tmp[0][1] = m[1][0];
X  tmp[0][2] = m[2][0];
X  tmp[1][0] = m[0][1];
X  tmp[1][2] = m[2][1];
X  tmp[2][0] = m[0][2];
X  tmp[2][1] = m[1][2];
X
X  m[0][1] = tmp[0][1];
X  m[0][2] = tmp[0][2];
X  m[1][0] = tmp[1][0];
X  m[1][2] = tmp[1][2];
X  m[2][0] = tmp[2][0];
X  m[2][1] = tmp[2][1];
X}
X
X/*!
X * @brief multiply mat3 with vec3 (column vector) and store in dest vector
X *
X * @param[in]  m    mat3 (left)
X * @param[in]  v    vec3 (right, column vector)
X * @param[out] dest vec3 (result, column vector)
X */
XCGLM_INLINE
Xvoid
Xglm_mat3_mulv(mat3 m, vec3 v, vec3 dest) {
X  vec3 res;
X  res[0] = m[0][0] * v[0] + m[1][0] * v[1] + m[2][0] * v[2];
X  res[1] = m[0][1] * v[0] + m[1][1] * v[1] + m[2][1] * v[2];
X  res[2] = m[0][2] * v[0] + m[1][2] * v[1] + m[2][2] * v[2];
X  glm_vec3_copy(res, dest);
X}
X
X/*!
X * @brief trace of matrix
X *
X * sum of the elements on the main diagonal from upper left to the lower right
X *
X * @param[in]  m matrix
X */
XCGLM_INLINE
Xfloat
Xglm_mat3_trace(mat3 m) {
X  return m[0][0] + m[1][1] + m[2][2];
X}
X
X/*!
X * @brief convert mat3 to quaternion
X *
X * @param[in]  m    rotation matrix
X * @param[out] dest destination quaternion
X */
XCGLM_INLINE
Xvoid
Xglm_mat3_quat(mat3 m, versor dest) {
X  float trace, r, rinv;
X
X  /* it seems using like m12 instead of m[1][2] causes extra instructions */
X
X  trace = m[0][0] + m[1][1] + m[2][2];
X  if (trace >= 0.0f) {
X    r       = sqrtf(1.0f + trace);
X    rinv    = 0.5f / r;
X
X    dest[0] = rinv * (m[1][2] - m[2][1]);
X    dest[1] = rinv * (m[2][0] - m[0][2]);
X    dest[2] = rinv * (m[0][1] - m[1][0]);
X    dest[3] = r    * 0.5f;
X  } else if (m[0][0] >= m[1][1] && m[0][0] >= m[2][2]) {
X    r       = sqrtf(1.0f - m[1][1] - m[2][2] + m[0][0]);
X    rinv    = 0.5f / r;
X
X    dest[0] = r    * 0.5f;
X    dest[1] = rinv * (m[0][1] + m[1][0]);
X    dest[2] = rinv * (m[0][2] + m[2][0]);
X    dest[3] = rinv * (m[1][2] - m[2][1]);
X  } else if (m[1][1] >= m[2][2]) {
X    r       = sqrtf(1.0f - m[0][0] - m[2][2] + m[1][1]);
X    rinv    = 0.5f / r;
X
X    dest[0] = rinv * (m[0][1] + m[1][0]);
X    dest[1] = r    * 0.5f;
X    dest[2] = rinv * (m[1][2] + m[2][1]);
X    dest[3] = rinv * (m[2][0] - m[0][2]);
X  } else {
X    r       = sqrtf(1.0f - m[0][0] - m[1][1] + m[2][2]);
X    rinv    = 0.5f / r;
X
X    dest[0] = rinv * (m[0][2] + m[2][0]);
X    dest[1] = rinv * (m[1][2] + m[2][1]);
X    dest[2] = r    * 0.5f;
X    dest[3] = rinv * (m[0][1] - m[1][0]);
X  }
X}
X
X/*!
X * @brief scale (multiply with scalar) matrix
X *
X * multiply matrix with scalar
X *
X * @param[in, out] m matrix
X * @param[in]      s scalar
X */
XCGLM_INLINE
Xvoid
Xglm_mat3_scale(mat3 m, float s) {
X  m[0][0] *= s; m[0][1] *= s; m[0][2] *= s;
X  m[1][0] *= s; m[1][1] *= s; m[1][2] *= s;
X  m[2][0] *= s; m[2][1] *= s; m[2][2] *= s;
X}
X
X/*!
X * @brief mat3 determinant
X *
X * @param[in] mat matrix
X *
X * @return determinant
X */
XCGLM_INLINE
Xfloat
Xglm_mat3_det(mat3 mat) {
X  float a = mat[0][0], b = mat[0][1], c = mat[0][2],
X        d = mat[1][0], e = mat[1][1], f = mat[1][2],
X        g = mat[2][0], h = mat[2][1], i = mat[2][2];
X
X  return a * (e * i - h * f) - d * (b * i - c * h) + g * (b * f - c * e);
X}
X
X/*!
X * @brief inverse mat3 and store in dest
X *
X * @param[in]  mat  matrix
X * @param[out] dest inverse matrix
X */
XCGLM_INLINE
Xvoid
Xglm_mat3_inv(mat3 mat, mat3 dest) {
X  float det;
X  float a = mat[0][0], b = mat[0][1], c = mat[0][2],
X        d = mat[1][0], e = mat[1][1], f = mat[1][2],
X        g = mat[2][0], h = mat[2][1], i = mat[2][2];
X
X  dest[0][0] =   e * i - f * h;
X  dest[0][1] = -(b * i - h * c);
X  dest[0][2] =   b * f - e * c;
X  dest[1][0] = -(d * i - g * f);
X  dest[1][1] =   a * i - c * g;
X  dest[1][2] = -(a * f - d * c);
X  dest[2][0] =   d * h - g * e;
X  dest[2][1] = -(a * h - g * b);
X  dest[2][2] =   a * e - b * d;
X
X  det = 1.0f / (a * dest[0][0] + b * dest[1][0] + c * dest[2][0]);
X
X  glm_mat3_scale(dest, det);
X}
X
X/*!
X * @brief swap two matrix columns
X *
X * @param[in,out] mat  matrix
X * @param[in]     col1 col1
X * @param[in]     col2 col2
X */
XCGLM_INLINE
Xvoid
Xglm_mat3_swap_col(mat3 mat, int col1, int col2) {
X  vec3 tmp;
X  glm_vec3_copy(mat[col1], tmp);
X  glm_vec3_copy(mat[col2], mat[col1]);
X  glm_vec3_copy(tmp, mat[col2]);
X}
X
X/*!
X * @brief swap two matrix rows
X *
X * @param[in,out] mat  matrix
X * @param[in]     row1 row1
X * @param[in]     row2 row2
X */
XCGLM_INLINE
Xvoid
Xglm_mat3_swap_row(mat3 mat, int row1, int row2) {
X  vec3 tmp;
X  tmp[0] = mat[0][row1];
X  tmp[1] = mat[1][row1];
X  tmp[2] = mat[2][row1];
X
X  mat[0][row1] = mat[0][row2];
X  mat[1][row1] = mat[1][row2];
X  mat[2][row1] = mat[2][row2];
X
X  mat[0][row2] = tmp[0];
X  mat[1][row2] = tmp[1];
X  mat[2][row2] = tmp[2];
X}
X
X/*!
X * @brief helper for  R (row vector) * M (matrix) * C (column vector)
X *
X * rmc stands for Row * Matrix * Column
X *
X * the result is scalar because R * M = Matrix1x3 (row vector),
X * then Matrix1x3 * Vec3 (column vector) = Matrix1x1 (Scalar)
X *
X * @param[in]  r   row vector or matrix1x3
X * @param[in]  m   matrix3x3
X * @param[in]  c   column vector or matrix3x1
X *
X * @return scalar value e.g. Matrix1x1
X */
XCGLM_INLINE
Xfloat
Xglm_mat3_rmc(vec3 r, mat3 m, vec3 c) {
X  vec3 tmp;
X  glm_mat3_mulv(m, c, tmp);
X  return glm_vec3_dot(r, tmp);
X}
X
X/*!
X * @brief Create mat3 matrix from pointer
X *
X * @param[in]  src  pointer to an array of floats
X * @param[out] dest matrix
X */
XCGLM_INLINE
Xvoid
Xglm_mat3_make(float * __restrict src, mat3 dest) {
X  dest[0][0] = src[0];
X  dest[0][1] = src[1];
X  dest[0][2] = src[2];
X
X  dest[1][0] = src[3];
X  dest[1][1] = src[4];
X  dest[1][2] = src[5];
X
X  dest[2][0] = src[6];
X  dest[2][1] = src[7];
X  dest[2][2] = src[8];
X}
X
X#endif /* cglm_mat3_h */
7b299bcaf63cee6af26f15e451462141
echo x - cglm/mat3x2.h
sed 's/^X//' >cglm/mat3x2.h << '8c5cc631ba0ae62910d3a0bfdd08b498'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Macros:
X   GLM_MAT3X2_ZERO_INIT
X   GLM_MAT3X2_ZERO
X
X Functions:
X   CGLM_INLINE void glm_mat3x2_copy(mat3x2 mat, mat3x2 dest);
X   CGLM_INLINE void glm_mat3x2_zero(mat3x2 mat);
X   CGLM_INLINE void glm_mat3x2_make(float * __restrict src, mat3x2 dest);
X   CGLM_INLINE void glm_mat3x2_mul(mat3x2 m1, mat2x3 m2, mat3 dest);
X   CGLM_INLINE void glm_mat3x2_mulv(mat3x2 m, vec2 v, vec3 dest);
X   CGLM_INLINE void glm_mat3x2_transpose(mat3x2 m, mat2x3 dest);
X   CGLM_INLINE void glm_mat3x2_scale(mat3x2 m, float s);
X */
X
X#ifndef cglm_mat3x2_h
X#define cglm_mat3x2_h
X
X#include "common.h"
X
X#define GLM_MAT3X2_ZERO_INIT {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}
X
X/* for C only */
X#define GLM_MAT3X2_ZERO GLM_MAT3X2_ZERO_INIT
X
X/*!
X * @brief copy all members of [mat] to [dest]
X *
X * @param[in]  mat  source
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_mat3x2_copy(mat3x2 mat, mat3x2 dest) {
X  dest[0][0] = mat[0][0];
X  dest[0][1] = mat[0][1];
X
X  dest[1][0] = mat[1][0];
X  dest[1][1] = mat[1][1];
X
X  dest[2][0] = mat[2][0];
X  dest[2][1] = mat[2][1];
X}
X
X/*!
X * @brief make given matrix zero.
X *
X * @param[in, out]  mat  matrix
X */
XCGLM_INLINE
Xvoid
Xglm_mat3x2_zero(mat3x2 mat) {
X  CGLM_ALIGN_MAT mat3x2 t = GLM_MAT3X2_ZERO_INIT;
X  glm_mat3x2_copy(t, mat);
X}
X
X/*!
X * @brief Create mat3x2 matrix from pointer
X *
X * @param[in]  src  pointer to an array of floats
X * @param[out] dest matrix
X */
XCGLM_INLINE
Xvoid
Xglm_mat3x2_make(float * __restrict src, mat3x2 dest) {
X  dest[0][0] = src[0];
X  dest[0][1] = src[1];
X
X  dest[1][0] = src[2];
X  dest[1][1] = src[3];
X
X  dest[2][0] = src[4];
X  dest[2][1] = src[5];
X}
X
X/*!
X * @brief multiply m1 and m2 to dest
X *
X * @code
X * glm_mat3x2_mul(mat3x2, mat2x3, mat3);
X * @endcode
X *
X * @param[in]  m1   left matrix (mat3x2)
X * @param[in]  m2   right matrix (mat2x3)
X * @param[out] dest destination matrix (mat3)
X */
XCGLM_INLINE
Xvoid
Xglm_mat3x2_mul(mat3x2 m1, mat2x3 m2, mat3 dest) {
X  float a00 = m1[0][0], a01 = m1[0][1],
X        a10 = m1[1][0], a11 = m1[1][1],
X        a20 = m1[2][0], a21 = m1[2][1],
X
X        b00 = m2[0][0], b01 = m2[0][1], b02 = m2[0][2],
X        b10 = m2[1][0], b11 = m2[1][1], b12 = m2[1][2];
X
X  dest[0][0] = a00 * b00 + a01 * b10;
X  dest[0][1] = a00 * b01 + a01 * b11;
X  dest[0][2] = a00 * b02 + a01 * b12;
X
X  dest[1][0] = a10 * b00 + a11 * b10;
X  dest[1][1] = a10 * b01 + a11 * b11;
X  dest[1][2] = a10 * b02 + a11 * b12;
X
X  dest[2][0] = a20 * b00 + a21 * b10;
X  dest[2][1] = a20 * b01 + a21 * b11;
X  dest[2][2] = a20 * b02 + a21 * b12;
X}
X
X/*!
X * @brief multiply matrix with column vector and store in dest vector
X *
X * @param[in]  m    matrix (left)
X * @param[in]  v    vector (right, column vector)
X * @param[out] dest result vector
X */
XCGLM_INLINE
Xvoid
Xglm_mat3x2_mulv(mat3x2 m, vec2 v, vec3 dest) {
X  float v0 = v[0], v1 = v[1];
X
X  dest[0] = m[0][0] * v0 + m[0][1] * v1;
X  dest[1] = m[1][0] * v0 + m[1][1] * v1;
X  dest[2] = m[2][0] * v0 + m[2][1] * v1;
X}
X
X/*!
X * @brief transpose matrix and store in dest
X *
X * @param[in]  m     matrix
X * @param[out] dest  result
X */
XCGLM_INLINE
Xvoid
Xglm_mat3x2_transpose(mat3x2 m, mat2x3 dest) {
X  dest[0][0] = m[0][0];  dest[0][1] = m[1][0];  dest[0][2] = m[2][0];
X  dest[1][0] = m[0][1];  dest[1][1] = m[1][1];  dest[1][2] = m[2][1];
X}
X
X/*!
X * @brief scale (multiply with scalar) matrix
X *
X * multiply matrix with scalar
X *
X * @param[in, out] m matrix
X * @param[in]    s scalar
X */
XCGLM_INLINE
Xvoid
Xglm_mat3x2_scale(mat3x2 m, float s) {
X  m[0][0] *= s;  m[0][1] *= s;  m[1][0] *= s;
X  m[1][1] *= s;  m[2][0] *= s;  m[2][1] *= s;
X}
X
X#endif
8c5cc631ba0ae62910d3a0bfdd08b498
echo x - cglm/mat3x4.h
sed 's/^X//' >cglm/mat3x4.h << '5a3ba639a430d75886c59f215b07f887'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Macros:
X   GLM_MAT3X4_ZERO_INIT
X   GLM_MAT3X4_ZERO
X
X Functions:
X   CGLM_INLINE void glm_mat3x4_copy(mat3x4 mat, mat3x4 dest);
X   CGLM_INLINE void glm_mat3x4_zero(mat3x4 mat);
X   CGLM_INLINE void glm_mat3x4_make(float * __restrict src, mat3x4 dest);
X   CGLM_INLINE void glm_mat3x4_mul(mat3x4 m1, mat4x3 m2, mat3 dest);
X   CGLM_INLINE void glm_mat3x4_mulv(mat3x4 m, vec4 v, vec3 dest);
X   CGLM_INLINE void glm_mat3x4_transpose(mat3x4 m, mat4x3 dest);
X   CGLM_INLINE void glm_mat3x4_scale(mat3x4 m, float s);
X */
X
X#ifndef cglm_mat3x4_h
X#define cglm_mat3x4_h
X
X#include "common.h"
X
X#define GLM_MAT3X4_ZERO_INIT {{0.0f, 0.0f, 0.0f, 0.0f}, \
X                              {0.0f, 0.0f, 0.0f, 0.0f}, \
X                              {0.0f, 0.0f, 0.0f, 0.0f}}
X
X/* for C only */
X#define GLM_MAT3X4_ZERO GLM_MAT3X4_ZERO_INIT
X
X/*!
X * @brief copy all members of [mat] to [dest]
X *
X * @param[in]  mat  source
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_mat3x4_copy(mat3x4 mat, mat3x4 dest) {
X  glm_vec4_ucopy(mat[0], dest[0]);
X  glm_vec4_ucopy(mat[1], dest[1]);
X  glm_vec4_ucopy(mat[2], dest[2]);
X}
X
X/*!
X * @brief make given matrix zero.
X *
X * @param[in, out]  mat  matrix
X */
XCGLM_INLINE
Xvoid
Xglm_mat3x4_zero(mat3x4 mat) {
X  CGLM_ALIGN_MAT mat3x4 t = GLM_MAT3X4_ZERO_INIT;
X  glm_mat3x4_copy(t, mat);
X}
X
X/*!
X * @brief Create mat3x4 matrix from pointer
X *
X * @param[in]  src  pointer to an array of floats
X * @param[out] dest matrix
X */
XCGLM_INLINE
Xvoid
Xglm_mat3x4_make(float * __restrict src, mat3x4 dest) {
X  dest[0][0] = src[0];
X  dest[0][1] = src[1];
X  dest[0][2] = src[2];
X  dest[0][3] = src[3];
X
X  dest[1][0] = src[4];
X  dest[1][1] = src[5];
X  dest[1][2] = src[6];
X  dest[1][3] = src[7];
X
X  dest[2][0] = src[8];
X  dest[2][1] = src[9];
X  dest[2][2] = src[10];
X  dest[2][3] = src[11];
X}
X
X/*!
X * @brief multiply m1 and m2 to dest
X *
X * @code
X * glm_mat3x4_mul(mat3x4, mat4x3, mat3);
X * @endcode
X *
X * @param[in]  m1   left matrix (mat3x4)
X * @param[in]  m2   right matrix (mat4x3)
X * @param[out] dest destination matrix (mat3)
X */
XCGLM_INLINE
Xvoid
Xglm_mat3x4_mul(mat3x4 m1, mat4x3 m2, mat3 dest) {
X  float a00 = m1[0][0], a01 = m1[0][1], a02 = m1[0][2], a03 = m1[0][3],
X        a10 = m1[1][0], a11 = m1[1][1], a12 = m1[1][2], a13 = m1[1][3],
X        a20 = m1[2][0], a21 = m1[2][1], a22 = m1[2][2], a23 = m1[2][3],
X
X        b00 = m2[0][0], b01 = m2[0][1], b02 = m2[0][2],
X        b10 = m2[1][0], b11 = m2[1][1], b12 = m2[1][2],
X        b20 = m2[2][0], b21 = m2[2][1], b22 = m2[2][2],
X        b30 = m2[3][0], b31 = m2[3][1], b32 = m2[3][2];
X
X  dest[0][0] = a00 * b00 + a01 * b10 + a02 * b20 + a03 * b30;
X  dest[0][1] = a00 * b01 + a01 * b11 + a02 * b21 + a03 * b31;
X  dest[0][2] = a00 * b02 + a01 * b12 + a02 * b22 + a03 * b32;
X
X  dest[1][0] = a10 * b00 + a11 * b10 + a12 * b20 + a13 * b30;
X  dest[1][1] = a10 * b01 + a11 * b11 + a12 * b21 + a13 * b31;
X  dest[1][2] = a10 * b02 + a11 * b12 + a12 * b22 + a13 * b32;
X
X  dest[2][0] = a20 * b00 + a21 * b10 + a22 * b20 + a23 * b30;
X  dest[2][1] = a20 * b01 + a21 * b11 + a22 * b21 + a23 * b31;
X  dest[2][2] = a20 * b02 + a21 * b12 + a22 * b22 + a23 * b32;
X}
X
X/*!
X * @brief multiply matrix with column vector and store in dest vector
X *
X * @param[in]  m    matrix (left)
X * @param[in]  v    vector (right, column vector)
X * @param[out] dest result vector
X */
XCGLM_INLINE
Xvoid
Xglm_mat3x4_mulv(mat3x4 m, vec4 v, vec3 dest) {
X  float v0 = v[0], v1 = v[1], v2 = v[2], v3 = v[3];
X
X  dest[0] = m[0][0] * v0 + m[0][1] * v1 + m[0][2] * v2 + m[0][3] * v3;
X  dest[1] = m[1][0] * v0 + m[1][1] * v1 + m[1][2] * v2 + m[1][3] * v3;
X  dest[2] = m[2][0] * v0 + m[2][1] * v1 + m[2][2] * v2 + m[2][3] * v3;
X}
X
X/*!
X * @brief transpose matrix and store in dest
X *
X * @param[in]  m     matrix
X * @param[out] dest  result
X */
XCGLM_INLINE
Xvoid
Xglm_mat3x4_transpose(mat3x4 m, mat4x3 dest) {
X  dest[0][0] = m[0][0];  dest[0][1] = m[1][0];  dest[0][2] = m[2][0];
X  dest[1][0] = m[0][1];  dest[1][1] = m[1][1];  dest[1][2] = m[2][1];
X  dest[2][0] = m[0][2];  dest[2][1] = m[1][2];  dest[2][2] = m[2][2];
X  dest[3][0] = m[0][3];  dest[3][1] = m[1][3];  dest[3][2] = m[2][3];
X}
X
X/*!
X * @brief scale (multiply with scalar) matrix
X *
X * multiply matrix with scalar
X *
X * @param[in, out] m matrix
X * @param[in]    s scalar
X */
XCGLM_INLINE
Xvoid
Xglm_mat3x4_scale(mat3x4 m, float s) {
X  m[0][0] *= s;  m[1][0] *= s;   m[2][0] *= s;
X  m[0][1] *= s;  m[1][1] *= s;   m[2][1] *= s;
X  m[0][2] *= s;  m[1][2] *= s;   m[2][2] *= s;
X  m[0][3] *= s;  m[1][3] *= s;   m[2][3] *= s;
X}
X
X#endif
5a3ba639a430d75886c59f215b07f887
echo x - cglm/mat2.h
sed 's/^X//' >cglm/mat2.h << '00da78bf771207805694989428f0a451'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Macros:
X   GLM_MAT2_IDENTITY_INIT
X   GLM_MAT2_ZERO_INIT
X   GLM_MAT2_IDENTITY
X   GLM_MAT2_ZERO
X
X Functions:
X   CGLM_INLINE void  glm_mat2_copy(mat2 mat, mat2 dest)
X   CGLM_INLINE void  glm_mat2_identity(mat2 mat)
X   CGLM_INLINE void  glm_mat2_identity_array(mat2 * restrict mat, size_t count)
X   CGLM_INLINE void  glm_mat2_zero(mat2 mat)
X   CGLM_INLINE void  glm_mat2_mul(mat2 m1, mat2 m2, mat2 dest)
X   CGLM_INLINE void  glm_mat2_transpose_to(mat2 m, mat2 dest)
X   CGLM_INLINE void  glm_mat2_transpose(mat2 m)
X   CGLM_INLINE void  glm_mat2_mulv(mat2 m, vec2 v, vec2 dest)
X   CGLM_INLINE float glm_mat2_trace(mat2 m)
X   CGLM_INLINE void  glm_mat2_scale(mat2 m, float s)
X   CGLM_INLINE float glm_mat2_det(mat2 mat)
X   CGLM_INLINE void  glm_mat2_inv(mat2 mat, mat2 dest)
X   CGLM_INLINE void  glm_mat2_swap_col(mat2 mat, int col1, int col2)
X   CGLM_INLINE void  glm_mat2_swap_row(mat2 mat, int row1, int row2)
X   CGLM_INLINE float glm_mat2_rmc(vec2 r, mat2 m, vec2 c)
X   CGLM_INLINE void  glm_mat2_make(float * restrict src, mat2 dest)
X */
X
X#ifndef cglm_mat2_h
X#define cglm_mat2_h
X
X#include "common.h"
X#include "vec2.h"
X
X#ifdef CGLM_SSE_FP
X#  include "simd/sse2/mat2.h"
X#endif
X
X#ifdef CGLM_NEON_FP
X#  include "simd/neon/mat2.h"
X#endif
X
X#ifdef CGLM_SIMD_WASM
X#  include "simd/wasm/mat2.h"
X#endif
X
X#define GLM_MAT2_IDENTITY_INIT  {{1.0f, 0.0f}, {0.0f, 1.0f}}
X#define GLM_MAT2_ZERO_INIT      {{0.0f, 0.0f}, {0.0f, 0.0f}}
X
X/* for C only */
X#define GLM_MAT2_IDENTITY ((mat2)GLM_MAT2_IDENTITY_INIT)
X#define GLM_MAT2_ZERO     ((mat2)GLM_MAT2_ZERO_INIT)
X
X/*!
X * @brief copy all members of [mat] to [dest]
X *
X * @param[in]  mat  source
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_mat2_copy(mat2 mat, mat2 dest) {
X  glm_vec4_ucopy(mat[0], dest[0]);
X}
X
X/*!
X * @brief make given matrix identity. It is identical with below,
X *        but it is more easy to do that with this func especially for members
X *        e.g. glm_mat2_identity(aStruct->aMatrix);
X *
X * @code
X * glm_mat2_copy(GLM_MAT2_IDENTITY, mat); // C only
X *
X * // or
X * mat2 mat = GLM_MAT2_IDENTITY_INIT;
X * @endcode
X *
X * @param[in, out]  mat  destination
X */
XCGLM_INLINE
Xvoid
Xglm_mat2_identity(mat2 mat) {
X  CGLM_ALIGN_MAT mat2 t = GLM_MAT2_IDENTITY_INIT;
X  glm_mat2_copy(t, mat);
X}
X
X/*!
X * @brief make given matrix array's each element identity matrix
X *
X * @param[in, out]  mat   matrix array (must be aligned (16)
X *                        if alignment is not disabled)
X *
X * @param[in]       count count of matrices
X */
XCGLM_INLINE
Xvoid
Xglm_mat2_identity_array(mat2 * __restrict mat, size_t count) {
X  CGLM_ALIGN_MAT mat2 t = GLM_MAT2_IDENTITY_INIT;
X  size_t i;
X
X  for (i = 0; i < count; i++) {
X    glm_mat2_copy(t, mat[i]);
X  }
X}
X
X/*!
X * @brief make given matrix zero.
X *
X * @param[in, out]  mat  matrix
X */
XCGLM_INLINE
Xvoid
Xglm_mat2_zero(mat2 mat) {
X  CGLM_ALIGN_MAT mat2 t = GLM_MAT2_ZERO_INIT;
X  glm_mat2_copy(t, mat);
X}
X
X/*!
X * @brief multiply m1 and m2 to dest
X *
X * m1, m2 and dest matrices can be same matrix, it is possible to write this:
X *
X * @code
X * mat2 m = GLM_MAT2_IDENTITY_INIT;
X * glm_mat2_mul(m, m, m);
X * @endcode
X *
X * @param[in]  m1   left matrix
X * @param[in]  m2   right matrix
X * @param[out] dest destination matrix
X */
XCGLM_INLINE
Xvoid
Xglm_mat2_mul(mat2 m1, mat2 m2, mat2 dest) {
X#if defined(__wasm__) && defined(__wasm_simd128__)
X  glm_mat2_mul_wasm(m1, m2, dest);
X#elif defined( __SSE__ ) || defined( __SSE2__ )
X  glm_mat2_mul_sse2(m1, m2, dest);
X#elif defined(CGLM_NEON_FP)
X  glm_mat2_mul_neon(m1, m2, dest);
X#else
X  float a00 = m1[0][0], a01 = m1[0][1],
X        a10 = m1[1][0], a11 = m1[1][1],
X        b00 = m2[0][0], b01 = m2[0][1],
X        b10 = m2[1][0], b11 = m2[1][1];
X
X  dest[0][0] = a00 * b00 + a10 * b01;
X  dest[0][1] = a01 * b00 + a11 * b01;
X  dest[1][0] = a00 * b10 + a10 * b11;
X  dest[1][1] = a01 * b10 + a11 * b11;
X#endif
X}
X
X/*!
X * @brief transpose mat2 and store in dest
X *
X * source matrix will not be transposed unless dest is m
X *
X * @param[in]  m     matrix
X * @param[out] dest  result
X */
XCGLM_INLINE
Xvoid
Xglm_mat2_transpose_to(mat2 m, mat2 dest) {
X#if defined(__wasm__) && defined(__wasm_simd128__)
X  glm_mat2_transp_wasm(m, dest);
X#elif defined( __SSE__ ) || defined( __SSE2__ )
X  glm_mat2_transp_sse2(m, dest);
X#else
X  dest[0][0] = m[0][0];
X  dest[0][1] = m[1][0];
X  dest[1][0] = m[0][1];
X  dest[1][1] = m[1][1];
X#endif
X}
X
X/*!
X * @brief tranpose mat2 and store result in same matrix
X *
X * @param[in, out] m source and dest
X */
XCGLM_INLINE
Xvoid
Xglm_mat2_transpose(mat2 m) {
X  float tmp;
X  tmp     = m[0][1];
X  m[0][1] = m[1][0];
X  m[1][0] = tmp;
X}
X
X/*!
X * @brief multiply mat2 with vec2 (column vector) and store in dest vector
X *
X * @param[in]  m    mat2 (left)
X * @param[in]  v    vec2 (right, column vector)
X * @param[out] dest vec2 (result, column vector)
X */
XCGLM_INLINE
Xvoid
Xglm_mat2_mulv(mat2 m, vec2 v, vec2 dest) {
X  dest[0] = m[0][0] * v[0] + m[1][0] * v[1];
X  dest[1] = m[0][1] * v[0] + m[1][1] * v[1];
X}
X
X/*!
X * @brief trace of matrix
X *
X * sum of the elements on the main diagonal from upper left to the lower right
X *
X * @param[in]  m matrix
X */
XCGLM_INLINE
Xfloat
Xglm_mat2_trace(mat2 m) {
X  return m[0][0] + m[1][1];
X}
X
X/*!
X * @brief scale (multiply with scalar) matrix
X *
X * multiply matrix with scalar
X *
X * @param[in, out] m matrix
X * @param[in]      s scalar
X */
XCGLM_INLINE
Xvoid
Xglm_mat2_scale(mat2 m, float s) {
X#if defined(__wasm__) && defined(__wasm_simd128__)
X  glmm_store(m[0], wasm_f32x4_mul(wasm_v128_load(m[0]),
X                                  wasm_f32x4_splat(s)));
X#elif defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(m[0], _mm_mul_ps(_mm_loadu_ps(m[0]), _mm_set1_ps(s)));
X#elif defined(CGLM_NEON_FP)
X  vst1q_f32(m[0], vmulq_f32(vld1q_f32(m[0]), vdupq_n_f32(s)));
X#else
X  m[0][0] = m[0][0] * s;
X  m[0][1] = m[0][1] * s;
X  m[1][0] = m[1][0] * s;
X  m[1][1] = m[1][1] * s;
X#endif
X}
X
X/*!
X * @brief mat2 determinant
X *
X * @param[in] mat matrix
X *
X * @return determinant
X */
XCGLM_INLINE
Xfloat
Xglm_mat2_det(mat2 mat) {
X  return mat[0][0] * mat[1][1] - mat[1][0] * mat[0][1];
X}
X
X/*!
X * @brief inverse mat2 and store in dest
X *
X * @param[in]  mat  matrix
X * @param[out] dest inverse matrix
X */
XCGLM_INLINE
Xvoid
Xglm_mat2_inv(mat2 mat, mat2 dest) {
X  float det;
X  float a = mat[0][0], b = mat[0][1],
X        c = mat[1][0], d = mat[1][1];
X
X  det = 1.0f / (a * d - b * c);
X
X  dest[0][0] =  d * det;
X  dest[0][1] = -b * det;
X  dest[1][0] = -c * det;
X  dest[1][1] =  a * det;
X}
X
X/*!
X * @brief swap two matrix columns
X *
X * @param[in,out] mat  matrix
X * @param[in]     col1 col1
X * @param[in]     col2 col2
X */
XCGLM_INLINE
Xvoid
Xglm_mat2_swap_col(mat2 mat, int col1, int col2) {
X  float a, b;
X
X  a = mat[col1][0];
X  b = mat[col1][1];
X
X  mat[col1][0] = mat[col2][0];
X  mat[col1][1] = mat[col2][1];
X
X  mat[col2][0] = a;
X  mat[col2][1] = b;
X}
X
X/*!
X * @brief swap two matrix rows
X *
X * @param[in,out] mat  matrix
X * @param[in]     row1 row1
X * @param[in]     row2 row2
X */
XCGLM_INLINE
Xvoid
Xglm_mat2_swap_row(mat2 mat, int row1, int row2) {
X  float a, b;
X
X  a = mat[0][row1];
X  b = mat[1][row1];
X
X  mat[0][row1] = mat[0][row2];
X  mat[1][row1] = mat[1][row2];
X
X  mat[0][row2] = a;
X  mat[1][row2] = b;
X}
X
X/*!
X * @brief helper for  R (row vector) * M (matrix) * C (column vector)
X *
X * rmc stands for Row * Matrix * Column
X *
X * the result is scalar because R * M = Matrix1x2 (row vector),
X * then Matrix1x2 * Vec2 (column vector) = Matrix1x1 (Scalar)
X *
X * @param[in]  r   row vector or matrix1x2
X * @param[in]  m   matrix2x2
X * @param[in]  c   column vector or matrix2x1
X *
X * @return scalar value e.g. Matrix1x1
X */
XCGLM_INLINE
Xfloat
Xglm_mat2_rmc(vec2 r, mat2 m, vec2 c) {
X  vec2 tmp;
X  glm_mat2_mulv(m, c, tmp);
X  return glm_vec2_dot(r, tmp);
X}
X
X/*!
X * @brief Create mat2 matrix from pointer
X *
X * @param[in]  src  pointer to an array of floats
X * @param[out] dest matrix
X */
XCGLM_INLINE
Xvoid
Xglm_mat2_make(float * __restrict src, mat2 dest) {
X  dest[0][0] = src[0];
X  dest[0][1] = src[1];
X  dest[1][0] = src[2];
X  dest[1][1] = src[3];
X}
X
X#endif /* cglm_mat2_h */
00da78bf771207805694989428f0a451
echo x - cglm/mat2x3.h
sed 's/^X//' >cglm/mat2x3.h << '531c556fbad58a11628023f249aff828'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Macros:
X   GLM_MAT2X3_ZERO_INIT
X   GLM_MAT2X3_ZERO
X
X Functions:
X   CGLM_INLINE void glm_mat2x3_copy(mat2x3 mat, mat2x3 dest);
X   CGLM_INLINE void glm_mat2x3_zero(mat2x3 mat);
X   CGLM_INLINE void glm_mat2x3_make(float * __restrict src, mat2x3 dest);
X   CGLM_INLINE void glm_mat2x3_mul(mat2x3 m1, mat3x2 m2, mat2 dest);
X   CGLM_INLINE void glm_mat2x3_mulv(mat2x3 m, vec3 v, vec2 dest);
X   CGLM_INLINE void glm_mat2x3_transpose(mat2x3 m, mat3x2 dest);
X   CGLM_INLINE void glm_mat2x3_scale(mat2x3 m, float s);
X */
X
X#ifndef cglm_mat2x3_h
X#define cglm_mat2x3_h
X
X#include "common.h"
X
X#define GLM_MAT2X3_ZERO_INIT {{0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}}
X
X/* for C only */
X#define GLM_MAT2X3_ZERO GLM_MAT2X3_ZERO_INIT
X
X/*!
X * @brief copy all members of [mat] to [dest]
X *
X * @param[in]  mat  source
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_mat2x3_copy(mat2x3 mat, mat2x3 dest) {
X  dest[0][0] = mat[0][0];
X  dest[0][1] = mat[0][1];
X  dest[0][2] = mat[0][2];
X
X  dest[1][0] = mat[1][0];
X  dest[1][1] = mat[1][1];
X  dest[1][2] = mat[1][2];
X}
X
X/*!
X * @brief make given matrix zero.
X *
X * @param[in, out]  mat  matrix
X */
XCGLM_INLINE
Xvoid
Xglm_mat2x3_zero(mat2x3 mat) {
X  CGLM_ALIGN_MAT mat2x3 t = GLM_MAT2X3_ZERO_INIT;
X  glm_mat2x3_copy(t, mat);
X}
X
X/*!
X * @brief Create mat2x3 matrix from pointer
X *
X * @param[in]  src  pointer to an array of floats
X * @param[out] dest matrix
X */
XCGLM_INLINE
Xvoid
Xglm_mat2x3_make(float * __restrict src, mat2x3 dest) {
X  dest[0][0] = src[0];
X  dest[0][1] = src[1];
X  dest[0][2] = src[2];
X
X  dest[1][0] = src[3];
X  dest[1][1] = src[4];
X  dest[1][2] = src[5];
X}
X
X/*!
X * @brief multiply m1 and m2 to dest
X *
X * @code
X * glm_mat2x3_mul(mat2x3, mat3x2, mat2);
X * @endcode
X *
X * @param[in]  m1   left matrix (mat2x3)
X * @param[in]  m2   right matrix (mat3x2)
X * @param[out] dest destination matrix (mat2)
X */
XCGLM_INLINE
Xvoid
Xglm_mat2x3_mul(mat2x3 m1, mat3x2 m2, mat2 dest) {
X  float a00 = m1[0][0], a01 = m1[0][1], a02 = m1[0][2],
X        a10 = m1[1][0], a11 = m1[1][1], a12 = m1[1][2],
X
X        b00 = m2[0][0], b01 = m2[0][1],
X        b10 = m2[1][0], b11 = m2[1][1],
X        b20 = m2[2][0], b21 = m2[2][1];
X
X  dest[0][0] = a00 * b00 + a01 * b10 + a02 * b20;
X  dest[0][1] = a00 * b01 + a01 * b11 + a02 * b21;
X
X  dest[1][0] = a10 * b00 + a11 * b10 + a12 * b20;
X  dest[1][1] = a10 * b01 + a11 * b11 + a12 * b21;
X}
X
X/*!
X * @brief multiply matrix with column vector and store in dest vector
X *
X * @param[in]  m    matrix (left)
X * @param[in]  v    vector (right, column vector)
X * @param[out] dest result vector
X */
XCGLM_INLINE
Xvoid
Xglm_mat2x3_mulv(mat2x3 m, vec3 v, vec2 dest) {
X  float v0 = v[0], v1 = v[1], v2 = v[2];
X
X  dest[0] = m[0][0] * v0 + m[0][1] * v1 + m[0][2] * v2;
X  dest[1] = m[1][0] * v0 + m[1][1] * v1 + m[1][2] * v2;
X}
X
X/*!
X * @brief transpose matrix and store in dest
X *
X * @param[in]  m     matrix
X * @param[out] dest  result
X */
XCGLM_INLINE
Xvoid
Xglm_mat2x3_transpose(mat2x3 m, mat3x2 dest) {
X  dest[0][0] = m[0][0];  dest[0][1] = m[1][0];
X  dest[1][0] = m[0][1];  dest[1][1] = m[1][1];
X  dest[2][0] = m[0][2];  dest[2][1] = m[1][2];
X}
X
X/*!
X * @brief scale (multiply with scalar) matrix
X *
X * multiply matrix with scalar
X *
X * @param[in, out] m matrix
X * @param[in]    s scalar
X */
XCGLM_INLINE
Xvoid
Xglm_mat2x3_scale(mat2x3 m, float s) {
X  m[0][0] *= s;  m[0][1] *= s;  m[0][2] *= s;
X  m[1][0] *= s;  m[1][1] *= s;  m[1][2] *= s;
X}
X
X#endif
531c556fbad58a11628023f249aff828
echo x - cglm/mat2x4.h
sed 's/^X//' >cglm/mat2x4.h << '088919366582c7ea251bbd07cf3a7f34'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Macros:
X   GLM_MAT2X4_ZERO_INIT
X   GLM_MAT2X4_ZERO
X
X Functions:
X   CGLM_INLINE void glm_mat2x4_copy(mat2x4 mat, mat2x4 dest);
X   CGLM_INLINE void glm_mat2x4_zero(mat2x4 mat);
X   CGLM_INLINE void glm_mat2x4_make(float * __restrict src, mat2x4 dest);
X   CGLM_INLINE void glm_mat2x4_mul(mat2x4 m1, mat4x2 m2, mat2 dest);
X   CGLM_INLINE void glm_mat2x4_mulv(mat2x4 m, vec4 v, vec2 dest);
X   CGLM_INLINE void glm_mat2x4_transpose(mat2x4 m, mat4x2 dest);
X   CGLM_INLINE void glm_mat2x4_scale(mat2x4 m, float s);
X */
X
X#ifndef cglm_mat2x4_h
X#define cglm_mat2x4_h
X
X#include "common.h"
X#include "vec4.h"
X
X#define GLM_MAT2X4_ZERO_INIT {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}
X
X/* for C only */
X#define GLM_MAT2X4_ZERO GLM_MAT2X4_ZERO_INIT
X
X/*!
X * @brief copy all members of [mat] to [dest]
X *
X * @param[in]  mat  source
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_mat2x4_copy(mat2x4 mat, mat2x4 dest) {
X  glm_vec4_ucopy(mat[0], dest[0]);
X  glm_vec4_ucopy(mat[1], dest[1]);
X}
X
X/*!
X * @brief make given matrix zero.
X *
X * @param[in, out]  mat  matrix
X */
XCGLM_INLINE
Xvoid
Xglm_mat2x4_zero(mat2x4 mat) {
X  CGLM_ALIGN_MAT mat2x4 t = GLM_MAT2X4_ZERO_INIT;
X  glm_mat2x4_copy(t, mat);
X}
X
X/*!
X * @brief Create mat2x4 matrix from pointer
X *
X * @param[in]  src  pointer to an array of floats
X * @param[out] dest matrix
X */
XCGLM_INLINE
Xvoid
Xglm_mat2x4_make(float * __restrict src, mat2x4 dest) {
X  dest[0][0] = src[0];
X  dest[0][1] = src[1];
X  dest[0][2] = src[2];
X  dest[0][3] = src[3];
X
X  dest[1][0] = src[4];
X  dest[1][1] = src[5];
X  dest[1][2] = src[6];
X  dest[1][3] = src[7];
X}
X
X/*!
X * @brief multiply m1 and m2 to dest
X *
X * @code
X * glm_mat2x4_mul(mat2x4, mat4x2, mat2);
X * @endcode
X *
X * @param[in]  m1   left matrix (mat2x4)
X * @param[in]  m2   right matrix (mat4x2)
X * @param[out] dest destination matrix (mat2)
X */
XCGLM_INLINE
Xvoid
Xglm_mat2x4_mul(mat2x4 m1, mat4x2 m2, mat2 dest) {
X  float a00 = m1[0][0], a01 = m1[0][1], a02 = m1[0][2], a03 = m1[0][3],
X        a10 = m1[1][0], a11 = m1[1][1], a12 = m1[1][2], a13 = m1[1][3],
X
X        b00 = m2[0][0], b01 = m2[0][1],
X        b10 = m2[1][0], b11 = m2[1][1],
X        b20 = m2[2][0], b21 = m2[2][1],
X        b30 = m2[3][0], b31 = m2[3][1];
X
X  dest[0][0] = a00 * b00 + a01 * b10 + a02 * b20 + a03 * b30;
X  dest[0][1] = a00 * b01 + a01 * b11 + a02 * b21 + a03 * b31;
X
X  dest[1][0] = a10 * b00 + a11 * b10 + a12 * b20 + a13 * b30;
X  dest[1][1] = a10 * b01 + a11 * b11 + a12 * b21 + a13 * b31;
X}
X
X/*!
X * @brief multiply matrix with column vector and store in dest vector
X *
X * @param[in]  m    matrix (left)
X * @param[in]  v    vector (right, column vector)
X * @param[out] dest result vector
X */
XCGLM_INLINE
Xvoid
Xglm_mat2x4_mulv(mat2x4 m, vec4 v, vec2 dest) {
X  float v0 = v[0], v1 = v[1], v2 = v[2], v3 = v[3];
X
X  dest[0] = m[0][0] * v0 + m[0][1] * v1 + m[0][2] * v2 + m[0][3] * v3;
X  dest[1] = m[1][0] * v0 + m[1][1] * v1 + m[1][2] * v2 + m[1][3] * v3;
X}
X
X/*!
X * @brief transpose matrix and store in dest
X *
X * @param[in]  m     matrix
X * @param[out] dest  result
X */
XCGLM_INLINE
Xvoid
Xglm_mat2x4_transpose(mat2x4 m, mat4x2 dest) {
X  dest[0][0] = m[0][0];  dest[0][1] = m[1][0];
X  dest[1][0] = m[0][1];  dest[1][1] = m[1][1];
X  dest[2][0] = m[0][2];  dest[2][1] = m[1][2];
X  dest[3][0] = m[0][3];  dest[3][1] = m[1][3];
X}
X
X/*!
X * @brief scale (multiply with scalar) matrix
X *
X * multiply matrix with scalar
X *
X * @param[in, out] m matrix
X * @param[in]    s scalar
X */
XCGLM_INLINE
Xvoid
Xglm_mat2x4_scale(mat2x4 m, float s) {
X  m[0][0] *= s;  m[0][1] *= s;  m[0][2] *= s;  m[0][3] *= s;
X  m[1][0] *= s;  m[1][1] *= s;  m[1][2] *= s;  m[1][3] *= s;
X}
X
X#endif
088919366582c7ea251bbd07cf3a7f34
echo x - cglm/affine-pre.h
sed 's/^X//' >cglm/affine-pre.h << 'ccd4aa6eaab01c18184d177cc3d96133'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_affine_pre_h
X#define cglm_affine_pre_h
X
X/*
X Functions:
X   CGLM_INLINE void glm_translate_to(mat4 m, vec3 v, mat4 dest);
X   CGLM_INLINE void glm_translate(mat4 m, vec3 v);
X   CGLM_INLINE void glm_translate_x(mat4 m, float to);
X   CGLM_INLINE void glm_translate_y(mat4 m, float to);
X   CGLM_INLINE void glm_translate_z(mat4 m, float to);
X   CGLM_INLINE void glm_rotate_x(mat4 m, float angle, mat4 dest);
X   CGLM_INLINE void glm_rotate_y(mat4 m, float angle, mat4 dest);
X   CGLM_INLINE void glm_rotate_z(mat4 m, float angle, mat4 dest);
X   CGLM_INLINE void glm_rotate(mat4 m, float angle, vec3 axis);
X   CGLM_INLINE void glm_rotate_at(mat4 m, vec3 pivot, float angle, vec3 axis);
X   CGLM_INLINE void glm_rotate_atm(mat4 m, vec3 pivot, float angle, vec3 axis);
X   CGLM_INLINE void glm_spin(mat4 m, float angle, vec3 axis);
X */
X
X#include "common.h"
X#include "util.h"
X#include "vec3.h"
X#include "vec4.h"
X#include "mat4.h"
X#include "affine-mat.h"
X
X/*!
X * @brief translate existing transform matrix by v vector
X *        and stores result in same matrix
X *
X * @param[in, out]  m  affine transfrom
X * @param[in]       v  translate vector [x, y, z]
X */
XCGLM_INLINE
Xvoid
Xglm_translate(mat4 m, vec3 v) {
X#if defined(CGLM_SIMD)
X  glmm_128 m0, m1, m2, m3;
X
X  m0 = glmm_load(m[0]);
X  m1 = glmm_load(m[1]);
X  m2 = glmm_load(m[2]);
X  m3 = glmm_load(m[3]);
X
X  glmm_store(m[3],
X             glmm_fmadd(m0, glmm_set1(v[0]),
X                        glmm_fmadd(m1, glmm_set1(v[1]),
X                                   glmm_fmadd(m2, glmm_set1(v[2]), m3))));
X#else
X  glm_vec4_muladds(m[0], v[0], m[3]);
X  glm_vec4_muladds(m[1], v[1], m[3]);
X  glm_vec4_muladds(m[2], v[2], m[3]);
X#endif
X}
X
X/*!
X * @brief translate existing transform matrix by v vector
X *        and store result in dest
X *
X * source matrix will remain same
X *
X * @param[in]  m    affine transfrom
X * @param[in]  v    translate vector [x, y, z]
X * @param[out] dest translated matrix
X */
XCGLM_INLINE
Xvoid
Xglm_translate_to(mat4 m, vec3 v, mat4 dest) {
X  glm_mat4_copy(m, dest);
X  glm_translate(dest, v);
X}
X
X/*!
X * @brief translate existing transform matrix by x factor
X *
X * @param[in, out]  m  affine transfrom
X * @param[in]       x  x factor
X */
XCGLM_INLINE
Xvoid
Xglm_translate_x(mat4 m, float x) {
X#if defined(CGLM_SIMD)
X  glmm_store(m[3], glmm_fmadd(glmm_load(m[0]), glmm_set1(x), glmm_load(m[3])));
X#else
X  vec4 v1;
X  glm_vec4_scale(m[0], x, v1);
X  glm_vec4_add(v1, m[3], m[3]);
X#endif
X}
X
X/*!
X * @brief translate existing transform matrix by y factor
X *
X * @param[in, out]  m  affine transfrom
X * @param[in]       y  y factor
X */
XCGLM_INLINE
Xvoid
Xglm_translate_y(mat4 m, float y) {
X#if defined(CGLM_SIMD)
X  glmm_store(m[3], glmm_fmadd(glmm_load(m[1]), glmm_set1(y), glmm_load(m[3])));
X#else
X  vec4 v1;
X  glm_vec4_scale(m[1], y, v1);
X  glm_vec4_add(v1, m[3], m[3]);
X#endif
X}
X
X/*!
X * @brief translate existing transform matrix by z factor
X *
X * @param[in, out]  m  affine transfrom
X * @param[in]       z  z factor
X */
XCGLM_INLINE
Xvoid
Xglm_translate_z(mat4 m, float z) {
X#if defined(CGLM_SIMD)
X  glmm_store(m[3], glmm_fmadd(glmm_load(m[2]), glmm_set1(z), glmm_load(m[3])));
X#else
X  vec4 v1;
X  glm_vec4_scale(m[2], z, v1);
X  glm_vec4_add(v1, m[3], m[3]);
X#endif
X}
X
X/*!
X * @brief rotate existing transform matrix around X axis by angle
X *        and store result in dest
X *
X * @param[in]   m      affine transfrom
X * @param[in]   angle  angle (radians)
X * @param[out]  dest   rotated matrix
X */
XCGLM_INLINE
Xvoid
Xglm_rotate_x(mat4 m, float angle, mat4 dest) {
X  CGLM_ALIGN_MAT mat4 t = GLM_MAT4_IDENTITY_INIT;
X  float c, s;
X
X  c = cosf(angle);
X  s = sinf(angle);
X
X  t[1][1] =  c;
X  t[1][2] =  s;
X  t[2][1] = -s;
X  t[2][2] =  c;
X
X  glm_mul_rot(m, t, dest);
X}
X
X/*!
X * @brief rotate existing transform matrix around Y axis by angle
X *        and store result in dest
X *
X * @param[in]   m      affine transfrom
X * @param[in]   angle  angle (radians)
X * @param[out]  dest   rotated matrix
X */
XCGLM_INLINE
Xvoid
Xglm_rotate_y(mat4 m, float angle, mat4 dest) {
X  CGLM_ALIGN_MAT mat4 t = GLM_MAT4_IDENTITY_INIT;
X  float c, s;
X
X  c = cosf(angle);
X  s = sinf(angle);
X
X  t[0][0] =  c;
X  t[0][2] = -s;
X  t[2][0] =  s;
X  t[2][2] =  c;
X
X  glm_mul_rot(m, t, dest);
X}
X
X/*!
X * @brief rotate existing transform matrix around Z axis by angle
X *        and store result in dest
X *
X * @param[in]   m      affine transfrom
X * @param[in]   angle  angle (radians)
X * @param[out]  dest   rotated matrix
X */
XCGLM_INLINE
Xvoid
Xglm_rotate_z(mat4 m, float angle, mat4 dest) {
X  CGLM_ALIGN_MAT mat4 t = GLM_MAT4_IDENTITY_INIT;
X  float c, s;
X
X  c = cosf(angle);
X  s = sinf(angle);
X
X  t[0][0] =  c;
X  t[0][1] =  s;
X  t[1][0] = -s;
X  t[1][1] =  c;
X
X  glm_mul_rot(m, t, dest);
X}
X
X/*!
X * @brief rotate existing transform matrix around given axis by angle
X *
X * @param[in, out]  m      affine transfrom
X * @param[in]       angle  angle (radians)
X * @param[in]       axis   axis
X */
XCGLM_INLINE
Xvoid
Xglm_rotate(mat4 m, float angle, vec3 axis) {
X  CGLM_ALIGN_MAT mat4 rot;
X  glm_rotate_make(rot, angle, axis);
X  glm_mul_rot(m, rot, m);
X}
X
X/*!
X * @brief rotate existing transform
X *        around given axis by angle at given pivot point (rotation center)
X *
X * @param[in, out]  m      affine transfrom
X * @param[in]       pivot  rotation center
X * @param[in]       angle  angle (radians)
X * @param[in]       axis   axis
X */
XCGLM_INLINE
Xvoid
Xglm_rotate_at(mat4 m, vec3 pivot, float angle, vec3 axis) {
X  CGLM_ALIGN(8) vec3 pivotInv;
X
X  glm_vec3_negate_to(pivot, pivotInv);
X
X  glm_translate(m, pivot);
X  glm_rotate(m, angle, axis);
X  glm_translate(m, pivotInv);
X}
X
X/*!
X * @brief creates NEW rotation matrix by angle and axis at given point
X *
X * this creates rotation matrix, it assumes you don't have a matrix
X *
X * this should work faster than glm_rotate_at because it reduces
X * one glm_translate.
X *
X * @param[out] m      affine transfrom
X * @param[in]  pivot  rotation center
X * @param[in]  angle  angle (radians)
X * @param[in]  axis   axis
X */
XCGLM_INLINE
Xvoid
Xglm_rotate_atm(mat4 m, vec3 pivot, float angle, vec3 axis) {
X  CGLM_ALIGN(8) vec3 pivotInv;
X
X  glm_vec3_negate_to(pivot, pivotInv);
X
X  glm_translate_make(m, pivot);
X  glm_rotate(m, angle, axis);
X  glm_translate(m, pivotInv);
X}
X
X/*!
X * @brief rotate existing transform matrix around given axis by angle around self (doesn't affected by position)
X *
X * @param[in, out]  m      affine transfrom
X * @param[in]       angle  angle (radians)
X * @param[in]       axis   axis
X */
XCGLM_INLINE
Xvoid
Xglm_spin(mat4 m, float angle, vec3 axis) {
X  CGLM_ALIGN_MAT mat4 rot;
X  glm_rotate_atm(rot, m[3], angle, axis);
X  glm_mat4_mul(m, rot, m);
X}
X
X#endif /* cglm_affine_pre_h */
ccd4aa6eaab01c18184d177cc3d96133
echo x - cglm/affine-post.h
sed 's/^X//' >cglm/affine-post.h << '839f8211b25146f6bd31ae1161d70d2c'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_affine_post_h
X#define cglm_affine_post_h
X
X/*
X Functions:
X   CGLM_INLINE void glm_translated_to(mat4 m, vec3 v, mat4 dest);
X   CGLM_INLINE void glm_translated(mat4 m, vec3 v);
X   CGLM_INLINE void glm_translated_x(mat4 m, float to);
X   CGLM_INLINE void glm_translated_y(mat4 m, float to);
X   CGLM_INLINE void glm_translated_z(mat4 m, float to);
X   CGLM_INLINE void glm_rotated_x(mat4 m, float angle, mat4 dest);
X   CGLM_INLINE void glm_rotated_y(mat4 m, float angle, mat4 dest);
X   CGLM_INLINE void glm_rotated_z(mat4 m, float angle, mat4 dest);
X   CGLM_INLINE void glm_rotated(mat4 m, float angle, vec3 axis);
X   CGLM_INLINE void glm_rotated_at(mat4 m, vec3 pivot, float angle, vec3 axis);
X   CGLM_INLINE void glm_spinned(mat4 m, float angle, vec3 axis);
X */
X
X#include "common.h"
X#include "util.h"
X#include "vec3.h"
X#include "vec4.h"
X#include "mat4.h"
X#include "affine-mat.h"
X
X/*!
X * @brief translate existing transform matrix by v vector
X *        and stores result in same matrix
X *
X *  this is POST transform, applies to existing transform as last transfrom
X *
X * @param[in, out]  m  affine transfrom
X * @param[in]       v  translate vector [x, y, z]
X */
XCGLM_INLINE
Xvoid
Xglm_translated(mat4 m, vec3 v) {
X  glm_vec3_add(m[3], v, m[3]);
X}
X
X/*!
X * @brief translate existing transform matrix by v vector
X *        and store result in dest
X *
X * source matrix will remain same
X *
X *  this is POST transform, applies to existing transform as last transfrom
X *
X * @param[in]  m    affine transfrom
X * @param[in]  v    translate vector [x, y, z]
X * @param[out] dest translated matrix
X */
XCGLM_INLINE
Xvoid
Xglm_translated_to(mat4 m, vec3 v, mat4 dest) {
X  glm_mat4_copy(m, dest);
X  glm_translated(dest, v);
X}
X
X/*!
X * @brief translate existing transform matrix by x factor
X *
X *  this is POST transform, applies to existing transform as last transfrom
X *
X * @param[in, out]  m  affine transfrom
X * @param[in]       x  x factor
X */
XCGLM_INLINE
Xvoid
Xglm_translated_x(mat4 m, float x) {
X  m[3][0] += x;
X}
X
X/*!
X * @brief translate existing transform matrix by y factor
X *
X *  this is POST transform, applies to existing transform as last transfrom
X *
X * @param[in, out]  m  affine transfrom
X * @param[in]       y  y factor
X */
XCGLM_INLINE
Xvoid
Xglm_translated_y(mat4 m, float y) {
X  m[3][1] += y;
X}
X
X/*!
X * @brief translate existing transform matrix by z factor
X *
X *  this is POST transform, applies to existing transform as last transfrom
X *
X * @param[in, out]  m  affine transfrom
X * @param[in]       z  z factor
X */
XCGLM_INLINE
Xvoid
Xglm_translated_z(mat4 m, float z) {
X  m[3][2] += z;
X}
X
X/*!
X * @brief rotate existing transform matrix around X axis by angle
X *        and store result in dest
X *
X *  this is POST transform, applies to existing transform as last transfrom
X *
X * @param[in]   m      affine transfrom
X * @param[in]   angle  angle (radians)
X * @param[out]  dest   rotated matrix
X */
XCGLM_INLINE
Xvoid
Xglm_rotated_x(mat4 m, float angle, mat4 dest) {
X  CGLM_ALIGN_MAT mat4 t = GLM_MAT4_IDENTITY_INIT;
X  float c, s;
X
X  c = cosf(angle);
X  s = sinf(angle);
X
X  t[1][1] =  c;
X  t[1][2] =  s;
X  t[2][1] = -s;
X  t[2][2] =  c;
X
X  glm_mul_rot(t, m, dest);
X}
X
X/*!
X * @brief rotate existing transform matrix around Y axis by angle
X *        and store result in dest
X *
X *  this is POST transform, applies to existing transform as last transfrom
X *
X * @param[in]   m      affine transfrom
X * @param[in]   angle  angle (radians)
X * @param[out]  dest   rotated matrix
X */
XCGLM_INLINE
Xvoid
Xglm_rotated_y(mat4 m, float angle, mat4 dest) {
X  CGLM_ALIGN_MAT mat4 t = GLM_MAT4_IDENTITY_INIT;
X  float c, s;
X
X  c = cosf(angle);
X  s = sinf(angle);
X
X  t[0][0] =  c;
X  t[0][2] = -s;
X  t[2][0] =  s;
X  t[2][2] =  c;
X
X  glm_mul_rot(t, m, dest);
X}
X
X/*!
X * @brief rotate existing transform matrix around Z axis by angle
X *        and store result in dest
X *
X *  this is POST transform, applies to existing transform as last transfrom
X *
X * @param[in]   m      affine transfrom
X * @param[in]   angle  angle (radians)
X * @param[out]  dest   rotated matrix
X */
XCGLM_INLINE
Xvoid
Xglm_rotated_z(mat4 m, float angle, mat4 dest) {
X  CGLM_ALIGN_MAT mat4 t = GLM_MAT4_IDENTITY_INIT;
X  float c, s;
X
X  c = cosf(angle);
X  s = sinf(angle);
X
X  t[0][0] =  c;
X  t[0][1] =  s;
X  t[1][0] = -s;
X  t[1][1] =  c;
X
X  glm_mul_rot(t, m, dest);
X}
X
X/*!
X * @brief rotate existing transform matrix around given axis by angle
X *
X *  this is POST transform, applies to existing transform as last transfrom
X *
X * @param[in, out]  m      affine transfrom
X * @param[in]       angle  angle (radians)
X * @param[in]       axis   axis
X */
XCGLM_INLINE
Xvoid
Xglm_rotated(mat4 m, float angle, vec3 axis) {
X  CGLM_ALIGN_MAT mat4 rot;
X  glm_rotate_make(rot, angle, axis);
X  glm_mul_rot(rot, m, m);
X}
X
X/*!
X * @brief rotate existing transform
X *        around given axis by angle at given pivot point (rotation center)
X *
X *  this is POST transform, applies to existing transform as last transfrom
X *
X * @param[in, out]  m      affine transfrom
X * @param[in]       pivot  rotation center
X * @param[in]       angle  angle (radians)
X * @param[in]       axis   axis
X */
XCGLM_INLINE
Xvoid
Xglm_rotated_at(mat4 m, vec3 pivot, float angle, vec3 axis) {
X  CGLM_ALIGN(8) vec3 pivotInv;
X
X  glm_vec3_negate_to(pivot, pivotInv);
X
X  glm_translated(m, pivot);
X  glm_rotated(m, angle, axis);
X  glm_translated(m, pivotInv);
X}
X
X/*!
X * @brief rotate existing transform matrix around given axis by angle around self (doesn't affected by position)
X *
X *  this is POST transform, applies to existing transform as last transfrom
X *
X * @param[in, out]  m      affine transfrom
X * @param[in]       angle  angle (radians)
X * @param[in]       axis   axis
X */
XCGLM_INLINE
Xvoid
Xglm_spinned(mat4 m, float angle, vec3 axis) {
X  CGLM_ALIGN_MAT mat4 rot;
X  glm_rotate_atm(rot, m[3], angle, axis);
X  glm_mat4_mul(rot, m, m);
X}
X
X#endif /* cglm_affine_post_h */
839f8211b25146f6bd31ae1161d70d2c
echo x - cglm/affine.h
sed 's/^X//' >cglm/affine.h << '43b5489fcd1d208f21cb3a378edfce43'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Functions:
X   CGLM_INLINE void glm_translate_to(mat4 m, vec3 v, mat4 dest);
X   CGLM_INLINE void glm_translate(mat4 m, vec3 v);
X   CGLM_INLINE void glm_translate_x(mat4 m, float to);
X   CGLM_INLINE void glm_translate_y(mat4 m, float to);
X   CGLM_INLINE void glm_translate_z(mat4 m, float to);
X   CGLM_INLINE void glm_translate_make(mat4 m, vec3 v);
X   CGLM_INLINE void glm_scale_to(mat4 m, vec3 v, mat4 dest);
X   CGLM_INLINE void glm_scale_make(mat4 m, vec3 v);
X   CGLM_INLINE void glm_scale(mat4 m, vec3 v);
X   CGLM_INLINE void glm_scale_uni(mat4 m, float s);
X   CGLM_INLINE void glm_rotate_x(mat4 m, float angle, mat4 dest);
X   CGLM_INLINE void glm_rotate_y(mat4 m, float angle, mat4 dest);
X   CGLM_INLINE void glm_rotate_z(mat4 m, float angle, mat4 dest);
X   CGLM_INLINE void glm_rotate_make(mat4 m, float angle, vec3 axis);
X   CGLM_INLINE void glm_rotate(mat4 m, float angle, vec3 axis);
X   CGLM_INLINE void glm_rotate_at(mat4 m, vec3 pivot, float angle, vec3 axis);
X   CGLM_INLINE void glm_rotate_atm(mat4 m, vec3 pivot, float angle, vec3 axis);
X   CGLM_INLINE void glm_spin(mat4 m, float angle, vec3 axis);
X   CGLM_INLINE void glm_decompose_scalev(mat4 m, vec3 s);
X   CGLM_INLINE bool glm_uniscaled(mat4 m);
X   CGLM_INLINE void glm_decompose_rs(mat4 m, mat4 r, vec3 s);
X   CGLM_INLINE void glm_decompose(mat4 m, vec4 t, mat4 r, vec3 s);
X */
X
X#ifndef cglm_affine_h
X#define cglm_affine_h
X
X#include "common.h"
X#include "util.h"
X#include "vec3.h"
X#include "vec4.h"
X#include "mat4.h"
X#include "affine-mat.h"
X
X/*!
X * @brief creates NEW translate transform matrix by v vector
X *
X * @param[out]  m  affine transfrom
X * @param[in]   v  translate vector [x, y, z]
X */
XCGLM_INLINE
Xvoid
Xglm_translate_make(mat4 m, vec3 v) {
X  glm_mat4_identity(m);
X  glm_vec3_copy(v, m[3]);
X}
X
X/*!
X * @brief scale existing transform matrix by v vector
X *        and store result in dest
X *
X * @param[in]  m    affine transfrom
X * @param[in]  v    scale vector [x, y, z]
X * @param[out] dest scaled matrix
X */
XCGLM_INLINE
Xvoid
Xglm_scale_to(mat4 m, vec3 v, mat4 dest) {
X  glm_vec4_scale(m[0], v[0], dest[0]);
X  glm_vec4_scale(m[1], v[1], dest[1]);
X  glm_vec4_scale(m[2], v[2], dest[2]);
X
X  glm_vec4_copy(m[3], dest[3]);
X}
X
X/*!
X * @brief creates NEW scale matrix by v vector
X *
X * @param[out]  m  affine transfrom
X * @param[in]   v  scale vector [x, y, z]
X */
XCGLM_INLINE
Xvoid
Xglm_scale_make(mat4 m, vec3 v) {
X  glm_mat4_identity(m);
X  m[0][0] = v[0];
X  m[1][1] = v[1];
X  m[2][2] = v[2];
X}
X
X/*!
X * @brief scales existing transform matrix by v vector
X *        and stores result in same matrix
X *
X * @param[in, out]  m  affine transfrom
X * @param[in]       v  scale vector [x, y, z]
X */
XCGLM_INLINE
Xvoid
Xglm_scale(mat4 m, vec3 v) {
X  glm_scale_to(m, v, m);
X}
X
X/*!
X * @brief applies uniform scale to existing transform matrix v = [s, s, s]
X *        and stores result in same matrix
X *
X * @param[in, out]  m  affine transfrom
X * @param[in]       s  scale factor
X */
XCGLM_INLINE
Xvoid
Xglm_scale_uni(mat4 m, float s) {
X  CGLM_ALIGN(8) vec3 v = { s, s, s };
X  glm_scale_to(m, v, m);
X}
X
X/*!
X * @brief creates NEW rotation matrix by angle and axis
X *
X * axis will be normalized so you don't need to normalize it
X *
X * @param[out] m     affine transfrom
X * @param[in]  angle angle (radians)
X * @param[in]  axis  axis
X */
XCGLM_INLINE
Xvoid
Xglm_rotate_make(mat4 m, float angle, vec3 axis) {
X  CGLM_ALIGN(8) vec3 axisn, v, vs;
X  float c;
X
X  c = cosf(angle);
X
X  glm_vec3_normalize_to(axis, axisn);
X  glm_vec3_scale(axisn, 1.0f - c, v);
X  glm_vec3_scale(axisn, sinf(angle), vs);
X
X  glm_vec3_scale(axisn, v[0], m[0]);
X  glm_vec3_scale(axisn, v[1], m[1]);
X  glm_vec3_scale(axisn, v[2], m[2]);
X
X  m[0][0] += c;       m[1][0] -= vs[2];   m[2][0] += vs[1];
X  m[0][1] += vs[2];   m[1][1] += c;       m[2][1] -= vs[0];
X  m[0][2] -= vs[1];   m[1][2] += vs[0];   m[2][2] += c;
X
X  m[0][3] = m[1][3] = m[2][3] = m[3][0] = m[3][1] = m[3][2] = 0.0f;
X  m[3][3] = 1.0f;
X}
X
X/*!
X * @brief decompose scale vector
X *
X * @param[in]  m  affine transform
X * @param[out] s  scale vector (Sx, Sy, Sz)
X */
XCGLM_INLINE
Xvoid
Xglm_decompose_scalev(mat4 m, vec3 s) {
X  s[0] = glm_vec3_norm(m[0]);
X  s[1] = glm_vec3_norm(m[1]);
X  s[2] = glm_vec3_norm(m[2]);
X}
X
X/*!
X * @brief returns true if matrix is uniform scaled. This is helpful for
X *        creating normal matrix.
X *
X * @param[in] m m
X *
X * @return boolean
X */
XCGLM_INLINE
Xbool
Xglm_uniscaled(mat4 m) {
X  CGLM_ALIGN(8) vec3 s;
X  glm_decompose_scalev(m, s);
X  return glm_vec3_eq_all(s);
X}
X
X/*!
X * @brief decompose rotation matrix (mat4) and scale vector [Sx, Sy, Sz]
X *        DON'T pass projected matrix here
X *
X * @param[in]  m affine transform
X * @param[out] r rotation matrix
X * @param[out] s scale matrix
X */
XCGLM_INLINE
Xvoid
Xglm_decompose_rs(mat4 m, mat4 r, vec3 s) {
X  CGLM_ALIGN(16) vec4 t = {0.0f, 0.0f, 0.0f, 1.0f};
X  CGLM_ALIGN(8)  vec3 v;
X
X  glm_vec4_copy(m[0], r[0]);
X  glm_vec4_copy(m[1], r[1]);
X  glm_vec4_copy(m[2], r[2]);
X  glm_vec4_copy(t,    r[3]);
X
X  s[0] = glm_vec3_norm(m[0]);
X  s[1] = glm_vec3_norm(m[1]);
X  s[2] = glm_vec3_norm(m[2]);
X
X  glm_vec4_scale(r[0], 1.0f/s[0], r[0]);
X  glm_vec4_scale(r[1], 1.0f/s[1], r[1]);
X  glm_vec4_scale(r[2], 1.0f/s[2], r[2]);
X
X  /* Note from Apple Open Source (assume that the matrix is orthonormal):
X     check for a coordinate system flip.  If the determinant
X     is -1, then negate the matrix and the scaling factors. */
X  glm_vec3_cross(m[0], m[1], v);
X  if (glm_vec3_dot(v, m[2]) < 0.0f) {
X    glm_vec4_negate(r[0]);
X    glm_vec4_negate(r[1]);
X    glm_vec4_negate(r[2]);
X    glm_vec3_negate(s);
X  }
X}
X
X/*!
X * @brief decompose affine transform, TODO: extract shear factors.
X *        DON'T pass projected matrix here
X *
X * @param[in]  m affine transfrom
X * @param[out] t translation vector
X * @param[out] r rotation matrix (mat4)
X * @param[out] s scaling vector [X, Y, Z]
X */
XCGLM_INLINE
Xvoid
Xglm_decompose(mat4 m, vec4 t, mat4 r, vec3 s) {
X  glm_vec4_copy(m[3], t);
X  glm_decompose_rs(m, r, s);
X}
X
X#include "affine-pre.h"
X#include "affine-post.h"
X
X#endif /* cglm_affine_h */
43b5489fcd1d208f21cb3a378edfce43
echo x - cglm/affine-mat.h
sed 's/^X//' >cglm/affine-mat.h << 'cf62f4daa8942dd96e24f485e099bd81'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Functions:
X   CGLM_INLINE void glm_mul(mat4 m1, mat4 m2, mat4 dest);
X   CGLM_INLINE void glm_mul_rot(mat4 m1, mat4 m2, mat4 dest);
X   CGLM_INLINE void glm_inv_tr(mat4 mat);
X */
X
X#ifndef cglm_affine_mat_h
X#define cglm_affine_mat_h
X
X#include "common.h"
X#include "mat4.h"
X#include "mat3.h"
X
X#ifdef CGLM_SSE_FP
X#  include "simd/sse2/affine.h"
X#endif
X
X#ifdef CGLM_AVX_FP
X#  include "simd/avx/affine.h"
X#endif
X
X#ifdef CGLM_NEON_FP
X#  include "simd/neon/affine.h"
X#endif
X
X#ifdef CGLM_SIMD_WASM
X#  include "simd/wasm/affine.h"
X#endif
X
X/*!
X * @brief this is similar to glm_mat4_mul but specialized to affine transform
X *
X * Matrix format should be:
X *   R  R  R  X
X *   R  R  R  Y
X *   R  R  R  Z
X *   0  0  0  W
X *
X * this reduces some multiplications. It should be faster than mat4_mul.
X * if you are not sure about matrix format then DON'T use this! use mat4_mul
X *
X * @param[in]   m1    affine matrix 1
X * @param[in]   m2    affine matrix 2
X * @param[out]  dest  result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_mul(mat4 m1, mat4 m2, mat4 dest) {
X#if defined(__wasm__) && defined(__wasm_simd128__)
X  glm_mul_wasm(m1, m2, dest);
X#elif defined(__AVX__)
X  glm_mul_avx(m1, m2, dest);
X#elif defined( __SSE__ ) || defined( __SSE2__ )
X  glm_mul_sse2(m1, m2, dest);
X#elif defined(CGLM_NEON_FP)
X  glm_mul_neon(m1, m2, dest);
X#else
X  float a00 = m1[0][0], a01 = m1[0][1], a02 = m1[0][2], a03 = m1[0][3],
X        a10 = m1[1][0], a11 = m1[1][1], a12 = m1[1][2], a13 = m1[1][3],
X        a20 = m1[2][0], a21 = m1[2][1], a22 = m1[2][2], a23 = m1[2][3],
X        a30 = m1[3][0], a31 = m1[3][1], a32 = m1[3][2], a33 = m1[3][3],
X
X        b00 = m2[0][0], b01 = m2[0][1], b02 = m2[0][2],
X        b10 = m2[1][0], b11 = m2[1][1], b12 = m2[1][2],
X        b20 = m2[2][0], b21 = m2[2][1], b22 = m2[2][2],
X        b30 = m2[3][0], b31 = m2[3][1], b32 = m2[3][2], b33 = m2[3][3];
X
X  dest[0][0] = a00 * b00 + a10 * b01 + a20 * b02;
X  dest[0][1] = a01 * b00 + a11 * b01 + a21 * b02;
X  dest[0][2] = a02 * b00 + a12 * b01 + a22 * b02;
X  dest[0][3] = a03 * b00 + a13 * b01 + a23 * b02;
X
X  dest[1][0] = a00 * b10 + a10 * b11 + a20 * b12;
X  dest[1][1] = a01 * b10 + a11 * b11 + a21 * b12;
X  dest[1][2] = a02 * b10 + a12 * b11 + a22 * b12;
X  dest[1][3] = a03 * b10 + a13 * b11 + a23 * b12;
X
X  dest[2][0] = a00 * b20 + a10 * b21 + a20 * b22;
X  dest[2][1] = a01 * b20 + a11 * b21 + a21 * b22;
X  dest[2][2] = a02 * b20 + a12 * b21 + a22 * b22;
X  dest[2][3] = a03 * b20 + a13 * b21 + a23 * b22;
X
X  dest[3][0] = a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33;
X  dest[3][1] = a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33;
X  dest[3][2] = a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33;
X  dest[3][3] = a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33;
X#endif
X}
X
X/*!
X * @brief this is similar to glm_mat4_mul but specialized to affine transform
X *
X * Right Matrix format should be:
X *   R  R  R  0
X *   R  R  R  0
X *   R  R  R  0
X *   0  0  0  1
X *
X * this reduces some multiplications. It should be faster than mat4_mul.
X * if you are not sure about matrix format then DON'T use this! use mat4_mul
X *
X * @param[in]   m1    affine matrix 1
X * @param[in]   m2    affine matrix 2
X * @param[out]  dest  result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_mul_rot(mat4 m1, mat4 m2, mat4 dest) {
X#if defined(__wasm__) && defined(__wasm_simd128__)
X  glm_mul_rot_wasm(m1, m2, dest);
X#elif defined( __SSE__ ) || defined( __SSE2__ )
X  glm_mul_rot_sse2(m1, m2, dest);
X#elif defined(CGLM_NEON_FP)
X  glm_mul_rot_neon(m1, m2, dest);
X#else
X  float a00 = m1[0][0], a01 = m1[0][1], a02 = m1[0][2], a03 = m1[0][3],
X        a10 = m1[1][0], a11 = m1[1][1], a12 = m1[1][2], a13 = m1[1][3],
X        a20 = m1[2][0], a21 = m1[2][1], a22 = m1[2][2], a23 = m1[2][3],
X        a30 = m1[3][0], a31 = m1[3][1], a32 = m1[3][2], a33 = m1[3][3],
X
X        b00 = m2[0][0], b01 = m2[0][1], b02 = m2[0][2],
X        b10 = m2[1][0], b11 = m2[1][1], b12 = m2[1][2],
X        b20 = m2[2][0], b21 = m2[2][1], b22 = m2[2][2];
X
X  dest[0][0] = a00 * b00 + a10 * b01 + a20 * b02;
X  dest[0][1] = a01 * b00 + a11 * b01 + a21 * b02;
X  dest[0][2] = a02 * b00 + a12 * b01 + a22 * b02;
X  dest[0][3] = a03 * b00 + a13 * b01 + a23 * b02;
X
X  dest[1][0] = a00 * b10 + a10 * b11 + a20 * b12;
X  dest[1][1] = a01 * b10 + a11 * b11 + a21 * b12;
X  dest[1][2] = a02 * b10 + a12 * b11 + a22 * b12;
X  dest[1][3] = a03 * b10 + a13 * b11 + a23 * b12;
X
X  dest[2][0] = a00 * b20 + a10 * b21 + a20 * b22;
X  dest[2][1] = a01 * b20 + a11 * b21 + a21 * b22;
X  dest[2][2] = a02 * b20 + a12 * b21 + a22 * b22;
X  dest[2][3] = a03 * b20 + a13 * b21 + a23 * b22;
X
X  dest[3][0] = a30;
X  dest[3][1] = a31;
X  dest[3][2] = a32;
X  dest[3][3] = a33;
X#endif
X}
X
X/*!
X * @brief inverse orthonormal rotation + translation matrix (ridig-body)
X *
X * @code
X * X = | R  T |   X' = | R' -R'T |
X *     | 0  1 |        | 0     1 |
X * @endcode
X *
X * @param[in,out]  mat  matrix
X */
XCGLM_INLINE
Xvoid
Xglm_inv_tr(mat4 mat) {
X#if defined(__wasm__) && defined(__wasm_simd128__)
X  glm_inv_tr_wasm(mat);
X#elif defined( __SSE__ ) || defined( __SSE2__ )
X  glm_inv_tr_sse2(mat);
X#elif defined(CGLM_NEON_FP)
X  glm_inv_tr_neon(mat);
X#else
X  CGLM_ALIGN_MAT mat3 r;
X  CGLM_ALIGN(8)  vec3 t;
X
X  /* rotate */
X  glm_mat4_pick3t(mat, r);
X  glm_mat4_ins3(r, mat);
X
X  /* translate */
X  glm_mat3_mulv(r, mat[3], t);
X  glm_vec3_negate(t);
X  glm_vec3_copy(t, mat[3]);
X#endif
X}
X
X#endif /* cglm_affine_mat_h */
cf62f4daa8942dd96e24f485e099bd81
echo x - cglm/vec2.h
sed 's/^X//' >cglm/vec2.h << '4001921be909fdebb392c47ed9d6f0f5'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Macros:
X   GLM_VEC2_ONE_INIT
X   GLM_VEC2_ZERO_INIT
X   GLM_VEC2_ONE
X   GLM_VEC2_ZERO
X
X Functions:
X   CGLM_INLINE void  glm_vec2(float * __restrict v, vec2 dest)
X   CGLM_INLINE void  glm_vec2_copy(vec2 a, vec2 dest)
X   CGLM_INLINE void  glm_vec2_zero(vec2 v)
X   CGLM_INLINE void  glm_vec2_one(vec2 v)
X   CGLM_INLINE float glm_vec2_dot(vec2 a, vec2 b)
X   CGLM_INLINE float glm_vec2_cross(vec2 a, vec2 b)
X   CGLM_INLINE float glm_vec2_norm2(vec2 v)
X   CGLM_INLINE float glm_vec2_norm(vec2 vec)
X   CGLM_INLINE void  glm_vec2_add(vec2 a, vec2 b, vec2 dest)
X   CGLM_INLINE void  glm_vec2_adds(vec2 v, float s, vec2 dest)
X   CGLM_INLINE void  glm_vec2_sub(vec2 a, vec2 b, vec2 dest)
X   CGLM_INLINE void  glm_vec2_subs(vec2 v, float s, vec2 dest)
X   CGLM_INLINE void  glm_vec2_mul(vec2 a, vec2 b, vec2 d)
X   CGLM_INLINE void  glm_vec2_scale(vec2 v, float s, vec2 dest)
X   CGLM_INLINE void  glm_vec2_scale_as(vec2 v, float s, vec2 dest)
X   CGLM_INLINE void  glm_vec2_div(vec2 a, vec2 b, vec2 dest)
X   CGLM_INLINE void  glm_vec2_divs(vec2 v, float s, vec2 dest)
X   CGLM_INLINE void  glm_vec2_addadd(vec2 a, vec2 b, vec2 dest)
X   CGLM_INLINE void  glm_vec2_subadd(vec2 a, vec2 b, vec2 dest)
X   CGLM_INLINE void  glm_vec2_muladd(vec2 a, vec2 b, vec2 dest)
X   CGLM_INLINE void  glm_vec2_muladds(vec2 a, float s, vec2 dest)
X   CGLM_INLINE void  glm_vec2_maxadd(vec2 a, vec2 b, vec2 dest)
X   CGLM_INLINE void  glm_vec2_minadd(vec2 a, vec2 b, vec2 dest)
X   CGLM_INLINE void  glm_vec2_subsub(vec2 a, vec2 b, vec2 dest)
X   CGLM_INLINE void  glm_vec2_addsub(vec2 a, vec2 b, vec2 dest)
X   CGLM_INLINE void  glm_vec2_mulsub(vec2 a, vec2 b, vec2 dest)
X   CGLM_INLINE void  glm_vec2_mulsubs(vec2 a, float s, vec2 dest)
X   CGLM_INLINE void  glm_vec2_maxsub(vec2 a, vec2 b, vec2 dest)
X   CGLM_INLINE void  glm_vec2_minsub(vec2 a, vec2 b, vec2 dest)
X   CGLM_INLINE void  glm_vec2_negate_to(vec2 v, vec2 dest)
X   CGLM_INLINE void  glm_vec2_negate(vec2 v)
X   CGLM_INLINE void  glm_vec2_normalize(vec2 v)
X   CGLM_INLINE void  glm_vec2_normalize_to(vec2 vec, vec2 dest)
X   CGLM_INLINE void  glm_vec2_rotate(vec2 v, float angle, vec2 dest)
X   CGLM_INLINE void  glm_vec2_center(vec2 a, vec2 b, vec2 dest)
X   CGLM_INLINE float glm_vec2_distance2(vec2 a, vec2 b)
X   CGLM_INLINE float glm_vec2_distance(vec2 a, vec2 b)
X   CGLM_INLINE void  glm_vec2_maxv(vec2 v1, vec2 v2, vec2 dest)
X   CGLM_INLINE void  glm_vec2_minv(vec2 v1, vec2 v2, vec2 dest)
X   CGLM_INLINE void  glm_vec2_clamp(vec2 v, float minVal, float maxVal)
X   CGLM_INLINE void  glm_vec2_lerp(vec2 from, vec2 to, float t, vec2 dest)
X   CGLM_INLINE void  glm_vec2_make(float * restrict src, vec2 dest)
X
X */
X
X#ifndef cglm_vec2_h
X#define cglm_vec2_h
X
X#include "common.h"
X#include "util.h"
X#include "vec2-ext.h"
X
X#define GLM_VEC2_ONE_INIT   {1.0f, 1.0f}
X#define GLM_VEC2_ZERO_INIT  {0.0f, 0.0f}
X
X#define GLM_VEC2_ONE  ((vec2)GLM_VEC2_ONE_INIT)
X#define GLM_VEC2_ZERO ((vec2)GLM_VEC2_ZERO_INIT)
X
X/*!
X * @brief init vec2 using another vector
X *
X * @param[in]  v    a vector
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec2(float * __restrict v, vec2 dest) {
X  dest[0] = v[0];
X  dest[1] = v[1];
X}
X
X/*!
X * @brief copy all members of [a] to [dest]
X *
X * @param[in]  a    source
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec2_copy(vec2 a, vec2 dest) {
X  dest[0] = a[0];
X  dest[1] = a[1];
X}
X
X/*!
X * @brief make vector zero
X *
X * @param[in, out]  v vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec2_zero(vec2 v) {
X  v[0] = v[1] = 0.0f;
X}
X
X/*!
X * @brief make vector one
X *
X * @param[in, out]  v vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec2_one(vec2 v) {
X  v[0] = v[1] = 1.0f;
X}
X
X/*!
X * @brief vec2 dot product
X *
X * @param[in] a vector1
X * @param[in] b vector2
X *
X * @return dot product
X */
XCGLM_INLINE
Xfloat
Xglm_vec2_dot(vec2 a, vec2 b) {
X  return a[0] * b[0] + a[1] * b[1];
X}
X
X/*!
X * @brief vec2 cross product
X *
X * REF: http://allenchou.net/2013/07/cross-product-of-2d-vectors/
X *
X * @param[in]  a vector1
X * @param[in]  b vector2
X *
X * @return Z component of cross product
X */
XCGLM_INLINE
Xfloat
Xglm_vec2_cross(vec2 a, vec2 b) {
X  /* just calculate the z-component */
X  return a[0] * b[1] - a[1] * b[0];
X}
X
X/*!
X * @brief norm * norm (magnitude) of vec
X *
X * we can use this func instead of calling norm * norm, because it would call
X * sqrtf fuction twice but with this func we can avoid func call, maybe this is
X * not good name for this func
X *
X * @param[in] v vector
X *
X * @return norm * norm
X */
XCGLM_INLINE
Xfloat
Xglm_vec2_norm2(vec2 v) {
X  return glm_vec2_dot(v, v);
X}
X
X/*!
X * @brief norm (magnitude) of vec2
X *
X * @param[in] vec vector
X *
X * @return norm
X */
XCGLM_INLINE
Xfloat
Xglm_vec2_norm(vec2 vec) {
X  return sqrtf(glm_vec2_norm2(vec));
X}
X
X/*!
X * @brief add a vector to b vector store result in dest
X *
X * @param[in]  a    vector1
X * @param[in]  b    vector2
X * @param[out] dest destination vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec2_add(vec2 a, vec2 b, vec2 dest) {
X  dest[0] = a[0] + b[0];
X  dest[1] = a[1] + b[1];
X}
X
X/*!
X * @brief add scalar to v vector store result in dest (d = v + s)
X *
X * @param[in]  v    vector
X * @param[in]  s    scalar
X * @param[out] dest destination vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec2_adds(vec2 v, float s, vec2 dest) {
X  dest[0] = v[0] + s;
X  dest[1] = v[1] + s;
X}
X
X/*!
X * @brief subtract b vector from a vector store result in dest
X *
X * @param[in]  a    vector1
X * @param[in]  b    vector2
X * @param[out] dest destination vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec2_sub(vec2 a, vec2 b, vec2 dest) {
X  dest[0] = a[0] - b[0];
X  dest[1] = a[1] - b[1];
X}
X
X/*!
X * @brief subtract scalar from v vector store result in dest (d = v - s)
X *
X * @param[in]  v    vector
X * @param[in]  s    scalar
X * @param[out] dest destination vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec2_subs(vec2 v, float s, vec2 dest) {
X  dest[0] = v[0] - s;
X  dest[1] = v[1] - s;
X}
X
X/*!
X * @brief multiply two vectors (component-wise multiplication)
X *
X * @param a    v1
X * @param b    v2
X * @param dest v3 = (a[0] * b[0], a[1] * b[1])
X */
XCGLM_INLINE
Xvoid
Xglm_vec2_mul(vec2 a, vec2 b, vec2 dest) {
X  dest[0] = a[0] * b[0];
X  dest[1] = a[1] * b[1];
X}
X
X/*!
X * @brief multiply/scale vector with scalar: result = v * s
X *
X * @param[in]  v    vector
X * @param[in]  s    scalar
X * @param[out] dest destination vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec2_scale(vec2 v, float s, vec2 dest) {
X  dest[0] = v[0] * s;
X  dest[1] = v[1] * s;
X}
X
X/*!
X * @brief scale as vector specified: result = unit(v) * s
X *
X * @param[in]  v    vector
X * @param[in]  s    scalar
X * @param[out] dest destination vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec2_scale_as(vec2 v, float s, vec2 dest) {
X  float norm;
X  norm = glm_vec2_norm(v);
X
X  if (norm == 0.0f) {
X    glm_vec2_zero(dest);
X    return;
X  }
X
X  glm_vec2_scale(v, s / norm, dest);
X}
X
X/*!
X * @brief div vector with another component-wise division: d = a / b
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @param[out] dest result = (a[0]/b[0], a[1]/b[1])
X */
XCGLM_INLINE
Xvoid
Xglm_vec2_div(vec2 a, vec2 b, vec2 dest) {
X  dest[0] = a[0] / b[0];
X  dest[1] = a[1] / b[1];
X}
X
X/*!
X * @brief div vector with scalar: d = v / s
X *
X * @param[in]  v    vector
X * @param[in]  s    scalar
X * @param[out] dest result = (a[0]/s, a[1]/s)
X */
XCGLM_INLINE
Xvoid
Xglm_vec2_divs(vec2 v, float s, vec2 dest) {
X  dest[0] = v[0] / s;
X  dest[1] = v[1] / s;
X}
X
X/*!
X * @brief add two vectors and add result to sum
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @param[out] dest dest += (a + b)
X */
XCGLM_INLINE
Xvoid
Xglm_vec2_addadd(vec2 a, vec2 b, vec2 dest) {
X  dest[0] += a[0] + b[0];
X  dest[1] += a[1] + b[1];
X}
X
X/*!
X * @brief sub two vectors and add result to dest
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @param[out] dest dest += (a + b)
X */
XCGLM_INLINE
Xvoid
Xglm_vec2_subadd(vec2 a, vec2 b, vec2 dest) {
X  dest[0] += a[0] - b[0];
X  dest[1] += a[1] - b[1];
X}
X
X/*!
X * @brief mul two vectors and add result to dest
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @param[out] dest dest += (a * b)
X */
XCGLM_INLINE
Xvoid
Xglm_vec2_muladd(vec2 a, vec2 b, vec2 dest) {
X  dest[0] += a[0] * b[0];
X  dest[1] += a[1] * b[1];
X}
X
X/*!
X * @brief mul vector with scalar and add result to sum
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector
X * @param[in]  s    scalar
X * @param[out] dest dest += (a * b)
X */
XCGLM_INLINE
Xvoid
Xglm_vec2_muladds(vec2 a, float s, vec2 dest) {
X  dest[0] += a[0] * s;
X  dest[1] += a[1] * s;
X}
X
X/*!
X * @brief add max of two vectors to result/dest
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @param[out] dest dest += max(a, b)
X */
XCGLM_INLINE
Xvoid
Xglm_vec2_maxadd(vec2 a, vec2 b, vec2 dest) {
X  dest[0] += glm_max(a[0], b[0]);
X  dest[1] += glm_max(a[1], b[1]);
X}
X
X/*!
X * @brief add min of two vectors to result/dest
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @param[out] dest dest += min(a, b)
X */
XCGLM_INLINE
Xvoid
Xglm_vec2_minadd(vec2 a, vec2 b, vec2 dest) {
X  dest[0] += glm_min(a[0], b[0]);
X  dest[1] += glm_min(a[1], b[1]);
X}
X
X/*!
X * @brief sub two vectors and sub result to dest
X *
X * it applies -= operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @param[out] dest dest -= (a - b)
X */
XCGLM_INLINE
Xvoid
Xglm_vec2_subsub(vec2 a, vec2 b, vec2 dest) {
X  dest[0] -= a[0] - b[0];
X  dest[1] -= a[1] - b[1];
X}
X
X/*!
X * @brief add two vectors and sub result to dest
X *
X * it applies -= operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @param[out] dest dest -= (a + b)
X */
XCGLM_INLINE
Xvoid
Xglm_vec2_addsub(vec2 a, vec2 b, vec2 dest) {
X  dest[0] -= a[0] + b[0];
X  dest[1] -= a[1] + b[1];
X}
X
X/*!
X * @brief mul two vectors and sub result to dest
X *
X * it applies -= operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @param[out] dest dest -= (a * b)
X */
XCGLM_INLINE
Xvoid
Xglm_vec2_mulsub(vec2 a, vec2 b, vec2 dest) {
X  dest[0] -= a[0] * b[0];
X  dest[1] -= a[1] * b[1];
X}
X
X/*!
X * @brief mul vector with scalar and sub result to sum
X *
X * it applies -= operator so dest must be initialized
X *
X * @param[in]  a    vector
X * @param[in]  s    scalar
X * @param[out] dest dest -= (a * b)
X */
XCGLM_INLINE
Xvoid
Xglm_vec2_mulsubs(vec2 a, float s, vec2 dest) {
X  dest[0] -= a[0] * s;
X  dest[1] -= a[1] * s;
X}
X
X/*!
X * @brief sub max of two vectors to result/dest
X *
X * it applies -= operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @param[out] dest dest -= max(a, b)
X */
XCGLM_INLINE
Xvoid
Xglm_vec2_maxsub(vec2 a, vec2 b, vec2 dest) {
X  dest[0] -= glm_max(a[0], b[0]);
X  dest[1] -= glm_max(a[1], b[1]);
X}
X
X/*!
X * @brief sub min of two vectors to result/dest
X *
X * it applies -= operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @param[out] dest dest -= min(a, b)
X */
XCGLM_INLINE
Xvoid
Xglm_vec2_minsub(vec2 a, vec2 b, vec2 dest) {
X  dest[0] -= glm_min(a[0], b[0]);
X  dest[1] -= glm_min(a[1], b[1]);
X}
X
X/*!
X * @brief negate vector components and store result in dest
X *
X * @param[in]   v     vector
X * @param[out]  dest  result vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec2_negate_to(vec2 v, vec2 dest) {
X  dest[0] = -v[0];
X  dest[1] = -v[1];
X}
X
X/*!
X * @brief negate vector components
X *
X * @param[in, out]  v  vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec2_negate(vec2 v) {
X  glm_vec2_negate_to(v, v);
X}
X
X/*!
X * @brief normalize vector and store result in same vec
X *
X * @param[in, out] v vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec2_normalize(vec2 v) {
X  float norm;
X
X  norm = glm_vec2_norm(v);
X
X  if (norm == 0.0f) {
X    v[0] = v[1] = 0.0f;
X    return;
X  }
X
X  glm_vec2_scale(v, 1.0f / norm, v);
X}
X
X/*!
X * @brief normalize vector to dest
X *
X * @param[in]  v    source
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec2_normalize_to(vec2 v, vec2 dest) {
X  float norm;
X
X  norm = glm_vec2_norm(v);
X
X  if (norm == 0.0f) {
X    glm_vec2_zero(dest);
X    return;
X  }
X
X  glm_vec2_scale(v, 1.0f / norm, dest);
X}
X
X/*!
X * @brief rotate vec2 around origin by angle (CCW: counterclockwise)
X *
X * Formula:
X *   2 = cos(a)1  sin(a)1
X *   2 = sin(a)1 + cos(a)1
X *
X * @param[in]  v     vector to rotate
X * @param[in]  angle angle by radians
X * @param[out] dest  destination vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec2_rotate(vec2 v, float angle, vec2 dest) {
X  float c, s, x1, y1;
X
X  c  = cosf(angle);
X  s  = sinf(angle);
X
X  x1 = v[0];
X  y1 = v[1];
X
X  dest[0] = c * x1 - s * y1;
X  dest[1] = s * x1 + c * y1;
X}
X
X/**
X * @brief find center point of two vector
X *
X * @param[in]  a    vector1
X * @param[in]  b    vector2
X * @param[out] dest center point
X */
XCGLM_INLINE
Xvoid
Xglm_vec2_center(vec2 a, vec2 b, vec2 dest) {
X  glm_vec2_add(a, b, dest);
X  glm_vec2_scale(dest, 0.5f, dest);
X}
X
X/**
X * @brief squared distance between two vectors
X *
X * @param[in] a vector1
X * @param[in] b vector2
X * @return returns squared distance (distance * distance)
X */
XCGLM_INLINE
Xfloat
Xglm_vec2_distance2(vec2 a, vec2 b) {
X  return glm_pow2(b[0] - a[0]) + glm_pow2(b[1] - a[1]);
X}
X
X/**
X * @brief distance between two vectors
X *
X * @param[in] a vector1
X * @param[in] b vector2
X * @return returns distance
X */
XCGLM_INLINE
Xfloat
Xglm_vec2_distance(vec2 a, vec2 b) {
X  return sqrtf(glm_vec2_distance2(a, b));
X}
X
X/*!
X * @brief max values of vectors
X *
X * @param[in]  a    vector1
X * @param[in]  b    vector2
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec2_maxv(vec2 a, vec2 b, vec2 dest) {
X  dest[0] = glm_max(a[0], b[0]);
X  dest[1] = glm_max(a[1], b[1]);
X}
X
X/*!
X * @brief min values of vectors
X *
X * @param[in]  a    vector1
X * @param[in]  b    vector2
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec2_minv(vec2 a, vec2 b, vec2 dest) {
X  dest[0] = glm_min(a[0], b[0]);
X  dest[1] = glm_min(a[1], b[1]);
X}
X
X/*!
X * @brief clamp vector's individual members between min and max values
X *
X * @param[in, out]  v      vector
X * @param[in]       minval minimum value
X * @param[in]       maxval maximum value
X */
XCGLM_INLINE
Xvoid
Xglm_vec2_clamp(vec2 v, float minval, float maxval) {
X  v[0] = glm_clamp(v[0], minval, maxval);
X  v[1] = glm_clamp(v[1], minval, maxval);
X}
X
X/*!
X * @brief linear interpolation between two vector
X *
X * formula:  from + s * (to - from)
X *
X * @param[in]   from from value
X * @param[in]   to   to value
X * @param[in]   t    interpolant (amount) clamped between 0 and 1
X * @param[out]  dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec2_lerp(vec2 from, vec2 to, float t, vec2 dest) {
X  vec2 s, v;
X
X  /* from + s * (to - from) */
X  glm_vec2_fill(s, glm_clamp_zo(t));
X  glm_vec2_sub(to, from, v);
X  glm_vec2_mul(s, v, v);
X  glm_vec2_add(from, v, dest);
X}
X
X/*!
X * @brief Create two dimensional vector from pointer
X *
X * @param[in]  src  pointer to an array of floats
X * @param[out] dest destination vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec2_make(float * __restrict src, vec2 dest) {
X  dest[0] = src[0]; dest[1] = src[1];
X}
X
X#endif /* cglm_vec2_h */
4001921be909fdebb392c47ed9d6f0f5
echo x - cglm/vec2-ext.h
sed 's/^X//' >cglm/vec2-ext.h << '749867399e3219477a269f74f6512694'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Functions:
X   CGLM_INLINE void  glm_vec2_fill(vec2 v, float val)
X   CGLM_INLINE bool  glm_vec2_eq(vec2 v, float val);
X   CGLM_INLINE bool  glm_vec2_eq_eps(vec2 v, float val);
X   CGLM_INLINE bool  glm_vec2_eq_all(vec2 v);
X   CGLM_INLINE bool  glm_vec2_eqv(vec2 a, vec2 b);
X   CGLM_INLINE bool  glm_vec2_eqv_eps(vec2 a, vec2 b);
X   CGLM_INLINE float glm_vec2_max(vec2 v);
X   CGLM_INLINE float glm_vec2_min(vec2 v);
X   CGLM_INLINE bool  glm_vec2_isnan(vec2 v);
X   CGLM_INLINE bool  glm_vec2_isinf(vec2 v);
X   CGLM_INLINE bool  glm_vec2_isvalid(vec2 v);
X   CGLM_INLINE void  glm_vec2_sign(vec2 v, vec2 dest);
X   CGLM_INLINE void  glm_vec2_abs(vec2 v, vec2 dest);
X   CGLM_INLINE void  glm_vec2_sqrt(vec2 v, vec2 dest);
X   CGLM_INLINE void  glm_vec2_complex_mul(vec2 a, vec2 b, vec2 dest)
X   CGLM_INLINE void  glm_vec2_complex_div(vec2 a, vec2 b, vec2 dest)
X   CGLM_INLINE void  glm_vec2_complex_conjugate(vec2 a, vec2 dest)
X */
X
X#ifndef cglm_vec2_ext_h
X#define cglm_vec2_ext_h
X
X#include "common.h"
X#include "util.h"
X
X/*!
X * @brief fill a vector with specified value
X *
X * @param[out] v   dest
X * @param[in]  val value
X */
XCGLM_INLINE
Xvoid
Xglm_vec2_fill(vec2 v, float val) {
X  v[0] = v[1] = val;
X}
X
X/*!
X * @brief check if vector is equal to value (without epsilon)
X *
X * @param[in] v   vector
X * @param[in] val value
X */
XCGLM_INLINE
Xbool
Xglm_vec2_eq(vec2 v, float val) {
X  return v[0] == val && v[0] == v[1];
X}
X
X/*!
X * @brief check if vector is equal to value (with epsilon)
X *
X * @param[in] v   vector
X * @param[in] val value
X */
XCGLM_INLINE
Xbool
Xglm_vec2_eq_eps(vec2 v, float val) {
X  return fabsf(v[0] - val) <= GLM_FLT_EPSILON
X         && fabsf(v[1] - val) <= GLM_FLT_EPSILON;
X}
X
X/*!
X * @brief check if vector members are equal (without epsilon)
X *
X * @param[in] v   vector
X */
XCGLM_INLINE
Xbool
Xglm_vec2_eq_all(vec2 v) {
X  return glm_vec2_eq_eps(v, v[0]);
X}
X
X/*!
X * @brief check if vector is equal to another (without epsilon)
X *
X * @param[in] a vector
X * @param[in] b vector
X */
XCGLM_INLINE
Xbool
Xglm_vec2_eqv(vec2 a, vec2 b) {
X  return a[0] == b[0] && a[1] == b[1];
X}
X
X/*!
X * @brief check if vector is equal to another (with epsilon)
X *
X * @param[in] a vector
X * @param[in] b vector
X */
XCGLM_INLINE
Xbool
Xglm_vec2_eqv_eps(vec2 a, vec2 b) {
X  return fabsf(a[0] - b[0]) <= GLM_FLT_EPSILON
X         && fabsf(a[1] - b[1]) <= GLM_FLT_EPSILON;
X}
X
X/*!
X * @brief max value of vector
X *
X * @param[in] v vector
X */
XCGLM_INLINE
Xfloat
Xglm_vec2_max(vec2 v) {
X  return glm_max(v[0], v[1]);
X}
X
X/*!
X * @brief min value of vector
X *
X * @param[in] v vector
X */
XCGLM_INLINE
Xfloat
Xglm_vec2_min(vec2 v) {
X  return glm_min(v[0], v[1]);
X}
X
X/*!
X * @brief check if all items are NaN (not a number)
X *        you should only use this in DEBUG mode or very critical asserts
X *
X * @param[in] v vector
X */
XCGLM_INLINE
Xbool
Xglm_vec2_isnan(vec2 v) {
X  return isnan(v[0]) || isnan(v[1]);
X}
X
X/*!
X * @brief check if all items are INFINITY
X *        you should only use this in DEBUG mode or very critical asserts
X *
X * @param[in] v vector
X */
XCGLM_INLINE
Xbool
Xglm_vec2_isinf(vec2 v) {
X  return isinf(v[0]) || isinf(v[1]);
X}
X
X/*!
X * @brief check if all items are valid number
X *        you should only use this in DEBUG mode or very critical asserts
X *
X * @param[in] v vector
X */
XCGLM_INLINE
Xbool
Xglm_vec2_isvalid(vec2 v) {
X  return !glm_vec2_isnan(v) && !glm_vec2_isinf(v);
X}
X
X/*!
X * @brief get sign of 32 bit float as +1, -1, 0
X *
X * Important: It returns 0 for zero/NaN input
X *
X * @param v vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec2_sign(vec2 v, vec2 dest) {
X  dest[0] = glm_signf(v[0]);
X  dest[1] = glm_signf(v[1]);
X}
X
X/*!
X * @brief absolute value of v
X *
X * @param[in]	v	vector
X * @param[out]	dest	destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec2_abs(vec2 v, vec2 dest) {
X  dest[0] = fabsf(v[0]);
X  dest[1] = fabsf(v[1]);
X}
X
X/*!
X * @brief square root of each vector item
X *
X * @param[in]  v    vector
X * @param[out] dest destination vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec2_sqrt(vec2 v, vec2 dest) {
X  dest[0] = sqrtf(v[0]);
X  dest[1] = sqrtf(v[1]);
X}
X
X/*!
X * @brief treat vectors as complex numbers and multiply them as such.
X *
X * @param[in]  a    left number
X * @param[in]  b    right number
X * @param[out] dest destination number
X */
XCGLM_INLINE
Xvoid
Xglm_vec2_complex_mul(vec2 a, vec2 b, vec2 dest) {
X  float tr, ti;
X  tr = a[0] * b[0] - a[1] * b[1];
X  ti = a[0] * b[1] + a[1] * b[0];
X  dest[0] = tr;
X  dest[1] = ti;
X}
X
X/*!
X * @brief treat vectors as complex numbers and divide them as such.
X *
X * @param[in]  a    left number (numerator)
X * @param[in]  b    right number (denominator)
X * @param[out] dest destination number
X */
XCGLM_INLINE
Xvoid
Xglm_vec2_complex_div(vec2 a, vec2 b, vec2 dest) {
X  float tr, ti;
X  float const ibnorm2 = 1.0f / (b[0] * b[0] + b[1] * b[1]);
X  tr = ibnorm2 * (a[0] * b[0] + a[1] * b[1]);
X  ti = ibnorm2 * (a[1] * b[0] - a[0] * b[1]);
X  dest[0] = tr;
X  dest[1] = ti;
X}
X
X/*!
X * @brief treat the vector as a complex number and conjugate it as such.
X *
X * @param[in]  a    the number
X * @param[out] dest destination number
X */
XCGLM_INLINE
Xvoid
Xglm_vec2_complex_conjugate(vec2 a, vec2 dest) {
X  dest[0] =  a[0];
X  dest[1] = -a[1];
X}
X
X#endif /* cglm_vec2_ext_h */
749867399e3219477a269f74f6512694
echo x - cglm/ivec2.h
sed 's/^X//' >cglm/ivec2.h << 'dd33adfdce7701ca261150a15c22883d'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Macros:
X   GLM_IVEC2_ONE_INIT
X   GLM_IVEC2_ZERO_INIT
X   GLM_IVEC2_ONE
X   GLM_IVEC2_ZERO
X
X Functions:
X  CGLM_INLINE void glm_ivec2(int * __restrict v, ivec2 dest)
X  CGLM_INLINE void glm_ivec2_copy(ivec2 a, ivec2 dest)
X  CGLM_INLINE void glm_ivec2_zero(ivec2 v)
X  CGLM_INLINE void glm_ivec2_one(ivec2 v)
X  CGLM_INLINE void glm_ivec2_add(ivec2 a, ivec2 b, ivec2 dest)
X  CGLM_INLINE void glm_ivec2_adds(ivec2 v, int s, ivec2 dest)
X  CGLM_INLINE void glm_ivec2_sub(ivec2 a, ivec2 b, ivec2 dest)
X  CGLM_INLINE void glm_ivec2_subs(ivec2 v, int s, ivec2 dest)
X  CGLM_INLINE void glm_ivec2_mul(ivec2 a, ivec2 b, ivec2 dest)
X  CGLM_INLINE void glm_ivec2_scale(ivec2 v, int s, ivec2 dest)
X  CGLM_INLINE int glm_ivec2_distance2(ivec2 a, ivec2 b)
X  CGLM_INLINE float glm_ivec2_distance(ivec2 a, ivec2 b)
X  CGLM_INLINE void glm_ivec2_fill(ivec2 v, int val);
X  CGLM_INLINE bool glm_ivec2_eq(ivec2 v, int val);
X  CGLM_INLINE bool glm_ivec2_eqv(ivec2 a, ivec2 b);
X  CGLM_INLINE void glm_ivec2_maxv(ivec2 a, ivec2 b, ivec2 dest)
X  CGLM_INLINE void glm_ivec2_minv(ivec2 a, ivec2 b, ivec2 dest)
X  CGLM_INLINE void glm_ivec2_clamp(ivec2 v, int minVal, int maxVal)
X  CGLM_INLINE void glm_ivec2_abs(ivec2 v, ivec2 dest)
X */
X
X#ifndef cglm_ivec2_h
X#define cglm_ivec2_h
X
X#include "common.h"
X
X#define GLM_IVEC2_ONE_INIT   {1, 1}
X#define GLM_IVEC2_ZERO_INIT  {0, 0}
X
X#define GLM_IVEC2_ONE  ((ivec2)GLM_IVEC2_ONE_INIT)
X#define GLM_IVEC2_ZERO ((ivec2)GLM_IVEC2_ZERO_INIT)
X
X/*!
X * @brief init ivec2 using vec3 or vec4
X *
X * @param[in]  v    vector
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_ivec2(int * __restrict v, ivec2 dest) {
X  dest[0] = v[0];
X  dest[1] = v[1];
X}
X
X/*!
X * @brief copy all members of [a] to [dest]
X *
X * @param[in]  a    source vector
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_ivec2_copy(ivec2 a, ivec2 dest) {
X  dest[0] = a[0];
X  dest[1] = a[1];
X}
X
X/*!
X * @brief set all members of [v] to zero
X *
X * @param[out] v vector
X */
XCGLM_INLINE
Xvoid 
Xglm_ivec2_zero(ivec2 v) {
X  v[0] = v[1] = 0;
X}
X
X/*!
X * @brief set all members of [v] to one
X *
X * @param[out] v vector
X */
XCGLM_INLINE
Xvoid
Xglm_ivec2_one(ivec2 v) {
X  v[0] = v[1] = 1;
X}
X
X/*!
X * @brief add vector [a] to vector [b] and store result in [dest]
X *
X * @param[in]  a    first vector
X * @param[in]  b    second vector
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_ivec2_add(ivec2 a, ivec2 b, ivec2 dest) {
X  dest[0] = a[0] + b[0];
X  dest[1] = a[1] + b[1];
X}
X
X/*!
X * @brief add scalar s to vector [v] and store result in [dest]
X *
X * @param[in]  v    vector
X * @param[in]  s    scalar
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_ivec2_adds(ivec2 v, int s, ivec2 dest) {
X  dest[0] = v[0] + s;
X  dest[1] = v[1] + s;
X}
X
X/*!
X * @brief subtract vector [b] from vector [a] and store result in [dest]
X *
X * @param[in]  a    first vector
X * @param[in]  b    second vector
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_ivec2_sub(ivec2 a, ivec2 b, ivec2 dest) {
X  dest[0] = a[0] - b[0];
X  dest[1] = a[1] - b[1];
X}
X
X/*!
X * @brief subtract scalar s from vector [v] and store result in [dest]
X *
X * @param[in]  v    vector
X * @param[in]  s    scalar
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_ivec2_subs(ivec2 v, int s, ivec2 dest) {
X  dest[0] = v[0] - s;
X  dest[1] = v[1] - s;
X}
X
X/*!
X * @brief multiply vector [a] with vector [b] and store result in [dest]
X *
X * @param[in]  a    frist vector
X * @param[in]  b    second vector
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_ivec2_mul(ivec2 a, ivec2 b, ivec2 dest) {
X  dest[0] = a[0] * b[0];
X  dest[1] = a[1] * b[1];
X}
X
X/*!
X * @brief multiply vector [a] with scalar s and store result in [dest]
X *
X * @param[in]  v    vector
X * @param[in]  s    scalar
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_ivec2_scale(ivec2 v, int s, ivec2 dest) {
X  dest[0] = v[0] * s;
X  dest[1] = v[1] * s;
X}
X
X/*!
X * @brief squared distance between two vectors
X *
X * @param[in] a first vector
X * @param[in] b second vector
X * @return returns squared distance (distance * distance)
X */
XCGLM_INLINE
Xint
Xglm_ivec2_distance2(ivec2 a, ivec2 b) {
X  int xd, yd;
X  xd = a[0] - b[0];
X  yd = a[1] - b[1];
X  return xd * xd + yd * yd;
X}
X
X/*!
X * @brief distance between two vectors
X *
X * @param[in] a first vector
X * @param[in] b second vector
X * @return returns distance
X */
XCGLM_INLINE
Xfloat
Xglm_ivec2_distance(ivec2 a, ivec2 b) {
X  return sqrtf((float)glm_ivec2_distance2(a, b));
X}
X
X
X/*!
X * @brief fill a vector with specified value
X *
X * @param[out] v   dest
X * @param[in]  val value
X */
XCGLM_INLINE
Xvoid
Xglm_ivec2_fill(ivec2 v, int val) {
X  v[0] = v[1] = val;
X}
X
X/*!
X * @brief check if vector is equal to value
X *
X * @param[in] v   vector
X * @param[in] val value
X */
XCGLM_INLINE
Xbool
Xglm_ivec2_eq(ivec2 v, int val) {
X  return v[0] == val && v[0] == v[1];
X}
X
X/*!
X * @brief check if vector is equal to another
X *
X * @param[in] a vector
X * @param[in] b vector
X */
XCGLM_INLINE
Xbool
Xglm_ivec2_eqv(ivec2 a, ivec2 b) {
X  return a[0] == b[0]
X         && a[1] == b[1];
X}
X
X/*!
X * @brief set each member of dest to greater of vector a and b
X *
X * @param[in]  a    first vector
X * @param[in]  b    second vector
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_ivec2_maxv(ivec2 a, ivec2 b, ivec2 dest) {
X  dest[0] = a[0] > b[0] ? a[0] : b[0];
X  dest[1] = a[1] > b[1] ? a[1] : b[1];
X}
X
X/*!
X * @brief set each member of dest to lesser of vector a and b
X *
X * @param[in]  a    first vector
X * @param[in]  b    second vector
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_ivec2_minv(ivec2 a, ivec2 b, ivec2 dest) {
X  dest[0] = a[0] < b[0] ? a[0] : b[0];
X  dest[1] = a[1] < b[1] ? a[1] : b[1];
X}
X
X/*!
X * @brief clamp each member of [v] between minVal and maxVal (inclusive)
X *
X * @param[in, out] v      vector
X * @param[in]      minVal minimum value
X * @param[in]      maxVal maximum value
X */
XCGLM_INLINE
Xvoid
Xglm_ivec2_clamp(ivec2 v, int minVal, int maxVal) {
X  if (v[0] < minVal)
X    v[0] = minVal;
X  else if(v[0] > maxVal)
X    v[0] = maxVal;
X
X  if (v[1] < minVal)
X    v[1] = minVal;
X  else if(v[1] > maxVal)
X    v[1] = maxVal;
X}
X
X/*!
X * @brief absolute value of v
X *
X * @param[in]	v	vector
X * @param[out]	dest	destination
X */
XCGLM_INLINE
Xvoid
Xglm_ivec2_abs(ivec2 v, ivec2 dest) {
X  dest[0] = abs(v[0]);
X  dest[1] = abs(v[1]);
X}
X
X#endif /* cglm_ivec2_h */
dd33adfdce7701ca261150a15c22883d
echo x - cglm/vec3.h
sed 's/^X//' >cglm/vec3.h << '76cbf42507315cc0767578bd22730a73'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Macros:
X   GLM_VEC3_ONE_INIT
X   GLM_VEC3_ZERO_INIT
X   GLM_VEC3_ONE
X   GLM_VEC3_ZERO
X   GLM_YUP
X   GLM_ZUP
X   GLM_XUP
X
X Functions:
X   CGLM_INLINE void  glm_vec3(vec4 v4, vec3 dest);
X   CGLM_INLINE void  glm_vec3_copy(vec3 a, vec3 dest);
X   CGLM_INLINE void  glm_vec3_zero(vec3 v);
X   CGLM_INLINE void  glm_vec3_one(vec3 v);
X   CGLM_INLINE float glm_vec3_dot(vec3 a, vec3 b);
X   CGLM_INLINE float glm_vec3_norm2(vec3 v);
X   CGLM_INLINE float glm_vec3_norm(vec3 v);
X   CGLM_INLINE float glm_vec3_norm_one(vec3 v);
X   CGLM_INLINE float glm_vec3_norm_inf(vec3 v);
X   CGLM_INLINE void  glm_vec3_add(vec3 a, vec3 b, vec3 dest);
X   CGLM_INLINE void  glm_vec3_adds(vec3 a, float s, vec3 dest);
X   CGLM_INLINE void  glm_vec3_sub(vec3 a, vec3 b, vec3 dest);
X   CGLM_INLINE void  glm_vec3_subs(vec3 a, float s, vec3 dest);
X   CGLM_INLINE void  glm_vec3_mul(vec3 a, vec3 b, vec3 dest);
X   CGLM_INLINE void  glm_vec3_scale(vec3 v, float s, vec3 dest);
X   CGLM_INLINE void  glm_vec3_scale_as(vec3 v, float s, vec3 dest);
X   CGLM_INLINE void  glm_vec3_div(vec3 a, vec3 b, vec3 dest);
X   CGLM_INLINE void  glm_vec3_divs(vec3 a, float s, vec3 dest);
X   CGLM_INLINE void  glm_vec3_addadd(vec3 a, vec3 b, vec3 dest);
X   CGLM_INLINE void  glm_vec3_subadd(vec3 a, vec3 b, vec3 dest);
X   CGLM_INLINE void  glm_vec3_muladd(vec3 a, vec3 b, vec3 dest);
X   CGLM_INLINE void  glm_vec3_muladds(vec3 a, float s, vec3 dest);
X   CGLM_INLINE void  glm_vec3_maxadd(vec3 a, vec3 b, vec3 dest);
X   CGLM_INLINE void  glm_vec3_minadd(vec3 a, vec3 b, vec3 dest);
X   CGLM_INLINE void  glm_vec3_subsub(vec3 a, vec3 b, vec3 dest);
X   CGLM_INLINE void  glm_vec3_addsub(vec3 a, vec3 b, vec3 dest);
X   CGLM_INLINE void  glm_vec3_mulsub(vec3 a, vec3 b, vec3 dest);
X   CGLM_INLINE void  glm_vec3_mulsubs(vec3 a, float s, vec3 dest);
X   CGLM_INLINE void  glm_vec3_maxsub(vec3 a, vec3 b, vec3 dest);
X   CGLM_INLINE void  glm_vec3_minsub(vec3 a, vec3 b, vec3 dest);
X   CGLM_INLINE void  glm_vec3_flipsign(vec3 v);
X   CGLM_INLINE void  glm_vec3_flipsign_to(vec3 v, vec3 dest);
X   CGLM_INLINE void  glm_vec3_negate_to(vec3 v, vec3 dest);
X   CGLM_INLINE void  glm_vec3_negate(vec3 v);
X   CGLM_INLINE void  glm_vec3_inv(vec3 v);
X   CGLM_INLINE void  glm_vec3_inv_to(vec3 v, vec3 dest);
X   CGLM_INLINE void  glm_vec3_normalize(vec3 v);
X   CGLM_INLINE void  glm_vec3_normalize_to(vec3 v, vec3 dest);
X   CGLM_INLINE void  glm_vec3_cross(vec3 a, vec3 b, vec3 d);
X   CGLM_INLINE void  glm_vec3_crossn(vec3 a, vec3 b, vec3 dest);
X   CGLM_INLINE float glm_vec3_angle(vec3 a, vec3 b);
X   CGLM_INLINE void  glm_vec3_rotate(vec3 v, float angle, vec3 axis);
X   CGLM_INLINE void  glm_vec3_rotate_m4(mat4 m, vec3 v, vec3 dest);
X   CGLM_INLINE void  glm_vec3_rotate_m3(mat3 m, vec3 v, vec3 dest);
X   CGLM_INLINE void  glm_vec3_proj(vec3 a, vec3 b, vec3 dest);
X   CGLM_INLINE void  glm_vec3_center(vec3 a, vec3 b, vec3 dest);
X   CGLM_INLINE float glm_vec3_distance(vec3 a, vec3 b);
X   CGLM_INLINE float glm_vec3_distance2(vec3 a, vec3 b);
X   CGLM_INLINE void  glm_vec3_maxv(vec3 a, vec3 b, vec3 dest);
X   CGLM_INLINE void  glm_vec3_minv(vec3 a, vec3 b, vec3 dest);
X   CGLM_INLINE void  glm_vec3_ortho(vec3 v, vec3 dest);
X   CGLM_INLINE void  glm_vec3_clamp(vec3 v, float minVal, float maxVal);
X   CGLM_INLINE void  glm_vec3_lerp(vec3 from, vec3 to, float t, vec3 dest);
X   CGLM_INLINE void  glm_vec3_lerpc(vec3 from, vec3 to, float t, vec3 dest);
X   CGLM_INLINE void  glm_vec3_mix(vec3 from, vec3 to, float t, vec3 dest);
X   CGLM_INLINE void  glm_vec3_mixc(vec3 from, vec3 to, float t, vec3 dest);
X   CGLM_INLINE void  glm_vec3_step_uni(float edge, vec3 x, vec3 dest);
X   CGLM_INLINE void  glm_vec3_step(vec3 edge, vec3 x, vec3 dest);
X   CGLM_INLINE void  glm_vec3_smoothstep_uni(float edge0, float edge1, vec3 x, vec3 dest);
X   CGLM_INLINE void  glm_vec3_smoothstep(vec3 edge0, vec3 edge1, vec3 x, vec3 dest);
X   CGLM_INLINE void  glm_vec3_smoothinterp(vec3 from, vec3 to, float t, vec3 dest);
X   CGLM_INLINE void  glm_vec3_smoothinterpc(vec3 from, vec3 to, float t, vec3 dest);
X   CGLM_INLINE void  glm_vec3_swizzle(vec3 v, int mask, vec3 dest);
X   CGLM_INLINE void  glm_vec3_make(float * restrict src, vec3 dest);
X
X Convenient:
X   CGLM_INLINE void  glm_cross(vec3 a, vec3 b, vec3 d);
X   CGLM_INLINE float glm_dot(vec3 a, vec3 b);
X   CGLM_INLINE void  glm_normalize(vec3 v);
X   CGLM_INLINE void  glm_normalize_to(vec3 v, vec3 dest);
X
X DEPRECATED:
X   glm_vec3_dup
X   glm_vec3_flipsign
X   glm_vec3_flipsign_to
X   glm_vec3_inv
X   glm_vec3_inv_to
X   glm_vec3_mulv
X */
X
X#ifndef cglm_vec3_h
X#define cglm_vec3_h
X
X#include "common.h"
X#include "vec4.h"
X#include "vec3-ext.h"
X#include "util.h"
X
X/* DEPRECATED! use _copy, _ucopy versions */
X#define glm_vec3_dup(v, dest)         glm_vec3_copy(v, dest)
X#define glm_vec3_flipsign(v)          glm_vec3_negate(v)
X#define glm_vec3_flipsign_to(v, dest) glm_vec3_negate_to(v, dest)
X#define glm_vec3_inv(v)               glm_vec3_negate(v)
X#define glm_vec3_inv_to(v, dest)      glm_vec3_negate_to(v, dest)
X#define glm_vec3_mulv(a, b, d)        glm_vec3_mul(a, b, d)
X
X#define GLM_VEC3_ONE_INIT   {1.0f, 1.0f, 1.0f}
X#define GLM_VEC3_ZERO_INIT  {0.0f, 0.0f, 0.0f}
X
X#define GLM_VEC3_ONE  ((vec3)GLM_VEC3_ONE_INIT)
X#define GLM_VEC3_ZERO ((vec3)GLM_VEC3_ZERO_INIT)
X
X#define GLM_YUP       ((vec3){0.0f,  1.0f,  0.0f})
X#define GLM_ZUP       ((vec3){0.0f,  0.0f,  1.0f})
X#define GLM_XUP       ((vec3){1.0f,  0.0f,  0.0f})
X#define GLM_FORWARD   ((vec3){0.0f,  0.0f, -1.0f})
X
X#define GLM_XXX GLM_SHUFFLE3(0, 0, 0)
X#define GLM_YYY GLM_SHUFFLE3(1, 1, 1)
X#define GLM_ZZZ GLM_SHUFFLE3(2, 2, 2)
X#define GLM_ZYX GLM_SHUFFLE3(0, 1, 2)
X
X/*!
X * @brief init vec3 using vec4
X *
X * @param[in]  v4   vector4
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec3(vec4 v4, vec3 dest) {
X  dest[0] = v4[0];
X  dest[1] = v4[1];
X  dest[2] = v4[2];
X}
X
X/*!
X * @brief copy all members of [a] to [dest]
X *
X * @param[in]  a    source
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_copy(vec3 a, vec3 dest) {
X  dest[0] = a[0];
X  dest[1] = a[1];
X  dest[2] = a[2];
X}
X
X/*!
X * @brief make vector zero
X *
X * @param[in, out]  v vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_zero(vec3 v) {
X  v[0] = v[1] = v[2] = 0.0f;
X}
X
X/*!
X * @brief make vector one
X *
X * @param[in, out]  v vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_one(vec3 v) {
X  v[0] = v[1] = v[2] = 1.0f;
X}
X
X/*!
X * @brief vec3 dot product
X *
X * @param[in] a vector1
X * @param[in] b vector2
X *
X * @return dot product
X */
XCGLM_INLINE
Xfloat
Xglm_vec3_dot(vec3 a, vec3 b) {
X  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
X}
X
X/*!
X * @brief norm * norm (magnitude) of vec
X *
X * we can use this func instead of calling norm * norm, because it would call
X * sqrtf fuction twice but with this func we can avoid func call, maybe this is
X * not good name for this func
X *
X * @param[in] v vector
X *
X * @return norm * norm
X */
XCGLM_INLINE
Xfloat
Xglm_vec3_norm2(vec3 v) {
X  return glm_vec3_dot(v, v);
X}
X
X/*!
X * @brief euclidean norm (magnitude), also called L2 norm
X *        this will give magnitude of vector in euclidean space
X *
X * @param[in] v vector
X *
X * @return norm
X */
XCGLM_INLINE
Xfloat
Xglm_vec3_norm(vec3 v) {
X  return sqrtf(glm_vec3_norm2(v));
X}
X
X/*!
X * @brief L1 norm of vec3
X * Also known as Manhattan Distance or Taxicab norm.
X * L1 Norm is the sum of the magnitudes of the vectors in a space.
X * It is calculated as the sum of the absolute values of the vector components.
X * In this norm, all the components of the vector are weighted equally.
X *
X * This computes:
X * R = |v[0]| + |v[1]| + |v[2]|
X *
X * @param[in] v vector
X *
X * @return L1 norm
X */
XCGLM_INLINE
Xfloat
Xglm_vec3_norm_one(vec3 v) {
X  vec3 t;
X  glm_vec3_abs(v, t);
X  return glm_vec3_hadd(t);
X}
X
X/*!
X * @brief infinity norm of vec3
X * Also known as Maximum norm.
X * Infinity Norm is the largest magnitude among each element of a vector.
X * It is calculated as the maximum of the absolute values of the vector components.
X *
X * This computes:
X * inf norm = max(|v[0]|, |v[1]|, |v[2]|)
X *
X * @param[in] v vector
X *
X * @return infinity norm
X */
XCGLM_INLINE
Xfloat
Xglm_vec3_norm_inf(vec3 v) {
X  vec3 t;
X  glm_vec3_abs(v, t);
X  return glm_vec3_max(t);
X}
X
X/*!
X * @brief add a vector to b vector store result in dest
X *
X * @param[in]  a    vector1
X * @param[in]  b    vector2
X * @param[out] dest destination vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_add(vec3 a, vec3 b, vec3 dest) {
X  dest[0] = a[0] + b[0];
X  dest[1] = a[1] + b[1];
X  dest[2] = a[2] + b[2];
X}
X
X/*!
X * @brief add scalar to v vector store result in dest (d = v + s)
X *
X * @param[in]  v    vector
X * @param[in]  s    scalar
X * @param[out] dest destination vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_adds(vec3 v, float s, vec3 dest) {
X  dest[0] = v[0] + s;
X  dest[1] = v[1] + s;
X  dest[2] = v[2] + s;
X}
X
X/*!
X * @brief subtract b vector from a vector store result in dest
X *
X * @param[in]  a    vector1
X * @param[in]  b    vector2
X * @param[out] dest destination vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_sub(vec3 a, vec3 b, vec3 dest) {
X  dest[0] = a[0] - b[0];
X  dest[1] = a[1] - b[1];
X  dest[2] = a[2] - b[2];
X}
X
X/*!
X * @brief subtract scalar from v vector store result in dest (d = v - s)
X *
X * @param[in]  v    vector
X * @param[in]  s    scalar
X * @param[out] dest destination vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_subs(vec3 v, float s, vec3 dest) {
X  dest[0] = v[0] - s;
X  dest[1] = v[1] - s;
X  dest[2] = v[2] - s;
X}
X
X/*!
X * @brief multiply two vectors (component-wise multiplication)
X *
X * @param a    vector1
X * @param b    vector2
X * @param dest v3 = (a[0] * b[0], a[1] * b[1], a[2] * b[2])
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_mul(vec3 a, vec3 b, vec3 dest) {
X  dest[0] = a[0] * b[0];
X  dest[1] = a[1] * b[1];
X  dest[2] = a[2] * b[2];
X}
X
X/*!
X * @brief multiply/scale vec3 vector with scalar: result = v * s
X *
X * @param[in]  v    vector
X * @param[in]  s    scalar
X * @param[out] dest destination vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_scale(vec3 v, float s, vec3 dest) {
X  dest[0] = v[0] * s;
X  dest[1] = v[1] * s;
X  dest[2] = v[2] * s;
X}
X
X/*!
X * @brief make vec3 vector scale as specified: result = unit(v) * s
X *
X * @param[in]  v    vector
X * @param[in]  s    scalar
X * @param[out] dest destination vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_scale_as(vec3 v, float s, vec3 dest) {
X  float norm;
X  norm = glm_vec3_norm(v);
X
X  if (norm == 0.0f) {
X    glm_vec3_zero(dest);
X    return;
X  }
X
X  glm_vec3_scale(v, s / norm, dest);
X}
X
X/*!
X * @brief div vector with another component-wise division: d = a / b
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @param[out] dest result = (a[0]/b[0], a[1]/b[1], a[2]/b[2])
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_div(vec3 a, vec3 b, vec3 dest) {
X  dest[0] = a[0] / b[0];
X  dest[1] = a[1] / b[1];
X  dest[2] = a[2] / b[2];
X}
X
X/*!
X * @brief div vector with scalar: d = v / s
X *
X * @param[in]  v    vector
X * @param[in]  s    scalar
X * @param[out] dest result = (a[0]/s, a[1]/s, a[2]/s)
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_divs(vec3 v, float s, vec3 dest) {
X  dest[0] = v[0] / s;
X  dest[1] = v[1] / s;
X  dest[2] = v[2] / s;
X}
X
X/*!
X * @brief add two vectors and add result to sum
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @param[out] dest dest += (a + b)
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_addadd(vec3 a, vec3 b, vec3 dest) {
X  dest[0] += a[0] + b[0];
X  dest[1] += a[1] + b[1];
X  dest[2] += a[2] + b[2];
X}
X
X/*!
X * @brief sub two vectors and add result to dest
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @param[out] dest dest += (a + b)
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_subadd(vec3 a, vec3 b, vec3 dest) {
X  dest[0] += a[0] - b[0];
X  dest[1] += a[1] - b[1];
X  dest[2] += a[2] - b[2];
X}
X
X/*!
X * @brief mul two vectors and add result to dest
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @param[out] dest dest += (a * b)
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_muladd(vec3 a, vec3 b, vec3 dest) {
X  dest[0] += a[0] * b[0];
X  dest[1] += a[1] * b[1];
X  dest[2] += a[2] * b[2];
X}
X
X/*!
X * @brief mul vector with scalar and add result to sum
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector
X * @param[in]  s    scalar
X * @param[out] dest dest += (a * b)
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_muladds(vec3 a, float s, vec3 dest) {
X  dest[0] += a[0] * s;
X  dest[1] += a[1] * s;
X  dest[2] += a[2] * s;
X}
X
X/*!
X * @brief add max of two vectors to result/dest
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @param[out] dest dest += max(a, b)
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_maxadd(vec3 a, vec3 b, vec3 dest) {
X  dest[0] += glm_max(a[0], b[0]);
X  dest[1] += glm_max(a[1], b[1]);
X  dest[2] += glm_max(a[2], b[2]);
X}
X
X/*!
X * @brief add min of two vectors to result/dest
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @param[out] dest dest += min(a, b)
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_minadd(vec3 a, vec3 b, vec3 dest) {
X  dest[0] += glm_min(a[0], b[0]);
X  dest[1] += glm_min(a[1], b[1]);
X  dest[2] += glm_min(a[2], b[2]);
X}
X
X/*!
X * @brief sub two vectors and sub result to dest
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @param[out] dest dest -= (a - b)
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_subsub(vec3 a, vec3 b, vec3 dest) {
X  dest[0] -= a[0] - b[0];
X  dest[1] -= a[1] - b[1];
X  dest[2] -= a[2] - b[2];
X}
X
X/*!
X * @brief add two vectors and sub result to dest
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @param[out] dest dest -= (a + b)
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_addsub(vec3 a, vec3 b, vec3 dest) {
X  dest[0] -= a[0] + b[0];
X  dest[1] -= a[1] + b[1];
X  dest[2] -= a[2] + b[2];
X}
X
X/*!
X * @brief mul two vectors and sub result to dest
X *
X * it applies -= operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @param[out] dest dest -= (a * b)
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_mulsub(vec3 a, vec3 b, vec3 dest) {
X  dest[0] -= a[0] * b[0];
X  dest[1] -= a[1] * b[1];
X  dest[2] -= a[2] * b[2];
X}
X
X/*!
X * @brief mul vector with scalar and sub result to dest
X *
X * it applies -= operator so dest must be initialized
X *
X * @param[in]  a    vector
X * @param[in]  s    scalar
X * @param[out] dest dest -= (a * b)
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_mulsubs(vec3 a, float s, vec3 dest) {
X  dest[0] -= a[0] * s;
X  dest[1] -= a[1] * s;
X  dest[2] -= a[2] * s;
X}
X
X/*!
X * @brief sub max of two vectors to result/dest
X *
X * it applies -= operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @param[out] dest dest -= max(a, b)
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_maxsub(vec3 a, vec3 b, vec3 dest) {
X  dest[0] -= glm_max(a[0], b[0]);
X  dest[1] -= glm_max(a[1], b[1]);
X  dest[2] -= glm_max(a[2], b[2]);
X}
X
X/*!
X * @brief sub min of two vectors to result/dest
X *
X * it applies -= operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @param[out] dest dest -= min(a, b)
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_minsub(vec3 a, vec3 b, vec3 dest) {
X  dest[0] -= glm_min(a[0], b[0]);
X  dest[1] -= glm_min(a[1], b[1]);
X  dest[2] -= glm_min(a[2], b[2]);
X}
X
X/*!
X * @brief negate vector components and store result in dest
X *
X * @param[in]   v     vector
X * @param[out]  dest  result vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_negate_to(vec3 v, vec3 dest) {
X  dest[0] = -v[0];
X  dest[1] = -v[1];
X  dest[2] = -v[2];
X}
X
X/*!
X * @brief negate vector components
X *
X * @param[in, out]  v  vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_negate(vec3 v) {
X  glm_vec3_negate_to(v, v);
X}
X
X/*!
X * @brief normalize vec3 and store result in same vec
X *
X * @param[in, out] v vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_normalize(vec3 v) {
X  float norm;
X
X  norm = glm_vec3_norm(v);
X
X  if (norm == 0.0f) {
X    v[0] = v[1] = v[2] = 0.0f;
X    return;
X  }
X
X  glm_vec3_scale(v, 1.0f / norm, v);
X}
X
X/*!
X * @brief normalize vec3 to dest
X *
X * @param[in]  v    source
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_normalize_to(vec3 v, vec3 dest) {
X  float norm;
X
X  norm = glm_vec3_norm(v);
X
X  if (norm == 0.0f) {
X    glm_vec3_zero(dest);
X    return;
X  }
X
X  glm_vec3_scale(v, 1.0f / norm, dest);
X}
X
X/*!
X * @brief cross product of two vector (RH)
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_cross(vec3 a, vec3 b, vec3 dest) {
X  vec3 c;
X  /* (u2.v3 - u3.v2, u3.v1 - u1.v3, u1.v2 - u2.v1) */
X  c[0] = a[1] * b[2] - a[2] * b[1];
X  c[1] = a[2] * b[0] - a[0] * b[2];
X  c[2] = a[0] * b[1] - a[1] * b[0];
X  glm_vec3_copy(c, dest);
X}
X
X/*!
X * @brief cross product of two vector (RH) and normalize the result
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_crossn(vec3 a, vec3 b, vec3 dest) {
X  glm_vec3_cross(a, b, dest);
X  glm_vec3_normalize(dest);
X}
X
X/*!
X * @brief angle betwen two vector
X *
X * @param[in] a  vector1
X * @param[in] b  vector2
X *
X * @return angle as radians
X */
XCGLM_INLINE
Xfloat
Xglm_vec3_angle(vec3 a, vec3 b) {
X  float norm, dot;
X
X  /* maybe compiler generate approximation instruction (rcp) */
X  norm = 1.0f / (glm_vec3_norm(a) * glm_vec3_norm(b));
X  dot  = glm_vec3_dot(a, b) * norm;
X
X  if (dot > 1.0f)
X    return 0.0f;
X  else if (dot < -1.0f)
X    return CGLM_PI;
X
X  return acosf(dot);
X}
X
X/*!
X * @brief rotate vec3 around axis by angle using Rodrigues' rotation formula
X *
X * @param[in, out] v     vector
X * @param[in]      axis  axis vector (must be unit vector)
X * @param[in]      angle angle by radians
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_rotate(vec3 v, float angle, vec3 axis) {
X  vec3   v1, v2, k;
X  float  c, s;
X
X  c = cosf(angle);
X  s = sinf(angle);
X
X  glm_vec3_normalize_to(axis, k);
X
X  /* Right Hand, Rodrigues' rotation formula:
X        v = v*cos(t) + (kxv)sin(t) + k*(k.v)(1 - cos(t))
X   */
X  glm_vec3_scale(v, c, v1);
X
X  glm_vec3_cross(k, v, v2);
X  glm_vec3_scale(v2, s, v2);
X
X  glm_vec3_add(v1, v2, v1);
X
X  glm_vec3_scale(k, glm_vec3_dot(k, v) * (1.0f - c), v2);
X  glm_vec3_add(v1, v2, v);
X}
X
X/*!
X * @brief apply rotation matrix to vector
X *
X *  matrix format should be (no perspective):
X *   a  b  c  x
X *   e  f  g  y
X *   i  j  k  z
X *   0  0  0  w
X *
X * @param[in]  m    affine matrix or rot matrix
X * @param[in]  v    vector
X * @param[out] dest rotated vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_rotate_m4(mat4 m, vec3 v, vec3 dest) {
X  vec4 x, y, z, res;
X
X  glm_vec4_normalize_to(m[0], x);
X  glm_vec4_normalize_to(m[1], y);
X  glm_vec4_normalize_to(m[2], z);
X
X  glm_vec4_scale(x,   v[0], res);
X  glm_vec4_muladds(y, v[1], res);
X  glm_vec4_muladds(z, v[2], res);
X
X  glm_vec3(res, dest);
X}
X
X/*!
X * @brief apply rotation matrix to vector
X *
X * @param[in]  m    affine matrix or rot matrix
X * @param[in]  v    vector
X * @param[out] dest rotated vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_rotate_m3(mat3 m, vec3 v, vec3 dest) {
X  vec4 res, x, y, z;
X
X  glm_vec4(m[0], 0.0f, x);
X  glm_vec4(m[1], 0.0f, y);
X  glm_vec4(m[2], 0.0f, z);
X
X  glm_vec4_normalize(x);
X  glm_vec4_normalize(y);
X  glm_vec4_normalize(z);
X
X  glm_vec4_scale(x,   v[0], res);
X  glm_vec4_muladds(y, v[1], res);
X  glm_vec4_muladds(z, v[2], res);
X
X  glm_vec3(res, dest);
X}
X
X/*!
X * @brief project a vector onto b vector
X *
X * @param[in]  a    vector1
X * @param[in]  b    vector2
X * @param[out] dest projected vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_proj(vec3 a, vec3 b, vec3 dest) {
X  glm_vec3_scale(b,
X                 glm_vec3_dot(a, b) / glm_vec3_norm2(b),
X                 dest);
X}
X
X/**
X * @brief find center point of two vector
X *
X * @param[in]  a    vector1
X * @param[in]  b    vector2
X * @param[out] dest center point
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_center(vec3 a, vec3 b, vec3 dest) {
X  glm_vec3_add(a, b, dest);
X  glm_vec3_scale(dest, 0.5f, dest);
X}
X
X/**
X * @brief squared distance between two vectors
X *
X * @param[in] a vector1
X * @param[in] b vector2
X * @return returns squared distance (distance * distance)
X */
XCGLM_INLINE
Xfloat
Xglm_vec3_distance2(vec3 a, vec3 b) {
X  return glm_pow2(a[0] - b[0])
X       + glm_pow2(a[1] - b[1])
X       + glm_pow2(a[2] - b[2]);
X}
X
X/**
X * @brief distance between two vectors
X *
X * @param[in] a vector1
X * @param[in] b vector2
X * @return returns distance
X */
XCGLM_INLINE
Xfloat
Xglm_vec3_distance(vec3 a, vec3 b) {
X  return sqrtf(glm_vec3_distance2(a, b));
X}
X
X/*!
X * @brief max values of vectors
X *
X * @param[in]  a    vector1
X * @param[in]  b    vector2
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_maxv(vec3 a, vec3 b, vec3 dest) {
X  dest[0] = glm_max(a[0], b[0]);
X  dest[1] = glm_max(a[1], b[1]);
X  dest[2] = glm_max(a[2], b[2]);
X}
X
X/*!
X * @brief min values of vectors
X *
X * @param[in]  a    vector1
X * @param[in]  b    vector2
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_minv(vec3 a, vec3 b, vec3 dest) {
X  dest[0] = glm_min(a[0], b[0]);
X  dest[1] = glm_min(a[1], b[1]);
X  dest[2] = glm_min(a[2], b[2]);
X}
X
X/*!
X * @brief possible orthogonal/perpendicular vector
X *
X * @param[in]  v    vector
X * @param[out] dest orthogonal/perpendicular vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_ortho(vec3 v, vec3 dest) {
X  float ignore;
X  float f      = modff(fabsf(v[0]) + 0.5f, &ignore);
X  vec3  result = {-v[1], v[0] - f * v[2], f * v[1]};
X  glm_vec3_copy(result, dest);
X}
X
X/*!
X * @brief clamp vector's individual members between min and max values
X *
X * @param[in, out]  v      vector
X * @param[in]       minVal minimum value
X * @param[in]       maxVal maximum value
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_clamp(vec3 v, float minVal, float maxVal) {
X  v[0] = glm_clamp(v[0], minVal, maxVal);
X  v[1] = glm_clamp(v[1], minVal, maxVal);
X  v[2] = glm_clamp(v[2], minVal, maxVal);
X}
X
X/*!
X * @brief linear interpolation between two vectors
X *
X * formula:  from + s * (to - from)
X *
X * @param[in]   from from value
X * @param[in]   to   to value
X * @param[in]   t    interpolant (amount)
X * @param[out]  dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_lerp(vec3 from, vec3 to, float t, vec3 dest) {
X  vec3 s, v;
X
X  /* from + s * (to - from) */
X  glm_vec3_broadcast(t, s);
X  glm_vec3_sub(to, from, v);
X  glm_vec3_mul(s, v, v);
X  glm_vec3_add(from, v, dest);
X}
X
X/*!
X * @brief linear interpolation between two vectors (clamped)
X *
X * formula:  from + s * (to - from)
X *
X * @param[in]   from from value
X * @param[in]   to   to value
X * @param[in]   t    interpolant (amount) clamped between 0 and 1
X * @param[out]  dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_lerpc(vec3 from, vec3 to, float t, vec3 dest) {
X  glm_vec3_lerp(from, to, glm_clamp_zo(t), dest);
X}
X
X/*!
X * @brief linear interpolation between two vectors
X *
X * formula:  from + s * (to - from)
X *
X * @param[in]   from from value
X * @param[in]   to   to value
X * @param[in]   t    interpolant (amount)
X * @param[out]  dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_mix(vec3 from, vec3 to, float t, vec3 dest) {
X  glm_vec3_lerp(from, to, t, dest);
X}
X
X/*!
X * @brief linear interpolation between two vectors (clamped)
X *
X * formula:  from + s * (to - from)
X *
X * @param[in]   from from value
X * @param[in]   to   to value
X * @param[in]   t    interpolant (amount) clamped between 0 and 1
X * @param[out]  dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_mixc(vec3 from, vec3 to, float t, vec3 dest) {
X  glm_vec3_lerpc(from, to, t, dest);
X}
X
X/*!
X * @brief threshold function (unidimensional)
X *
X * @param[in]   edge    threshold
X * @param[in]   x       value to test against threshold
X * @param[out]  dest    destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_step_uni(float edge, vec3 x, vec3 dest) {
X  dest[0] = glm_step(edge, x[0]);
X  dest[1] = glm_step(edge, x[1]);
X  dest[2] = glm_step(edge, x[2]);
X}
X
X/*!
X * @brief threshold function
X *
X * @param[in]   edge    threshold
X * @param[in]   x       value to test against threshold
X * @param[out]  dest    destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_step(vec3 edge, vec3 x, vec3 dest) {
X  dest[0] = glm_step(edge[0], x[0]);
X  dest[1] = glm_step(edge[1], x[1]);
X  dest[2] = glm_step(edge[2], x[2]);
X}
X
X/*!
X * @brief threshold function with a smooth transition (unidimensional)
X *
X * @param[in]   edge0   low threshold
X * @param[in]   edge1   high threshold
X * @param[in]   x       value to test against threshold
X * @param[out]  dest    destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_smoothstep_uni(float edge0, float edge1, vec3 x, vec3 dest) {
X  dest[0] = glm_smoothstep(edge0, edge1, x[0]);
X  dest[1] = glm_smoothstep(edge0, edge1, x[1]);
X  dest[2] = glm_smoothstep(edge0, edge1, x[2]);
X}
X
X/*!
X * @brief threshold function with a smooth transition
X *
X * @param[in]   edge0   low threshold
X * @param[in]   edge1   high threshold
X * @param[in]   x       value to test against threshold
X * @param[out]  dest    destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_smoothstep(vec3 edge0, vec3 edge1, vec3 x, vec3 dest) {
X  dest[0] = glm_smoothstep(edge0[0], edge1[0], x[0]);
X  dest[1] = glm_smoothstep(edge0[1], edge1[1], x[1]);
X  dest[2] = glm_smoothstep(edge0[2], edge1[2], x[2]);
X}
X
X/*!
X * @brief smooth Hermite interpolation between two vectors
X *
X * formula:  from + s * (to - from)
X *
X * @param[in]   from from value
X * @param[in]   to   to value
X * @param[in]   t    interpolant (amount)
X * @param[out]  dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_smoothinterp(vec3 from, vec3 to, float t, vec3 dest) {
X  vec3 s, v;
X    
X  /* from + s * (to - from) */
X  glm_vec3_broadcast(glm_smooth(t), s);
X  glm_vec3_sub(to, from, v);
X  glm_vec3_mul(s, v, v);
X  glm_vec3_add(from, v, dest);
X}
X
X/*!
X * @brief smooth Hermite interpolation between two vectors (clamped)
X *
X * formula:  from + s * (to - from)
X *
X * @param[in]   from from value
X * @param[in]   to   to value
X * @param[in]   t    interpolant (amount) clamped between 0 and 1
X * @param[out]  dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_smoothinterpc(vec3 from, vec3 to, float t, vec3 dest) {
X  glm_vec3_smoothinterp(from, to, glm_clamp_zo(t), dest);
X}
X
X/*!
X * @brief swizzle vector components
X *
X * you can use existin masks e.g. GLM_XXX, GLM_ZYX
X *
X * @param[in]  v    source
X * @param[in]  mask mask
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_swizzle(vec3 v, int mask, vec3 dest) {
X  vec3 t;
X
X  t[0] = v[(mask & (3 << 0))];
X  t[1] = v[(mask & (3 << 2)) >> 2];
X  t[2] = v[(mask & (3 << 4)) >> 4];
X
X  glm_vec3_copy(t, dest);
X}
X
X/*!
X * @brief vec3 cross product
X *
X * this is just convenient wrapper
X *
X * @param[in]  a source 1
X * @param[in]  b source 2
X * @param[out] d destination
X */
XCGLM_INLINE
Xvoid
Xglm_cross(vec3 a, vec3 b, vec3 d) {
X  glm_vec3_cross(a, b, d);
X}
X
X/*!
X * @brief vec3 dot product
X *
X * this is just convenient wrapper
X *
X * @param[in] a vector1
X * @param[in] b vector2
X *
X * @return dot product
X */
XCGLM_INLINE
Xfloat
Xglm_dot(vec3 a, vec3 b) {
X  return glm_vec3_dot(a, b);
X}
X
X/*!
X * @brief normalize vec3 and store result in same vec
X *
X * this is just convenient wrapper
X *
X * @param[in, out] v vector
X */
XCGLM_INLINE
Xvoid
Xglm_normalize(vec3 v) {
X  glm_vec3_normalize(v);
X}
X
X/*!
X * @brief normalize vec3 to dest
X *
X * this is just convenient wrapper
X *
X * @param[in]  v    source
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_normalize_to(vec3 v, vec3 dest) {
X  glm_vec3_normalize_to(v, dest);
X}
X
X/*!
X * @brief Create three dimensional vector from pointer
X *
X * @param[in]  src  pointer to an array of floats
X * @param[out] dest destination vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_make(float * __restrict src, vec3 dest) {
X  dest[0] = src[0];
X  dest[1] = src[1];
X  dest[2] = src[2];
X}
X
X#endif /* cglm_vec3_h */
76cbf42507315cc0767578bd22730a73
echo x - cglm/vec3-ext.h
sed 's/^X//' >cglm/vec3-ext.h << 'f150e4549fb643679142d1675fcb0bf9'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*!
X * @brief SIMD like functions
X */
X
X/*
X Functions:
X   CGLM_INLINE void  glm_vec3_broadcast(float val, vec3 d);
X   CGLM_INLINE void  glm_vec3_fill(vec3 v, float val);
X   CGLM_INLINE bool  glm_vec3_eq(vec3 v, float val);
X   CGLM_INLINE bool  glm_vec3_eq_eps(vec3 v, float val);
X   CGLM_INLINE bool  glm_vec3_eq_all(vec3 v);
X   CGLM_INLINE bool  glm_vec3_eqv(vec3 a, vec3 b);
X   CGLM_INLINE bool  glm_vec3_eqv_eps(vec3 a, vec3 b);
X   CGLM_INLINE float glm_vec3_max(vec3 v);
X   CGLM_INLINE float glm_vec3_min(vec3 v);
X   CGLM_INLINE bool  glm_vec3_isnan(vec3 v);
X   CGLM_INLINE bool  glm_vec3_isinf(vec3 v);
X   CGLM_INLINE bool  glm_vec3_isvalid(vec3 v);
X   CGLM_INLINE void  glm_vec3_sign(vec3 v, vec3 dest);
X   CGLM_INLINE void  glm_vec3_abs(vec3 v, vec3 dest);
X   CGLM_INLINE void  glm_vec3_fract(vec3 v, vec3 dest);
X   CGLM_INLINE float glm_vec3_hadd(vec3 v);
X   CGLM_INLINE void  glm_vec3_sqrt(vec3 v, vec3 dest);
X */
X
X#ifndef cglm_vec3_ext_h
X#define cglm_vec3_ext_h
X
X#include "common.h"
X#include "util.h"
X
X/*!
X * @brief fill a vector with specified value
X *
X * @param[in]  val value
X * @param[out] d   dest
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_broadcast(float val, vec3 d) {
X  d[0] = d[1] = d[2] = val;
X}
X
X/*!
X * @brief fill a vector with specified value
X *
X * @param[out] v   dest
X * @param[in]  val value
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_fill(vec3 v, float val) {
X  v[0] = v[1] = v[2] = val;
X}
X
X/*!
X * @brief check if vector is equal to value (without epsilon)
X *
X * @param[in] v   vector
X * @param[in] val value
X */
XCGLM_INLINE
Xbool
Xglm_vec3_eq(vec3 v, float val) {
X  return v[0] == val && v[0] == v[1] && v[0] == v[2];
X}
X
X/*!
X * @brief check if vector is equal to value (with epsilon)
X *
X * @param[in] v   vector
X * @param[in] val value
X */
XCGLM_INLINE
Xbool
Xglm_vec3_eq_eps(vec3 v, float val) {
X  return fabsf(v[0] - val) <= GLM_FLT_EPSILON
X         && fabsf(v[1] - val) <= GLM_FLT_EPSILON
X         && fabsf(v[2] - val) <= GLM_FLT_EPSILON;
X}
X
X/*!
X * @brief check if vector members are equal (without epsilon)
X *
X * @param[in] v   vector
X */
XCGLM_INLINE
Xbool
Xglm_vec3_eq_all(vec3 v) {
X  return glm_vec3_eq_eps(v, v[0]);
X}
X
X/*!
X * @brief check if vector is equal to another (without epsilon)
X *
X * @param[in] a vector
X * @param[in] b vector
X */
XCGLM_INLINE
Xbool
Xglm_vec3_eqv(vec3 a, vec3 b) {
X  return a[0] == b[0]
X         && a[1] == b[1]
X         && a[2] == b[2];
X}
X
X/*!
X * @brief check if vector is equal to another (with epsilon)
X *
X * @param[in] a vector
X * @param[in] b vector
X */
XCGLM_INLINE
Xbool
Xglm_vec3_eqv_eps(vec3 a, vec3 b) {
X  return fabsf(a[0] - b[0]) <= GLM_FLT_EPSILON
X         && fabsf(a[1] - b[1]) <= GLM_FLT_EPSILON
X         && fabsf(a[2] - b[2]) <= GLM_FLT_EPSILON;
X}
X
X/*!
X * @brief max value of vector
X *
X * @param[in] v vector
X */
XCGLM_INLINE
Xfloat
Xglm_vec3_max(vec3 v) {
X  float max;
X
X  max = v[0];
X  if (v[1] > max)
X    max = v[1];
X  if (v[2] > max)
X    max = v[2];
X
X  return max;
X}
X
X/*!
X * @brief min value of vector
X *
X * @param[in] v vector
X */
XCGLM_INLINE
Xfloat
Xglm_vec3_min(vec3 v) {
X  float min;
X
X  min = v[0];
X  if (v[1] < min)
X    min = v[1];
X  if (v[2] < min)
X    min = v[2];
X
X  return min;
X}
X
X/*!
X * @brief check if all items are NaN (not a number)
X *        you should only use this in DEBUG mode or very critical asserts
X *
X * @param[in] v vector
X */
XCGLM_INLINE
Xbool
Xglm_vec3_isnan(vec3 v) {
X  return isnan(v[0]) || isnan(v[1]) || isnan(v[2]);
X}
X
X/*!
X * @brief check if all items are INFINITY
X *        you should only use this in DEBUG mode or very critical asserts
X *
X * @param[in] v vector
X */
XCGLM_INLINE
Xbool
Xglm_vec3_isinf(vec3 v) {
X  return isinf(v[0]) || isinf(v[1]) || isinf(v[2]);
X}
X
X/*!
X * @brief check if all items are valid number
X *        you should only use this in DEBUG mode or very critical asserts
X *
X * @param[in] v vector
X */
XCGLM_INLINE
Xbool
Xglm_vec3_isvalid(vec3 v) {
X  return !glm_vec3_isnan(v) && !glm_vec3_isinf(v);
X}
X
X/*!
X * @brief get sign of 32 bit float as +1, -1, 0
X *
X * Important: It returns 0 for zero/NaN input
X *
X * @param v vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_sign(vec3 v, vec3 dest) {
X  dest[0] = glm_signf(v[0]);
X  dest[1] = glm_signf(v[1]);
X  dest[2] = glm_signf(v[2]);
X}
X
X/*!
X * @brief absolute value of each vector item
X *
X * @param[in]  v    vector
X * @param[out] dest destination vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_abs(vec3 v, vec3 dest) {
X  dest[0] = fabsf(v[0]);
X  dest[1] = fabsf(v[1]);
X  dest[2] = fabsf(v[2]);
X}
X
X/*!
X * @brief fractional part of each vector item
X *
X * @param[in]  v    vector
X * @param[out] dest destination vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_fract(vec3 v, vec3 dest) {
X  dest[0] = fminf(v[0] - floorf(v[0]), 0.999999940395355224609375f);
X  dest[1] = fminf(v[1] - floorf(v[1]), 0.999999940395355224609375f);
X  dest[2] = fminf(v[2] - floorf(v[2]), 0.999999940395355224609375f);
X}
X
X/*!
X * @brief vector reduction by summation
X * @warning could overflow
X *
X * @param[in]  v    vector
X * @return     sum of all vector's elements
X */
XCGLM_INLINE
Xfloat
Xglm_vec3_hadd(vec3 v) {
X  return v[0] + v[1] + v[2];
X}
X
X/*!
X * @brief square root of each vector item
X *
X * @param[in]  v    vector
X * @param[out] dest destination vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec3_sqrt(vec3 v, vec3 dest) {
X  dest[0] = sqrtf(v[0]);
X  dest[1] = sqrtf(v[1]);
X  dest[2] = sqrtf(v[2]);
X}
X
X#endif /* cglm_vec3_ext_h */
f150e4549fb643679142d1675fcb0bf9
echo x - cglm/ivec3.h
sed 's/^X//' >cglm/ivec3.h << 'd6bb000f49fdeb547ca4e79dd809a4c8'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Macros:
X   GLM_IVEC3_ONE_INIT
X   GLM_IVEC3_ZERO_INIT
X   GLM_IVEC3_ONE
X   GLM_IVEC3_ZERO
X
X Functions:
X  CGLM_INLINE void glm_ivec3(ivec4 v4, ivec3 dest)
X  CGLM_INLINE void glm_ivec3_copy(ivec3 a, ivec3 dest)
X  CGLM_INLINE void glm_ivec3_zero(ivec3 v)
X  CGLM_INLINE void glm_ivec3_one(ivec3 v)
X  CGLM_INLINE void glm_ivec3_add(ivec3 a, ivec3 b, ivec3 dest)
X  CGLM_INLINE void glm_ivec3_adds(ivec3 v, int s, ivec3 dest)
X  CGLM_INLINE void glm_ivec3_sub(ivec3 a, ivec3 b, ivec3 dest)
X  CGLM_INLINE void glm_ivec3_subs(ivec3 v, int s, ivec3 dest)
X  CGLM_INLINE void glm_ivec3_mul(ivec3 a, ivec3 b, ivec3 dest)
X  CGLM_INLINE void glm_ivec3_scale(ivec3 v, int s, ivec3 dest)
X  CGLM_INLINE int glm_ivec3_distance2(ivec3 a, ivec3 b)
X  CGLM_INLINE float glm_ivec3_distance(ivec3 a, ivec3 b)
X  CGLM_INLINE void glm_ivec3_fill(ivec3 v, int val);
X  CGLM_INLINE bool glm_ivec3_eq(ivec3 v, int val);
X  CGLM_INLINE bool glm_ivec3_eqv(ivec3 a, ivec3 b);
X  CGLM_INLINE void glm_ivec3_maxv(ivec3 a, ivec3 b, ivec3 dest)
X  CGLM_INLINE void glm_ivec3_minv(ivec3 a, ivec3 b, ivec3 dest)
X  CGLM_INLINE void glm_ivec3_clamp(ivec3 v, int minVal, int maxVal)
X  CGLM_INLINE void glm_ivec3_abs(ivec3 v, ivec3 dest)
X */
X
X#ifndef cglm_ivec3_h
X#define cglm_ivec3_h
X
X#include "common.h"
X
X#define GLM_IVEC3_ONE_INIT   {1, 1, 1}
X#define GLM_IVEC3_ZERO_INIT  {0, 0, 0}
X
X#define GLM_IVEC3_ONE  ((ivec3)GLM_IVEC3_ONE_INIT)
X#define GLM_IVEC3_ZERO ((ivec3)GLM_IVEC3_ZERO_INIT)
X
X/*!
X * @brief init ivec3 using ivec4
X *
X * @param[in]  v4   vector4
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_ivec3(ivec4 v4, ivec3 dest) {
X  dest[0] = v4[0];
X  dest[1] = v4[1];
X  dest[2] = v4[2];
X}
X
X/*!
X * @brief copy all members of [a] to [dest]
X *
X * @param[in]  a    source vector
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_ivec3_copy(ivec3 a, ivec3 dest) {
X  dest[0] = a[0];
X  dest[1] = a[1];
X  dest[2] = a[2];
X}
X
X/*!
X * @brief set all members of [v] to zero
X *
X * @param[out] v vector
X */
XCGLM_INLINE
Xvoid 
Xglm_ivec3_zero(ivec3 v) {
X  v[0] = v[1] = v[2] = 0;
X}
X
X/*!
X * @brief set all members of [v] to one
X *
X * @param[out] v vector
X */
XCGLM_INLINE
Xvoid
Xglm_ivec3_one(ivec3 v) {
X  v[0] = v[1] = v[2] = 1;
X}
X
X/*!
X * @brief add vector [a] to vector [b] and store result in [dest]
X *
X * @param[in]  a    first vector
X * @param[in]  b    second vector
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_ivec3_add(ivec3 a, ivec3 b, ivec3 dest) {
X  dest[0] = a[0] + b[0];
X  dest[1] = a[1] + b[1];
X  dest[2] = a[2] + b[2];
X}
X
X/*!
X * @brief add scalar s to vector [v] and store result in [dest]
X *
X * @param[in]  v    vector
X * @param[in]  s    scalar
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_ivec3_adds(ivec3 v, int s, ivec3 dest) {
X  dest[0] = v[0] + s;
X  dest[1] = v[1] + s;
X  dest[2] = v[2] + s;
X}
X
X/*!
X * @brief subtract vector [b] from vector [a] and store result in [dest]
X *
X * @param[in]  a    first vector
X * @param[in]  b    second vector
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_ivec3_sub(ivec3 a, ivec3 b, ivec3 dest) {
X  dest[0] = a[0] - b[0];
X  dest[1] = a[1] - b[1];
X  dest[2] = a[2] - b[2];
X}
X
X/*!
X * @brief subtract scalar s from vector [v] and store result in [dest]
X *
X * @param[in]  v    vector
X * @param[in]  s    scalar
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_ivec3_subs(ivec3 v, int s, ivec3 dest) {
X  dest[0] = v[0] - s;
X  dest[1] = v[1] - s;
X  dest[2] = v[2] - s;
X}
X
X/*!
X * @brief multiply vector [a] with vector [b] and store result in [dest]
X *
X * @param[in]  a    frist vector
X * @param[in]  b    second vector
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_ivec3_mul(ivec3 a, ivec3 b, ivec3 dest) {
X  dest[0] = a[0] * b[0];
X  dest[1] = a[1] * b[1];
X  dest[2] = a[2] * b[2];
X}
X
X/*!
X * @brief multiply vector [a] with scalar s and store result in [dest]
X *
X * @param[in]  v    vector
X * @param[in]  s    scalar
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_ivec3_scale(ivec3 v, int s, ivec3 dest) {
X  dest[0] = v[0] * s;
X  dest[1] = v[1] * s;
X  dest[2] = v[2] * s;
X}
X
X/*!
X * @brief squared distance between two vectors
X *
X * @param[in] a first vector
X * @param[in] b second vector
X * @return returns squared distance (distance * distance)
X */
XCGLM_INLINE
Xint
Xglm_ivec3_distance2(ivec3 a, ivec3 b) {
X  int xd, yd, zd;
X  xd = a[0] - b[0];
X  yd = a[1] - b[1];
X  zd = a[2] - b[2];
X  return xd * xd + yd * yd + zd * zd;
X}
X
X/*!
X * @brief distance between two vectors
X *
X * @param[in] a first vector
X * @param[in] b second vector
X * @return returns distance
X */
XCGLM_INLINE
Xfloat
Xglm_ivec3_distance(ivec3 a, ivec3 b) {
X  return sqrtf((float)glm_ivec3_distance2(a, b));
X}
X
X/*!
X * @brief fill a vector with specified value
X *
X * @param[out] v   dest
X * @param[in]  val value
X */
XCGLM_INLINE
Xvoid
Xglm_ivec3_fill(ivec3 v, int val) {
X  v[0] = v[1] = v[2] = val;
X}
X
X/*!
X * @brief check if vector is equal to value
X *
X * @param[in] v   vector
X * @param[in] val value
X */
XCGLM_INLINE
Xbool
Xglm_ivec3_eq(ivec3 v, int val) {
X  return v[0] == val && v[0] == v[1] && v[0] == v[2];
X}
X
X/*!
X * @brief check if vector is equal to another
X *
X * @param[in] a vector
X * @param[in] b vector
X */
XCGLM_INLINE
Xbool
Xglm_ivec3_eqv(ivec3 a, ivec3 b) {
X  return a[0] == b[0]
X         && a[1] == b[1]
X         && a[2] == b[2];
X}
X
X/*!
X * @brief set each member of dest to greater of vector a and b
X *
X * @param[in]  a    first vector
X * @param[in]  b    second vector
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_ivec3_maxv(ivec3 a, ivec3 b, ivec3 dest) {
X  dest[0] = a[0] > b[0] ? a[0] : b[0];
X  dest[1] = a[1] > b[1] ? a[1] : b[1];
X  dest[2] = a[2] > b[2] ? a[2] : b[2];
X}
X
X/*!
X * @brief set each member of dest to lesser of vector a and b
X *
X * @param[in]  a    first vector
X * @param[in]  b    second vector
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_ivec3_minv(ivec3 a, ivec3 b, ivec3 dest) {
X  dest[0] = a[0] < b[0] ? a[0] : b[0];
X  dest[1] = a[1] < b[1] ? a[1] : b[1];
X  dest[2] = a[2] < b[2] ? a[2] : b[2];
X}
X
X/*!
X * @brief clamp each member of [v] between minVal and maxVal (inclusive)
X *
X * @param[in, out] v      vector
X * @param[in]      minVal minimum value
X * @param[in]      maxVal maximum value
X */
XCGLM_INLINE
Xvoid
Xglm_ivec3_clamp(ivec3 v, int minVal, int maxVal) {
X  if (v[0] < minVal)
X    v[0] = minVal;
X  else if(v[0] > maxVal)
X    v[0] = maxVal;
X
X  if (v[1] < minVal)
X    v[1] = minVal;
X  else if(v[1] > maxVal)
X    v[1] = maxVal;
X
X  if (v[2] < minVal)
X    v[2] = minVal;
X  else if(v[2] > maxVal)
X    v[2] = maxVal;
X}
X
X/*!
X * @brief absolute value of v
X *
X * @param[in]	v	vector
X * @param[out]	dest	destination
X */
XCGLM_INLINE
Xvoid
Xglm_ivec3_abs(ivec3 v, ivec3 dest) {
X  dest[0] = abs(v[0]);
X  dest[1] = abs(v[1]);
X  dest[2] = abs(v[2]);
X}
X
X#endif /* cglm_ivec3_h */
d6bb000f49fdeb547ca4e79dd809a4c8
echo x - cglm/vec4.h
sed 's/^X//' >cglm/vec4.h << '9f2417491b5e5a040ac88f1bc6f078aa'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Macros:
X   GLM_VEC4_ONE_INIT
X   GLM_VEC4_BLACK_INIT
X   GLM_VEC4_ZERO_INIT
X   GLM_VEC4_ONE
X   GLM_VEC4_BLACK
X   GLM_VEC4_ZERO
X
X Functions:
X   CGLM_INLINE void  glm_vec4(vec3 v3, float last, vec4 dest);
X   CGLM_INLINE void  glm_vec4_copy3(vec4 a, vec3 dest);
X   CGLM_INLINE void  glm_vec4_copy(vec4 v, vec4 dest);
X   CGLM_INLINE void  glm_vec4_ucopy(vec4 v, vec4 dest);
X   CGLM_INLINE float glm_vec4_dot(vec4 a, vec4 b);
X   CGLM_INLINE float glm_vec4_norm2(vec4 v);
X   CGLM_INLINE float glm_vec4_norm(vec4 v);
X   CGLM_INLINE float glm_vec4_norm_one(vec4 v);
X   CGLM_INLINE float glm_vec4_norm_inf(vec4 v);
X   CGLM_INLINE void  glm_vec4_add(vec4 a, vec4 b, vec4 dest);
X   CGLM_INLINE void  glm_vec4_adds(vec4 v, float s, vec4 dest);
X   CGLM_INLINE void  glm_vec4_sub(vec4 a, vec4 b, vec4 dest);
X   CGLM_INLINE void  glm_vec4_subs(vec4 v, float s, vec4 dest);
X   CGLM_INLINE void  glm_vec4_mul(vec4 a, vec4 b, vec4 dest);
X   CGLM_INLINE void  glm_vec4_scale(vec4 v, float s, vec4 dest);
X   CGLM_INLINE void  glm_vec4_scale_as(vec4 v, float s, vec4 dest);
X   CGLM_INLINE void  glm_vec4_div(vec4 a, vec4 b, vec4 dest);
X   CGLM_INLINE void  glm_vec4_divs(vec4 v, float s, vec4 dest);
X   CGLM_INLINE void  glm_vec4_addadd(vec4 a, vec4 b, vec4 dest);
X   CGLM_INLINE void  glm_vec4_subadd(vec4 a, vec4 b, vec4 dest);
X   CGLM_INLINE void  glm_vec4_muladd(vec4 a, vec4 b, vec4 dest);
X   CGLM_INLINE void  glm_vec4_muladds(vec4 a, float s, vec4 dest);
X   CGLM_INLINE void  glm_vec4_maxadd(vec4 a, vec4 b, vec4 dest);
X   CGLM_INLINE void  glm_vec4_minadd(vec4 a, vec4 b, vec4 dest);
X   CGLM_INLINE void  glm_vec4_subsub(vec4 a, vec4 b, vec4 dest);
X   CGLM_INLINE void  glm_vec4_addsub(vec4 a, vec4 b, vec4 dest);
X   CGLM_INLINE void  glm_vec4_mulsub(vec4 a, vec4 b, vec4 dest);
X   CGLM_INLINE void  glm_vec4_mulsubs(vec4 a, float s, vec4 dest);
X   CGLM_INLINE void  glm_vec4_maxsub(vec4 a, vec4 b, vec4 dest);
X   CGLM_INLINE void  glm_vec4_minsub(vec4 a, vec4 b, vec4 dest);
X   CGLM_INLINE void  glm_vec4_negate(vec4 v);
X   CGLM_INLINE void  glm_vec4_inv(vec4 v);
X   CGLM_INLINE void  glm_vec4_inv_to(vec4 v, vec4 dest);
X   CGLM_INLINE void  glm_vec4_normalize(vec4 v);
X   CGLM_INLINE void  glm_vec4_normalize_to(vec4 vec, vec4 dest);
X   CGLM_INLINE float glm_vec4_distance(vec4 a, vec4 b);
X   CGLM_INLINE float glm_vec4_distance2(vec4 a, vec4 b);
X   CGLM_INLINE void  glm_vec4_maxv(vec4 a, vec4 b, vec4 dest);
X   CGLM_INLINE void  glm_vec4_minv(vec4 a, vec4 b, vec4 dest);
X   CGLM_INLINE void  glm_vec4_clamp(vec4 v, float minVal, float maxVal);
X   CGLM_INLINE void  glm_vec4_lerp(vec4 from, vec4 to, float t, vec4 dest);
X   CGLM_INLINE void  glm_vec4_lerpc(vec4 from, vec4 to, float t, vec4 dest);
X   CGLM_INLINE void  glm_vec4_step_uni(float edge, vec4 x, vec4 dest);
X   CGLM_INLINE void  glm_vec4_step(vec4 edge, vec4 x, vec4 dest);
X   CGLM_INLINE void  glm_vec4_smoothstep_uni(float edge0, float edge1, vec4 x, vec4 dest);
X   CGLM_INLINE void  glm_vec4_smoothstep(vec4 edge0, vec4 edge1, vec4 x, vec4 dest);
X   CGLM_INLINE void  glm_vec4_smoothinterp(vec4 from, vec4 to, float t, vec4 dest);
X   CGLM_INLINE void  glm_vec4_smoothinterpc(vec4 from, vec4 to, float t, vec4 dest);
X   CGLM_INLINE void  glm_vec4_swizzle(vec4 v, int mask, vec4 dest);
X   CGLM_INLINE void  glm_vec4_make(float * restrict src, vec4 dest);
X
X DEPRECATED:
X   glm_vec4_dup
X   glm_vec4_flipsign
X   glm_vec4_flipsign_to
X   glm_vec4_inv
X   glm_vec4_inv_to
X   glm_vec4_mulv
X */
X
X#ifndef cglm_vec4_h
X#define cglm_vec4_h
X
X#include "common.h"
X#include "vec4-ext.h"
X#include "util.h"
X
X/* DEPRECATED! functions */
X#define glm_vec4_dup3(v, dest)         glm_vec4_copy3(v, dest)
X#define glm_vec4_dup(v, dest)          glm_vec4_copy(v, dest)
X#define glm_vec4_flipsign(v)           glm_vec4_negate(v)
X#define glm_vec4_flipsign_to(v, dest)  glm_vec4_negate_to(v, dest)
X#define glm_vec4_inv(v)                glm_vec4_negate(v)
X#define glm_vec4_inv_to(v, dest)       glm_vec4_negate_to(v, dest)
X#define glm_vec4_mulv(a, b, d)         glm_vec4_mul(a, b, d)
X
X#define GLM_VEC4_ONE_INIT   {1.0f, 1.0f, 1.0f, 1.0f}
X#define GLM_VEC4_BLACK_INIT {0.0f, 0.0f, 0.0f, 1.0f}
X#define GLM_VEC4_ZERO_INIT  {0.0f, 0.0f, 0.0f, 0.0f}
X
X#define GLM_VEC4_ONE        ((vec4)GLM_VEC4_ONE_INIT)
X#define GLM_VEC4_BLACK      ((vec4)GLM_VEC4_BLACK_INIT)
X#define GLM_VEC4_ZERO       ((vec4)GLM_VEC4_ZERO_INIT)
X
X#define GLM_XXXX GLM_SHUFFLE4(0, 0, 0, 0)
X#define GLM_YYYY GLM_SHUFFLE4(1, 1, 1, 1)
X#define GLM_ZZZZ GLM_SHUFFLE4(2, 2, 2, 2)
X#define GLM_WWWW GLM_SHUFFLE4(3, 3, 3, 3)
X#define GLM_WZYX GLM_SHUFFLE4(0, 1, 2, 3)
X
X/*!
X * @brief init vec4 using vec3
X *
X * @param[in]  v3   vector3
X * @param[in]  last last item
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec4(vec3 v3, float last, vec4 dest) {
X  dest[0] = v3[0];
X  dest[1] = v3[1];
X  dest[2] = v3[2];
X  dest[3] = last;
X}
X
X/*!
X * @brief copy first 3 members of [a] to [dest]
X *
X * @param[in]  a    source
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_copy3(vec4 a, vec3 dest) {
X  dest[0] = a[0];
X  dest[1] = a[1];
X  dest[2] = a[2];
X}
X
X/*!
X * @brief copy all members of [a] to [dest]
X *
X * @param[in]  v    source
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_copy(vec4 v, vec4 dest) {
X#if defined(__wasm__) && defined(__wasm_simd128__)
X  glmm_store(dest, glmm_load(v));
X#elif defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(dest, glmm_load(v));
X#elif defined(CGLM_NEON_FP)
X  vst1q_f32(dest, vld1q_f32(v));
X#else
X  dest[0] = v[0];
X  dest[1] = v[1];
X  dest[2] = v[2];
X  dest[3] = v[3];
X#endif
X}
X
X/*!
X * @brief copy all members of [a] to [dest]
X *
X * alignment is not required
X *
X * @param[in]  v    source
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_ucopy(vec4 v, vec4 dest) {
X#if defined(__wasm__) && defined(__wasm_simd128__)
X  /* note here wasm v128.load/v128.store support unaligned loads and stores */
X  wasm_v128_store(dest, wasm_v128_load(v));
X#else
X  dest[0] = v[0];
X  dest[1] = v[1];
X  dest[2] = v[2];
X  dest[3] = v[3];
X#endif
X}
X
X/*!
X * @brief make vector zero
X *
X * @param[in, out]  v vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_zero(vec4 v) {
X#if defined(__wasm__) && defined(__wasm_simd128__)
X  glmm_store(v, wasm_f32x4_const_splat(0.f));
X#elif defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(v, _mm_setzero_ps());
X#elif defined(CGLM_NEON_FP)
X  vst1q_f32(v, vdupq_n_f32(0.0f));
X#else
X  v[0] = 0.0f;
X  v[1] = 0.0f;
X  v[2] = 0.0f;
X  v[3] = 0.0f;
X#endif
X}
X
X/*!
X * @brief make vector one
X *
X * @param[in, out]  v vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_one(vec4 v) {
X#if defined(__wasm__) && defined(__wasm_simd128__)
X  glmm_store(v, wasm_f32x4_const_splat(1.0f));
X#elif defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(v, _mm_set1_ps(1.0f));
X#elif defined(CGLM_NEON_FP)
X  vst1q_f32(v, vdupq_n_f32(1.0f));
X#else
X  v[0] = 1.0f;
X  v[1] = 1.0f;
X  v[2] = 1.0f;
X  v[3] = 1.0f;
X#endif
X}
X
X/*!
X * @brief vec4 dot product
X *
X * @param[in] a vector1
X * @param[in] b vector2
X *
X * @return dot product
X */
XCGLM_INLINE
Xfloat
Xglm_vec4_dot(vec4 a, vec4 b) {
X#if defined(CGLM_SIMD)
X  return glmm_dot(glmm_load(a), glmm_load(b));
X#else
X  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
X#endif
X}
X
X/*!
X * @brief norm * norm (magnitude) of vec
X *
X * we can use this func instead of calling norm * norm, because it would call
X * sqrtf fuction twice but with this func we can avoid func call, maybe this is
X * not good name for this func
X *
X * @param[in] v vec4
X *
X * @return norm * norm
X */
XCGLM_INLINE
Xfloat
Xglm_vec4_norm2(vec4 v) {
X  return glm_vec4_dot(v, v);
X}
X
X/*!
X * @brief euclidean norm (magnitude), also called L2 norm
X *        this will give magnitude of vector in euclidean space
X *
X * @param[in] v vector
X *
X * @return norm
X */
XCGLM_INLINE
Xfloat
Xglm_vec4_norm(vec4 v) {
X#if defined(CGLM_SIMD)
X  return glmm_norm(glmm_load(v));
X#else
X  return sqrtf(glm_vec4_dot(v, v));
X#endif
X}
X
X/*!
X * @brief L1 norm of vec4
X * Also known as Manhattan Distance or Taxicab norm.
X * L1 Norm is the sum of the magnitudes of the vectors in a space.
X * It is calculated as the sum of the absolute values of the vector components.
X * In this norm, all the components of the vector are weighted equally.
X *
X * This computes:
X * L1 norm = |v[0]| + |v[1]| + |v[2]| + |v[3]|
X *
X * @param[in] v vector
X *
X * @return L1 norm
X */
XCGLM_INLINE
Xfloat
Xglm_vec4_norm_one(vec4 v) {
X#if defined(CGLM_SIMD)
X  return glmm_norm_one(glmm_load(v));
X#else
X  vec4 t;
X  glm_vec4_abs(v, t);
X  return glm_vec4_hadd(t);
X#endif
X}
X
X/*!
X * @brief infinity norm of vec4
X * Also known as Maximum norm.
X * Infinity Norm is the largest magnitude among each element of a vector.
X * It is calculated as the maximum of the absolute values of the vector components.
X *
X * This computes:
X * inf norm = max(|v[0]|, |v[1]|, |v[2]|, |v[3]|)
X *
X * @param[in] v vector
X *
X * @return infinity norm
X */
XCGLM_INLINE
Xfloat
Xglm_vec4_norm_inf(vec4 v) {
X#if defined(CGLM_SIMD)
X  return glmm_norm_inf(glmm_load(v));
X#else
X  vec4 t;
X  glm_vec4_abs(v, t);
X  return glm_vec4_max(t);
X#endif
X}
X
X/*!
X * @brief add b vector to a vector store result in dest
X *
X * @param[in]  a    vector1
X * @param[in]  b    vector2
X * @param[out] dest destination vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_add(vec4 a, vec4 b, vec4 dest) {
X#if defined(__wasm__) && defined(__wasm_simd128__)
X  glmm_store(dest, wasm_f32x4_add(glmm_load(a), glmm_load(b)));
X#elif defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(dest, _mm_add_ps(glmm_load(a), glmm_load(b)));
X#elif defined(CGLM_NEON_FP)
X  vst1q_f32(dest, vaddq_f32(vld1q_f32(a), vld1q_f32(b)));
X#else
X  dest[0] = a[0] + b[0];
X  dest[1] = a[1] + b[1];
X  dest[2] = a[2] + b[2];
X  dest[3] = a[3] + b[3];
X#endif
X}
X
X/*!
X * @brief add scalar to v vector store result in dest (d = v + vec(s))
X *
X * @param[in]  v    vector
X * @param[in]  s    scalar
X * @param[out] dest destination vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_adds(vec4 v, float s, vec4 dest) {
X#if defined(__wasm__) && defined(__wasm_simd128__)
X  glmm_store(dest, wasm_f32x4_add(glmm_load(v), wasm_f32x4_splat(s)));
X#elif defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(dest, _mm_add_ps(glmm_load(v), _mm_set1_ps(s)));
X#elif defined(CGLM_NEON_FP)
X  vst1q_f32(dest, vaddq_f32(vld1q_f32(v), vdupq_n_f32(s)));
X#else
X  dest[0] = v[0] + s;
X  dest[1] = v[1] + s;
X  dest[2] = v[2] + s;
X  dest[3] = v[3] + s;
X#endif
X}
X
X/*!
X * @brief subtract b vector from a vector store result in dest (d = a - b)
X *
X * @param[in]  a    vector1
X * @param[in]  b    vector2
X * @param[out] dest destination vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_sub(vec4 a, vec4 b, vec4 dest) {
X#if defined(__wasm__) && defined(__wasm_simd128__)
X  glmm_store(dest, wasm_f32x4_sub(glmm_load(a), glmm_load(b)));
X#elif defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(dest, _mm_sub_ps(glmm_load(a), glmm_load(b)));
X#elif defined(CGLM_NEON_FP)
X  vst1q_f32(dest, vsubq_f32(vld1q_f32(a), vld1q_f32(b)));
X#else
X  dest[0] = a[0] - b[0];
X  dest[1] = a[1] - b[1];
X  dest[2] = a[2] - b[2];
X  dest[3] = a[3] - b[3];
X#endif
X}
X
X/*!
X * @brief subtract scalar from v vector store result in dest (d = v - vec(s))
X *
X * @param[in]  v    vector
X * @param[in]  s    scalar
X * @param[out] dest destination vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_subs(vec4 v, float s, vec4 dest) {
X#if defined(__wasm__) && defined(__wasm_simd128__)
X  glmm_store(dest, wasm_f32x4_sub(glmm_load(v), wasm_f32x4_splat(s)));
X#elif defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(dest, _mm_sub_ps(glmm_load(v), _mm_set1_ps(s)));
X#elif defined(CGLM_NEON_FP)
X  vst1q_f32(dest, vsubq_f32(vld1q_f32(v), vdupq_n_f32(s)));
X#else
X  dest[0] = v[0] - s;
X  dest[1] = v[1] - s;
X  dest[2] = v[2] - s;
X  dest[3] = v[3] - s;
X#endif
X}
X
X/*!
X * @brief multiply two vectors (component-wise multiplication)
X *
X * @param a    vector1
X * @param b    vector2
X * @param dest dest = (a[0] * b[0], a[1] * b[1], a[2] * b[2], a[3] * b[3])
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_mul(vec4 a, vec4 b, vec4 dest) {
X#if defined(__wasm__) && defined(__wasm_simd128__)
X  glmm_store(dest, wasm_f32x4_mul(glmm_load(a), glmm_load(b)));
X#elif defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(dest, _mm_mul_ps(glmm_load(a), glmm_load(b)));
X#elif defined(CGLM_NEON_FP)
X  vst1q_f32(dest, vmulq_f32(vld1q_f32(a), vld1q_f32(b)));
X#else
X  dest[0] = a[0] * b[0];
X  dest[1] = a[1] * b[1];
X  dest[2] = a[2] * b[2];
X  dest[3] = a[3] * b[3];
X#endif
X}
X
X/*!
X * @brief multiply/scale vec4 vector with scalar: result = v * s
X *
X * @param[in]  v    vector
X * @param[in]  s    scalar
X * @param[out] dest destination vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_scale(vec4 v, float s, vec4 dest) {
X#if defined(__wasm__) && defined(__wasm_simd128__)
X  glmm_store(dest, wasm_f32x4_mul(glmm_load(v), wasm_f32x4_splat(s)));
X#elif defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(dest, _mm_mul_ps(glmm_load(v), _mm_set1_ps(s)));
X#elif defined(CGLM_NEON_FP)
X  vst1q_f32(dest, vmulq_f32(vld1q_f32(v), vdupq_n_f32(s)));
X#else
X  dest[0] = v[0] * s;
X  dest[1] = v[1] * s;
X  dest[2] = v[2] * s;
X  dest[3] = v[3] * s;
X#endif
X}
X
X/*!
X * @brief make vec4 vector scale as specified: result = unit(v) * s
X *
X * @param[in]  v    vector
X * @param[in]  s    scalar
X * @param[out] dest destination vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_scale_as(vec4 v, float s, vec4 dest) {
X  float norm;
X  norm = glm_vec4_norm(v);
X
X  if (norm == 0.0f) {
X    glm_vec4_zero(dest);
X    return;
X  }
X
X  glm_vec4_scale(v, s / norm, dest);
X}
X
X/*!
X * @brief div vector with another component-wise division: d = a / b
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @param[out] dest result = (a[0]/b[0], a[1]/b[1], a[2]/b[2], a[3]/b[3])
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_div(vec4 a, vec4 b, vec4 dest) {
X#if defined(CGLM_SIMD)
X  glmm_store(dest, glmm_div(glmm_load(a), glmm_load(b)));
X#else
X  dest[0] = a[0] / b[0];
X  dest[1] = a[1] / b[1];
X  dest[2] = a[2] / b[2];
X  dest[3] = a[3] / b[3];
X#endif
X}
X
X/*!
X * @brief div vec4 vector with scalar: d = v / s
X *
X * @param[in]  v    vector
X * @param[in]  s    scalar
X * @param[out] dest destination vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_divs(vec4 v, float s, vec4 dest) {
X#if defined(__wasm__) && defined(__wasm_simd128__)
X  glmm_store(dest, wasm_f32x4_div(glmm_load(v), wasm_f32x4_splat(s)));
X#elif defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(dest, _mm_div_ps(glmm_load(v), _mm_set1_ps(s)));
X#else
X  glm_vec4_scale(v, 1.0f / s, dest);
X#endif
X}
X
X/*!
X * @brief add two vectors and add result to sum
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @param[out] dest dest += (a + b)
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_addadd(vec4 a, vec4 b, vec4 dest) {
X#if defined(__wasm__) && defined(__wasm_simd128__)
X  glmm_store(dest, wasm_f32x4_add(
X          glmm_load(dest),
X          wasm_f32x4_add(glmm_load(a), glmm_load(b))));
X#elif defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(dest, _mm_add_ps(glmm_load(dest),
X                              _mm_add_ps(glmm_load(a),
X                                         glmm_load(b))));
X#elif defined(CGLM_NEON_FP)
X  vst1q_f32(dest, vaddq_f32(vld1q_f32(dest),
X                            vaddq_f32(vld1q_f32(a),
X                                      vld1q_f32(b))));
X#else
X  dest[0] += a[0] + b[0];
X  dest[1] += a[1] + b[1];
X  dest[2] += a[2] + b[2];
X  dest[3] += a[3] + b[3];
X#endif
X}
X
X/*!
X * @brief sub two vectors and add result to dest
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @param[out] dest dest += (a - b)
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_subadd(vec4 a, vec4 b, vec4 dest) {
X#if defined(__wasm__) && defined(__wasm_simd128__)
X  glmm_store(dest, wasm_f32x4_add(
X          glmm_load(dest),
X          wasm_f32x4_sub(glmm_load(a), glmm_load(b))));
X#elif defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(dest, _mm_add_ps(glmm_load(dest),
X                              _mm_sub_ps(glmm_load(a),
X                                         glmm_load(b))));
X#elif defined(CGLM_NEON_FP)
X  vst1q_f32(dest, vaddq_f32(vld1q_f32(dest),
X                            vsubq_f32(vld1q_f32(a),
X                                      vld1q_f32(b))));
X#else
X  dest[0] += a[0] - b[0];
X  dest[1] += a[1] - b[1];
X  dest[2] += a[2] - b[2];
X  dest[3] += a[3] - b[3];
X#endif
X}
X
X/*!
X * @brief mul two vectors and add result to dest
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @param[out] dest dest += (a * b)
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_muladd(vec4 a, vec4 b, vec4 dest) {
X#if defined(CGLM_SIMD)
X  glmm_store(dest, glmm_fmadd(glmm_load(a), glmm_load(b), glmm_load(dest)));
X#else
X  dest[0] += a[0] * b[0];
X  dest[1] += a[1] * b[1];
X  dest[2] += a[2] * b[2];
X  dest[3] += a[3] * b[3];
X#endif
X}
X
X/*!
X * @brief mul vector with scalar and add result to sum
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector
X * @param[in]  s    scalar
X * @param[out] dest dest += (a * b)
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_muladds(vec4 a, float s, vec4 dest) {
X#if defined(CGLM_SIMD)
X  glmm_store(dest, glmm_fmadd(glmm_load(a), glmm_set1(s), glmm_load(dest)));
X#else
X  dest[0] += a[0] * s;
X  dest[1] += a[1] * s;
X  dest[2] += a[2] * s;
X  dest[3] += a[3] * s;
X#endif
X}
X
X/*!
X * @brief add max of two vectors to result/dest
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @param[out] dest dest += max(a, b)
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_maxadd(vec4 a, vec4 b, vec4 dest) {
X#if defined(__wasm__) && defined(__wasm_simd128__)
X  glmm_store(dest, wasm_f32x4_add(
X          glmm_load(dest),
X          wasm_f32x4_pmax(glmm_load(a), glmm_load(b))));
X#elif defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(dest, _mm_add_ps(glmm_load(dest),
X                              _mm_max_ps(glmm_load(a),
X                                         glmm_load(b))));
X#elif defined(CGLM_NEON_FP)
X  vst1q_f32(dest, vaddq_f32(vld1q_f32(dest),
X                            vmaxq_f32(vld1q_f32(a),
X                                      vld1q_f32(b))));
X#else
X  dest[0] += glm_max(a[0], b[0]);
X  dest[1] += glm_max(a[1], b[1]);
X  dest[2] += glm_max(a[2], b[2]);
X  dest[3] += glm_max(a[3], b[3]);
X#endif
X}
X
X/*!
X * @brief add min of two vectors to result/dest
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @param[out] dest dest += min(a, b)
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_minadd(vec4 a, vec4 b, vec4 dest) {
X#if defined(__wasm__) && defined(__wasm_simd128__)
X  glmm_store(dest, wasm_f32x4_add(
X          glmm_load(dest),
X          wasm_f32x4_pmin(glmm_load(a), glmm_load(b))));
X#elif defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(dest, _mm_add_ps(glmm_load(dest),
X                              _mm_min_ps(glmm_load(a),
X                                         glmm_load(b))));
X#elif defined(CGLM_NEON_FP)
X  vst1q_f32(dest, vaddq_f32(vld1q_f32(dest),
X                            vminq_f32(vld1q_f32(a),
X                                      vld1q_f32(b))));
X#else
X  dest[0] += glm_min(a[0], b[0]);
X  dest[1] += glm_min(a[1], b[1]);
X  dest[2] += glm_min(a[2], b[2]);
X  dest[3] += glm_min(a[3], b[3]);
X#endif
X}
X
X/*!
X * @brief sub two vectors and sub result to dest
X *
X * it applies -= operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @param[out] dest dest -= (a - b)
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_subsub(vec4 a, vec4 b, vec4 dest) {
X#if defined(__wasm__) && defined(__wasm_simd128__)
X  glmm_store(dest, wasm_f32x4_sub(
X          glmm_load(dest),
X          wasm_f32x4_sub(glmm_load(a), glmm_load(b))));
X#elif defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(dest, _mm_sub_ps(glmm_load(dest),
X                              _mm_sub_ps(glmm_load(a),
X                                         glmm_load(b))));
X#elif defined(CGLM_NEON_FP)
X  vst1q_f32(dest, vsubq_f32(vld1q_f32(dest),
X                            vsubq_f32(vld1q_f32(a),
X                                      vld1q_f32(b))));
X#else
X  dest[0] -= a[0] - b[0];
X  dest[1] -= a[1] - b[1];
X  dest[2] -= a[2] - b[2];
X  dest[3] -= a[3] - b[3];
X#endif
X}
X
X/*!
X * @brief add two vectors and sub result to dest
X *
X * it applies -= operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @param[out] dest dest -= (a + b)
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_addsub(vec4 a, vec4 b, vec4 dest) {
X#if defined(__wasm__) && defined(__wasm_simd128__)
X  glmm_store(dest, wasm_f32x4_sub(
X          glmm_load(dest),
X          wasm_f32x4_add(glmm_load(a), glmm_load(b))));
X#elif defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(dest, _mm_sub_ps(glmm_load(dest),
X                              _mm_add_ps(glmm_load(a),
X                                         glmm_load(b))));
X#elif defined(CGLM_NEON_FP)
X  vst1q_f32(dest, vsubq_f32(vld1q_f32(dest),
X                            vaddq_f32(vld1q_f32(a),
X                                      vld1q_f32(b))));
X#else
X  dest[0] -= a[0] + b[0];
X  dest[1] -= a[1] + b[1];
X  dest[2] -= a[2] + b[2];
X  dest[3] -= a[3] + b[3];
X#endif
X}
X
X/*!
X * @brief mul two vectors and sub result to dest
X *
X * it applies -= operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @param[out] dest dest -= (a * b)
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_mulsub(vec4 a, vec4 b, vec4 dest) {
X#if defined(CGLM_SIMD)
X  glmm_store(dest, glmm_fnmadd(glmm_load(a), glmm_load(b), glmm_load(dest)));
X#else
X  dest[0] -= a[0] * b[0];
X  dest[1] -= a[1] * b[1];
X  dest[2] -= a[2] * b[2];
X  dest[3] -= a[3] * b[3];
X#endif
X}
X
X/*!
X * @brief mul vector with scalar and sub result to dest
X *
X * it applies -= operator so dest must be initialized
X *
X * @param[in]  a    vector
X * @param[in]  s    scalar
X * @param[out] dest dest -= (a * b)
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_mulsubs(vec4 a, float s, vec4 dest) {
X#if defined(CGLM_SIMD)
X  glmm_store(dest, glmm_fnmadd(glmm_load(a), glmm_set1(s), glmm_load(dest)));
X#else
X  dest[0] -= a[0] * s;
X  dest[1] -= a[1] * s;
X  dest[2] -= a[2] * s;
X  dest[3] -= a[3] * s;
X#endif
X}
X
X/*!
X * @brief sub max of two vectors to dest
X *
X * it applies -= operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @param[out] dest dest -= max(a, b)
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_maxsub(vec4 a, vec4 b, vec4 dest) {
X#if defined(__wasm__) && defined(__wasm_simd128__)
X  glmm_store(dest, wasm_f32x4_sub(
X          glmm_load(dest),
X          wasm_f32x4_pmax(glmm_load(a), glmm_load(b))));
X#elif defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(dest, _mm_sub_ps(glmm_load(dest),
X                              _mm_max_ps(glmm_load(a),
X                                         glmm_load(b))));
X#elif defined(CGLM_NEON_FP)
X  vst1q_f32(dest, vsubq_f32(vld1q_f32(dest),
X                            vmaxq_f32(vld1q_f32(a),
X                                      vld1q_f32(b))));
X#else
X  dest[0] -= glm_max(a[0], b[0]);
X  dest[1] -= glm_max(a[1], b[1]);
X  dest[2] -= glm_max(a[2], b[2]);
X  dest[3] -= glm_max(a[3], b[3]);
X#endif
X}
X
X/*!
X * @brief sub min of two vectors to dest
X *
X * it applies -= operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @param[out] dest dest -= min(a, b)
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_minsub(vec4 a, vec4 b, vec4 dest) {
X#if defined(__wasm__) && defined(__wasm_simd128__)
X  glmm_store(dest, wasm_f32x4_sub(
X          glmm_load(dest),
X          wasm_f32x4_pmin(glmm_load(a), glmm_load(b))));
X#elif defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(dest, _mm_sub_ps(glmm_load(dest),
X                              _mm_min_ps(glmm_load(a),
X                                         glmm_load(b))));
X#elif defined(CGLM_NEON_FP)
X  vst1q_f32(dest, vsubq_f32(vld1q_f32(dest),
X                            vminq_f32(vld1q_f32(a),
X                                      vld1q_f32(b))));
X#else
X  dest[0] -= glm_min(a[0], b[0]);
X  dest[1] -= glm_min(a[1], b[1]);
X  dest[2] -= glm_min(a[2], b[2]);
X  dest[3] -= glm_min(a[3], b[3]);
X#endif
X}
X
X/*!
X * @brief negate vector components and store result in dest
X *
X * @param[in]  v     vector
X * @param[out] dest  result vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_negate_to(vec4 v, vec4 dest) {
X#if defined(__wasm__) && defined(__wasm_simd128__)
X  glmm_store(dest, wasm_f32x4_neg(glmm_load(v)));
X#elif defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(dest, _mm_xor_ps(glmm_load(v), glmm_float32x4_SIGNMASK_NEG));
X#elif defined(CGLM_NEON_FP)
X  vst1q_f32(dest, vnegq_f32(vld1q_f32(v)));
X#else
X  dest[0] = -v[0];
X  dest[1] = -v[1];
X  dest[2] = -v[2];
X  dest[3] = -v[3];
X#endif
X}
X
X/*!
X * @brief flip sign of all vec4 members
X *
X * @param[in, out]  v  vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_negate(vec4 v) {
X  glm_vec4_negate_to(v, v);
X}
X
X/*!
X * @brief normalize vec4 to dest
X *
X * @param[in]  v    source
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_normalize_to(vec4 v, vec4 dest) {
X#if defined(__wasm__) && defined(__wasm_simd128__)
X  glmm_128 xdot, x0;
X  float  dot;
X
X  x0   = glmm_load(v);
X  xdot = glmm_vdot(x0, x0);
X  /* dot  = _mm_cvtss_f32(xdot); */
X  dot  = wasm_f32x4_extract_lane(xdot, 0);
X
X  if (dot == 0.0f) {
X    glmm_store(dest, wasm_f32x4_const_splat(0.f));
X    return;
X  }
X
X  glmm_store(dest, wasm_f32x4_div(x0, wasm_f32x4_sqrt(xdot)));
X#elif defined( __SSE__ ) || defined( __SSE2__ )
X  __m128 xdot, x0;
X  float  dot;
X
X  x0   = glmm_load(v);
X  xdot = glmm_vdot(x0, x0);
X  dot  = _mm_cvtss_f32(xdot);
X
X  if (dot == 0.0f) {
X    glmm_store(dest, _mm_setzero_ps());
X    return;
X  }
X
X  glmm_store(dest, _mm_div_ps(x0, _mm_sqrt_ps(xdot)));
X#else
X  float norm;
X
X  norm = glm_vec4_norm(v);
X
X  if (norm == 0.0f) {
X    glm_vec4_zero(dest);
X    return;
X  }
X
X  glm_vec4_scale(v, 1.0f / norm, dest);
X#endif
X}
X
X/*!
X * @brief normalize vec4 and store result in same vec
X *
X * @param[in, out] v vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_normalize(vec4 v) {
X  glm_vec4_normalize_to(v, v);
X}
X
X/**
X * @brief distance between two vectors
X *
X * @param[in] a vector1
X * @param[in] b vector2
X * @return returns distance
X */
XCGLM_INLINE
Xfloat
Xglm_vec4_distance(vec4 a, vec4 b) {
X#if defined(__wasm__) && defined(__wasm_simd128__)
X  return glmm_norm(wasm_f32x4_sub(glmm_load(a), glmm_load(b)));
X#elif defined( __SSE__ ) || defined( __SSE2__ )
X  return glmm_norm(_mm_sub_ps(glmm_load(a), glmm_load(b)));
X#elif defined(CGLM_NEON_FP)
X  return glmm_norm(vsubq_f32(glmm_load(a), glmm_load(b)));
X#else
X  return sqrtf(glm_pow2(a[0] - b[0])
X             + glm_pow2(a[1] - b[1])
X             + glm_pow2(a[2] - b[2])
X             + glm_pow2(a[3] - b[3]));
X#endif
X}
X
X/**
X * @brief squared distance between two vectors
X *
X * @param[in] a vector1
X * @param[in] b vector2
X * @return returns squared distance
X */
XCGLM_INLINE
Xfloat
Xglm_vec4_distance2(vec4 a, vec4 b) {
X#if defined(__wasm__) && defined(__wasm_simd128__)
X  return glmm_norm2(wasm_f32x4_sub(glmm_load(a), glmm_load(b)));
X#elif defined( __SSE__ ) || defined( __SSE2__ )
X  return glmm_norm2(_mm_sub_ps(glmm_load(a), glmm_load(b)));
X#elif defined(CGLM_NEON_FP)
X  return glmm_norm2(vsubq_f32(glmm_load(a), glmm_load(b)));
X#else
X  return glm_pow2(a[0] - b[0])
X       + glm_pow2(a[1] - b[1])
X       + glm_pow2(a[2] - b[2])
X       + glm_pow2(a[3] - b[3]);
X#endif
X}
X
X/*!
X * @brief max values of vectors
X *
X * @param[in]  a    vector1
X * @param[in]  b    vector2
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_maxv(vec4 a, vec4 b, vec4 dest) {
X#if defined(__wasm__) && defined(__wasm_simd128__)
X  glmm_store(dest, wasm_f32x4_pmax(glmm_load(a), glmm_load(b)));
X#elif defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(dest, _mm_max_ps(glmm_load(a), glmm_load(b)));
X#elif defined(CGLM_NEON_FP)
X  vst1q_f32(dest, vmaxq_f32(vld1q_f32(a), vld1q_f32(b)));
X#else
X  dest[0] = glm_max(a[0], b[0]);
X  dest[1] = glm_max(a[1], b[1]);
X  dest[2] = glm_max(a[2], b[2]);
X  dest[3] = glm_max(a[3], b[3]);
X#endif
X}
X
X/*!
X * @brief min values of vectors
X *
X * @param[in]  a    vector1
X * @param[in]  b    vector2
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_minv(vec4 a, vec4 b, vec4 dest) {
X#if defined(__wasm__) && defined(__wasm_simd128__)
X  glmm_store(dest, wasm_f32x4_pmin(glmm_load(a), glmm_load(b)));
X#elif defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(dest, _mm_min_ps(glmm_load(a), glmm_load(b)));
X#elif defined(CGLM_NEON_FP)
X  vst1q_f32(dest, vminq_f32(vld1q_f32(a), vld1q_f32(b)));
X#else
X  dest[0] = glm_min(a[0], b[0]);
X  dest[1] = glm_min(a[1], b[1]);
X  dest[2] = glm_min(a[2], b[2]);
X  dest[3] = glm_min(a[3], b[3]);
X#endif
X}
X
X/*!
X * @brief clamp vector's individual members between min and max values
X *
X * @param[in, out]  v      vector
X * @param[in]       minVal minimum value
X * @param[in]       maxVal maximum value
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_clamp(vec4 v, float minVal, float maxVal) {
X#if defined(__wasm__) && defined(__wasm_simd128__)
X  glmm_store(v, wasm_f32x4_pmin(
X          wasm_f32x4_pmax(glmm_load(v), wasm_f32x4_splat(minVal)),
X          wasm_f32x4_splat(maxVal)));
X#elif defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(v, _mm_min_ps(_mm_max_ps(glmm_load(v), _mm_set1_ps(minVal)),
X                           _mm_set1_ps(maxVal)));
X#elif defined(CGLM_NEON_FP)
X  vst1q_f32(v, vminq_f32(vmaxq_f32(vld1q_f32(v), vdupq_n_f32(minVal)),
X                         vdupq_n_f32(maxVal)));
X#else
X  v[0] = glm_clamp(v[0], minVal, maxVal);
X  v[1] = glm_clamp(v[1], minVal, maxVal);
X  v[2] = glm_clamp(v[2], minVal, maxVal);
X  v[3] = glm_clamp(v[3], minVal, maxVal);
X#endif
X}
X
X/*!
X * @brief linear interpolation between two vectors
X *
X * formula:  from + t * (to - from)
X *
X * @param[in]   from from value
X * @param[in]   to   to value
X * @param[in]   t    interpolant (amount)
X * @param[out]  dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_lerp(vec4 from, vec4 to, float t, vec4 dest) {
X  vec4 s, v;
X
X  /* from + s * (to - from) */
X  glm_vec4_broadcast(t, s);
X  glm_vec4_sub(to, from, v);
X  glm_vec4_mul(s, v, v);
X  glm_vec4_add(from, v, dest);
X}
X
X/*!
X * @brief linear interpolation between two vectors (clamped)
X *
X * formula:  from + t * (to - from)
X *
X * @param[in]   from from value
X * @param[in]   to   to value
X * @param[in]   t    interpolant (amount) clamped between 0 and 1
X * @param[out]  dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_lerpc(vec4 from, vec4 to, float t, vec4 dest) {
X  glm_vec4_lerp(from, to, glm_clamp_zo(t), dest);
X}
X
X/*!
X * @brief linear interpolation between two vectors
X *
X * formula:  from + t * (to - from)
X *
X * @param[in]   from from value
X * @param[in]   to   to value
X * @param[in]   t    interpolant (amount)
X * @param[out]  dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_mix(vec4 from, vec4 to, float t, vec4 dest) {
X  glm_vec4_lerp(from, to, t, dest);
X}
X
X/*!
X * @brief linear interpolation between two vectors (clamped)
X *
X * formula:  from + t * (to - from)
X *
X * @param[in]   from from value
X * @param[in]   to   to value
X * @param[in]   t    interpolant (amount) clamped between 0 and 1
X * @param[out]  dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_mixc(vec4 from, vec4 to, float t, vec4 dest) {
X  glm_vec4_lerpc(from, to, t, dest);
X}
X
X/*!
X * @brief threshold function (unidimensional)
X *
X * @param[in]   edge    threshold
X * @param[in]   x       value to test against threshold
X * @param[out]  dest    destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_step_uni(float edge, vec4 x, vec4 dest) {
X  dest[0] = glm_step(edge, x[0]);
X  dest[1] = glm_step(edge, x[1]);
X  dest[2] = glm_step(edge, x[2]);
X  dest[3] = glm_step(edge, x[3]);
X}
X
X/*!
X * @brief threshold function
X *
X * @param[in]   edge    threshold
X * @param[in]   x       value to test against threshold
X * @param[out]  dest    destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_step(vec4 edge, vec4 x, vec4 dest) {
X  dest[0] = glm_step(edge[0], x[0]);
X  dest[1] = glm_step(edge[1], x[1]);
X  dest[2] = glm_step(edge[2], x[2]);
X  dest[3] = glm_step(edge[3], x[3]);
X}
X
X/*!
X * @brief threshold function with a smooth transition (unidimensional)
X *
X * @param[in]   edge0   low threshold
X * @param[in]   edge1   high threshold
X * @param[in]   x       value to test against threshold
X * @param[out]  dest    destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_smoothstep_uni(float edge0, float edge1, vec4 x, vec4 dest) {
X  dest[0] = glm_smoothstep(edge0, edge1, x[0]);
X  dest[1] = glm_smoothstep(edge0, edge1, x[1]);
X  dest[2] = glm_smoothstep(edge0, edge1, x[2]);
X  dest[3] = glm_smoothstep(edge0, edge1, x[3]);
X}
X
X/*!
X * @brief threshold function with a smooth transition
X *
X * @param[in]   edge0   low threshold
X * @param[in]   edge1   high threshold
X * @param[in]   x       value to test against threshold
X * @param[out]  dest    destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_smoothstep(vec4 edge0, vec4 edge1, vec4 x, vec4 dest) {
X  dest[0] = glm_smoothstep(edge0[0], edge1[0], x[0]);
X  dest[1] = glm_smoothstep(edge0[1], edge1[1], x[1]);
X  dest[2] = glm_smoothstep(edge0[2], edge1[2], x[2]);
X  dest[3] = glm_smoothstep(edge0[3], edge1[3], x[3]);
X}
X
X/*!
X * @brief smooth Hermite interpolation between two vectors
X *
X * formula:  t^2 * (3 - 2*t)
X *
X * @param[in]   from    from value
X * @param[in]   to      to value
X * @param[in]   t       interpolant (amount)
X * @param[out]  dest    destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_smoothinterp(vec4 from, vec4 to, float t, vec4 dest) {
X  vec4 s, v;
X    
X  /* from + smoothstep * (to - from) */
X  glm_vec4_broadcast(glm_smooth(t), s);
X  glm_vec4_sub(to, from, v);
X  glm_vec4_mul(s, v, v);
X  glm_vec4_add(from, v, dest);
X}
X
X/*!
X * @brief smooth Hermite interpolation between two vectors (clamped)
X *
X * formula:  t^2 * (3 - 2*t)
X *
X * @param[in]   from    from value
X * @param[in]   to      to value
X * @param[in]   t       interpolant (amount) clamped between 0 and 1
X * @param[out]  dest    destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_smoothinterpc(vec4 from, vec4 to, float t, vec4 dest) {
X  glm_vec4_smoothinterp(from, to, glm_clamp_zo(t), dest);
X}
X
X/*!
X * @brief helper to fill vec4 as [S^3, S^2, S, 1]
X *
X * @param[in]   s    parameter
X * @param[out]  dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_cubic(float s, vec4 dest) {
X  float ss;
X
X  ss = s * s;
X
X  dest[0] = ss * s;
X  dest[1] = ss;
X  dest[2] = s;
X  dest[3] = 1.0f;
X}
X
X/*!
X * @brief swizzle vector components
X *
X * you can use existin masks e.g. GLM_XXXX, GLM_WZYX
X *
X * @param[in]  v    source
X * @param[in]  mask mask
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_swizzle(vec4 v, int mask, vec4 dest) {
X  vec4 t;
X
X  t[0] = v[(mask & (3 << 0))];
X  t[1] = v[(mask & (3 << 2)) >> 2];
X  t[2] = v[(mask & (3 << 4)) >> 4];
X  t[3] = v[(mask & (3 << 6)) >> 6];
X
X  glm_vec4_copy(t, dest);
X}
X
X/*!
X * @brief Create four dimensional vector from pointer
X *
X * @param[in]  src  pointer to an array of floats
X * @param[out] dest destination vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_make(float * __restrict src, vec4 dest) {
X  dest[0] = src[0]; dest[1] = src[1];
X  dest[2] = src[2]; dest[3] = src[3];
X}
X
X#endif /* cglm_vec4_h */
9f2417491b5e5a040ac88f1bc6f078aa
echo x - cglm/vec4-ext.h
sed 's/^X//' >cglm/vec4-ext.h << '85518fed09ce9f135b6e077bd4b391e3'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*!
X * @brief SIMD like functions
X */
X
X/*
X Functions:
X   CGLM_INLINE void  glm_vec4_broadcast(float val, vec4 d);
X   CGLM_INLINE void  glm_vec4_fill(vec4 v, float val);
X   CGLM_INLINE bool  glm_vec4_eq(vec4 v, float val);
X   CGLM_INLINE bool  glm_vec4_eq_eps(vec4 v, float val);
X   CGLM_INLINE bool  glm_vec4_eq_all(vec4 v);
X   CGLM_INLINE bool  glm_vec4_eqv(vec4 a, vec4 b);
X   CGLM_INLINE bool  glm_vec4_eqv_eps(vec4 a, vec4 b);
X   CGLM_INLINE float glm_vec4_max(vec4 v);
X   CGLM_INLINE float glm_vec4_min(vec4 v);
X   CGLM_INLINE bool  glm_vec4_isnan(vec4 v);
X   CGLM_INLINE bool  glm_vec4_isinf(vec4 v);
X   CGLM_INLINE bool  glm_vec4_isvalid(vec4 v);
X   CGLM_INLINE void  glm_vec4_sign(vec4 v, vec4 dest);
X   CGLM_INLINE void  glm_vec4_abs(vec4 v, vec4 dest);
X   CGLM_INLINE void  glm_vec4_fract(vec4 v, vec4 dest);
X   CGLM_INLINE float glm_vec4_hadd(vec4 v);
X   CGLM_INLINE void  glm_vec4_sqrt(vec4 v, vec4 dest);
X */
X
X#ifndef cglm_vec4_ext_h
X#define cglm_vec4_ext_h
X
X#include "common.h"
X#include "vec3-ext.h"
X
X/*!
X * @brief fill a vector with specified value
X *
X * @param val value
X * @param d   dest
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_broadcast(float val, vec4 d) {
X#if defined(__wasm__) && defined(__wasm_simd128__)
X  glmm_store(d, wasm_f32x4_splat(val));
X#elif defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(d, _mm_set1_ps(val));
X#else
X  d[0] = d[1] = d[2] = d[3] = val;
X#endif
X}
X
X/*!
X * @brief fill a vector with specified value
X *
X * @param v   dest
X * @param val value
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_fill(vec4 v, float val) {
X#if defined(__wasm__) && defined(__wasm_simd128__)
X  glmm_store(v, wasm_f32x4_splat(val));
X#elif defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(v, _mm_set1_ps(val));
X#else
X  v[0] = v[1] = v[2] = v[3] = val;
X#endif
X}
X
X/*!
X * @brief check if vector is equal to value (without epsilon)
X *
X * @param v   vector
X * @param val value
X */
XCGLM_INLINE
Xbool
Xglm_vec4_eq(vec4 v, float val) {
X  return v[0] == val
X         && v[0] == v[1]
X         && v[0] == v[2]
X         && v[0] == v[3];
X}
X
X/*!
X * @brief check if vector is equal to value (with epsilon)
X *
X * @param v   vector
X * @param val value
X */
XCGLM_INLINE
Xbool
Xglm_vec4_eq_eps(vec4 v, float val) {
X  return fabsf(v[0] - val) <= GLM_FLT_EPSILON
X         && fabsf(v[1] - val) <= GLM_FLT_EPSILON
X         && fabsf(v[2] - val) <= GLM_FLT_EPSILON
X         && fabsf(v[3] - val) <= GLM_FLT_EPSILON;
X}
X
X/*!
X * @brief check if vector members are equal (without epsilon)
X *
X * @param v   vector
X */
XCGLM_INLINE
Xbool
Xglm_vec4_eq_all(vec4 v) {
X  return glm_vec4_eq_eps(v, v[0]);
X}
X
X/*!
X * @brief check if vector is equal to another (without epsilon)
X *
X * @param a vector
X * @param b vector
X */
XCGLM_INLINE
Xbool
Xglm_vec4_eqv(vec4 a, vec4 b) {
X  return a[0] == b[0]
X         && a[1] == b[1]
X         && a[2] == b[2]
X         && a[3] == b[3];
X}
X
X/*!
X * @brief check if vector is equal to another (with epsilon)
X *
X * @param a vector
X * @param b vector
X */
XCGLM_INLINE
Xbool
Xglm_vec4_eqv_eps(vec4 a, vec4 b) {
X  return fabsf(a[0] - b[0]) <= GLM_FLT_EPSILON
X         && fabsf(a[1] - b[1]) <= GLM_FLT_EPSILON
X         && fabsf(a[2] - b[2]) <= GLM_FLT_EPSILON
X         && fabsf(a[3] - b[3]) <= GLM_FLT_EPSILON;
X}
X
X/*!
X * @brief max value of vector
X *
X * @param v vector
X */
XCGLM_INLINE
Xfloat
Xglm_vec4_max(vec4 v) {
X  float max;
X
X  max = glm_vec3_max(v);
X  if (v[3] > max)
X    max = v[3];
X
X  return max;
X}
X
X/*!
X * @brief min value of vector
X *
X * @param v vector
X */
XCGLM_INLINE
Xfloat
Xglm_vec4_min(vec4 v) {
X  float min;
X
X  min = glm_vec3_min(v);
X  if (v[3] < min)
X    min = v[3];
X
X  return min;
X}
X
X/*!
X * @brief check if one of items is NaN (not a number)
X *        you should only use this in DEBUG mode or very critical asserts
X *
X * @param[in] v vector
X */
XCGLM_INLINE
Xbool
Xglm_vec4_isnan(vec4 v) {
X  return isnan(v[0]) || isnan(v[1]) || isnan(v[2]) || isnan(v[3]);
X}
X
X/*!
X * @brief check if one of items is INFINITY
X *        you should only use this in DEBUG mode or very critical asserts
X *
X * @param[in] v vector
X */
XCGLM_INLINE
Xbool
Xglm_vec4_isinf(vec4 v) {
X  return isinf(v[0]) || isinf(v[1]) || isinf(v[2]) || isinf(v[3]);
X}
X
X/*!
X * @brief check if all items are valid number
X *        you should only use this in DEBUG mode or very critical asserts
X *
X * @param[in] v vector
X */
XCGLM_INLINE
Xbool
Xglm_vec4_isvalid(vec4 v) {
X  return !glm_vec4_isnan(v) && !glm_vec4_isinf(v);
X}
X
X/*!
X * @brief get sign of 32 bit float as +1, -1, 0
X *
X * Important: It returns 0 for zero/NaN input
X *
X * @param v vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_sign(vec4 v, vec4 dest) {
X#if defined( __SSE__ ) || defined( __SSE2__ )
X  __m128 x0, x1, x2, x3, x4;
X
X  x0 = glmm_load(v);
X  x1 = _mm_set_ps(0.0f, 0.0f, 1.0f, -1.0f);
X  x2 = glmm_splat(x1, 2);
X
X  x3 = _mm_and_ps(_mm_cmpgt_ps(x0, x2), glmm_splat(x1, 1));
X  x4 = _mm_and_ps(_mm_cmplt_ps(x0, x2), glmm_splat(x1, 0));
X
X  glmm_store(dest, _mm_or_ps(x3, x4));
X#else
X  dest[0] = glm_signf(v[0]);
X  dest[1] = glm_signf(v[1]);
X  dest[2] = glm_signf(v[2]);
X  dest[3] = glm_signf(v[3]);
X#endif
X}
X
X/*!
X * @brief absolute value of each vector item
X *
X * @param[in]  v    vector
X * @param[out] dest destination vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_abs(vec4 v, vec4 dest) {
X#if defined(__wasm__) && defined(__wasm_simd128__)
X  glmm_store(dest, glmm_abs(glmm_load(v)));
X#elif defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(dest, glmm_abs(glmm_load(v)));
X#elif defined(CGLM_NEON_FP)
X  vst1q_f32(dest, vabsq_f32(vld1q_f32(v)));
X#else
X  dest[0] = fabsf(v[0]);
X  dest[1] = fabsf(v[1]);
X  dest[2] = fabsf(v[2]);
X  dest[3] = fabsf(v[3]);
X#endif
X}
X
X/*!
X * @brief fractional part of each vector item
X *
X * @param[in]  v    vector
X * @param[out] dest destination vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_fract(vec4 v, vec4 dest) {
X  dest[0] = fminf(v[0] - floorf(v[0]), 0.999999940395355224609375f);
X  dest[1] = fminf(v[1] - floorf(v[1]), 0.999999940395355224609375f);
X  dest[2] = fminf(v[2] - floorf(v[2]), 0.999999940395355224609375f);
X  dest[3] = fminf(v[3] - floorf(v[3]), 0.999999940395355224609375f);
X}
X
X/*!
X * @brief vector reduction by summation
X * @warning could overflow
X *
X * @param[in]   v    vector
X * @return      sum of all vector's elements
X */
XCGLM_INLINE
Xfloat
Xglm_vec4_hadd(vec4 v) {
X#if defined(__wasm__) && defined(__wasm_simd128__)
X  return glmm_hadd(glmm_load(v));
X#elif defined( __SSE__ ) || defined( __SSE2__ )
X  return glmm_hadd(glmm_load(v));
X#else
X  return v[0] + v[1] + v[2] + v[3];
X#endif
X}
X
X/*!
X * @brief square root of each vector item
X *
X * @param[in]  v    vector
X * @param[out] dest destination vector
X */
XCGLM_INLINE
Xvoid
Xglm_vec4_sqrt(vec4 v, vec4 dest) {
X#if defined(__wasm__) && defined(__wasm_simd128__)
X  glmm_store(dest, wasm_f32x4_sqrt(glmm_load(v)));
X#elif defined( __SSE__ ) || defined( __SSE2__ )
X  glmm_store(dest, _mm_sqrt_ps(glmm_load(v)));
X#else
X  dest[0] = sqrtf(v[0]);
X  dest[1] = sqrtf(v[1]);
X  dest[2] = sqrtf(v[2]);
X  dest[3] = sqrtf(v[3]);
X#endif
X}
X
X#endif /* cglm_vec4_ext_h */
85518fed09ce9f135b6e077bd4b391e3
echo x - cglm/ivec4.h
sed 's/^X//' >cglm/ivec4.h << '618946c8aba0876291f05b5ef37e08d1'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Macros:
X   GLM_IVEC4_ONE_INIT
X   GLM_IVEC4_ZERO_INIT
X   GLM_IVEC4_ONE
X   GLM_IVEC4_ZERO
X
X Functions:
X  CGLM_INLINE void glm_ivec4(ivec3 v3, int last, ivec4 dest)
X  CGLM_INLINE void glm_ivec4_copy(ivec4 a, ivec4 dest)
X  CGLM_INLINE void glm_ivec4_zero(ivec4 v)
X  CGLM_INLINE void glm_ivec4_one(ivec4 v)
X  CGLM_INLINE void glm_ivec4_add(ivec4 a, ivec4 b, ivec4 dest)
X  CGLM_INLINE void glm_ivec4_adds(ivec4 v, int s, ivec4 dest)
X  CGLM_INLINE void glm_ivec4_sub(ivec4 a, ivec4 b, ivec4 dest)
X  CGLM_INLINE void glm_ivec4_subs(ivec4 v, int s, ivec4 dest)
X  CGLM_INLINE void glm_ivec4_mul(ivec4 a, ivec4 b, ivec4 dest)
X  CGLM_INLINE void glm_ivec4_scale(ivec4 v, int s, ivec4 dest)
X  CGLM_INLINE int glm_ivec4_distance2(ivec4 a, ivec4 b)
X  CGLM_INLINE float glm_ivec4_distance(ivec4 a, ivec4 b)
X  CGLM_INLINE void glm_ivec4_maxv(ivec4 a, ivec4 b, ivec4 dest)
X  CGLM_INLINE void glm_ivec4_minv(ivec4 a, ivec4 b, ivec4 dest)
X  CGLM_INLINE void glm_ivec4_clamp(ivec4 v, int minVal, int maxVal)
X  CGLM_INLINE void glm_ivec4_abs(ivec4 v, ivec4 dest)
X */
X
X#ifndef cglm_ivec4_h
X#define cglm_ivec4_h
X
X#include "common.h"
X
X#define GLM_IVEC4_ONE_INIT   {1, 1, 1, 1}
X#define GLM_IVEC4_ZERO_INIT  {0, 0, 0, 0}
X
X#define GLM_IVEC4_ONE  ((ivec4)GLM_IVEC4_ONE_INIT)
X#define GLM_IVEC4_ZERO ((ivec4)GLM_IVEC4_ZERO_INIT)
X
X/*!
X * @brief init ivec4 using ivec3
X *
X * @param[in]  v3   vector3
X * @param[in]  last last item
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_ivec4(ivec3 v3, int last, ivec4 dest) {
X  dest[0] = v3[0];
X  dest[1] = v3[1];
X  dest[2] = v3[2];
X  dest[3] = last;
X}
X
X/*!
X * @brief copy all members of [a] to [dest]
X *
X * @param[in]  a    source vector
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_ivec4_copy(ivec4 a, ivec4 dest) {
X  dest[0] = a[0];
X  dest[1] = a[1];
X  dest[2] = a[2];
X  dest[3] = a[3];
X}
X
X/*!
X * @brief set all members of [v] to zero
X *
X * @param[out] v vector
X */
XCGLM_INLINE
Xvoid 
Xglm_ivec4_zero(ivec4 v) {
X  v[0] = v[1] = v[2] = v[3] = 0;
X}
X
X/*!
X * @brief set all members of [v] to one
X *
X * @param[out] v vector
X */
XCGLM_INLINE
Xvoid
Xglm_ivec4_one(ivec4 v) {
X  v[0] = v[1] = v[2] = v[3] = 1;
X}
X
X/*!
X * @brief add vector [a] to vector [b] and store result in [dest]
X *
X * @param[in]  a    first vector
X * @param[in]  b    second vector
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_ivec4_add(ivec4 a, ivec4 b, ivec4 dest) {
X  dest[0] = a[0] + b[0];
X  dest[1] = a[1] + b[1];
X  dest[2] = a[2] + b[2];
X  dest[3] = a[3] + b[3];
X}
X
X/*!
X * @brief add scalar s to vector [v] and store result in [dest]
X *
X * @param[in]  v    vector
X * @param[in]  s    scalar
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_ivec4_adds(ivec4 v, int s, ivec4 dest) {
X  dest[0] = v[0] + s;
X  dest[1] = v[1] + s;
X  dest[2] = v[2] + s;
X  dest[3] = v[3] + s;
X}
X
X/*!
X * @brief subtract vector [b] from vector [a] and store result in [dest]
X *
X * @param[in]  a    first vector
X * @param[in]  b    second vector
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_ivec4_sub(ivec4 a, ivec4 b, ivec4 dest) {
X  dest[0] = a[0] - b[0];
X  dest[1] = a[1] - b[1];
X  dest[2] = a[2] - b[2];
X  dest[3] = a[3] - b[3];
X}
X
X/*!
X * @brief subtract scalar s from vector [v] and store result in [dest]
X *
X * @param[in]  v    vector
X * @param[in]  s    scalar
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_ivec4_subs(ivec4 v, int s, ivec4 dest) {
X  dest[0] = v[0] - s;
X  dest[1] = v[1] - s;
X  dest[2] = v[2] - s;
X  dest[3] = v[3] - s;
X}
X
X/*!
X * @brief multiply vector [a] with vector [b] and store result in [dest]
X *
X * @param[in]  a    frist vector
X * @param[in]  b    second vector
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_ivec4_mul(ivec4 a, ivec4 b, ivec4 dest) {
X  dest[0] = a[0] * b[0];
X  dest[1] = a[1] * b[1];
X  dest[2] = a[2] * b[2];
X  dest[3] = a[3] * b[3];
X}
X
X/*!
X * @brief multiply vector [a] with scalar s and store result in [dest]
X *
X * @param[in]  v    vector
X * @param[in]  s    scalar
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_ivec4_scale(ivec4 v, int s, ivec4 dest) {
X  dest[0] = v[0] * s;
X  dest[1] = v[1] * s;
X  dest[2] = v[2] * s;
X  dest[3] = v[3] * s;
X}
X
X/*!
X * @brief squared distance between two vectors
X *
X * @param[in] a first vector
X * @param[in] b second vector
X * @return returns squared distance (distance * distance)
X */
XCGLM_INLINE
Xint
Xglm_ivec4_distance2(ivec4 a, ivec4 b) {
X  int xd, yd, zd, wd;
X  xd = a[0] - b[0];
X  yd = a[1] - b[1];
X  zd = a[2] - b[2];
X  wd = a[3] - b[3];
X  return xd * xd + yd * yd + zd * zd + wd * wd;
X}
X
X/*!
X * @brief distance between two vectors
X *
X * @param[in] a first vector
X * @param[in] b second vector
X * @return returns distance
X */
XCGLM_INLINE
Xfloat
Xglm_ivec4_distance(ivec4 a, ivec4 b) {
X  return sqrtf((float)glm_ivec4_distance2(a, b));
X}
X
X/*!
X * @brief set each member of dest to greater of vector a and b
X *
X * @param[in]  a    first vector
X * @param[in]  b    second vector
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_ivec4_maxv(ivec4 a, ivec4 b, ivec4 dest) {
X  dest[0] = a[0] > b[0] ? a[0] : b[0];
X  dest[1] = a[1] > b[1] ? a[1] : b[1];
X  dest[2] = a[2] > b[2] ? a[2] : b[2];
X  dest[3] = a[3] > b[3] ? a[3] : b[3];
X}
X
X/*!
X * @brief set each member of dest to lesser of vector a and b
X *
X * @param[in]  a    first vector
X * @param[in]  b    second vector
X * @param[out] dest destination
X */
XCGLM_INLINE
Xvoid
Xglm_ivec4_minv(ivec4 a, ivec4 b, ivec4 dest) {
X  dest[0] = a[0] < b[0] ? a[0] : b[0];
X  dest[1] = a[1] < b[1] ? a[1] : b[1];
X  dest[2] = a[2] < b[2] ? a[2] : b[2];
X  dest[3] = a[3] < b[3] ? a[3] : b[3];
X}
X
X/*!
X * @brief clamp each member of [v] between minVal and maxVal (inclusive)
X *
X * @param[in, out] v      vector
X * @param[in]      minVal minimum value
X * @param[in]      maxVal maximum value
X */
XCGLM_INLINE
Xvoid
Xglm_ivec4_clamp(ivec4 v, int minVal, int maxVal) {
X  if (v[0] < minVal)
X    v[0] = minVal;
X  else if(v[0] > maxVal)
X    v[0] = maxVal;
X
X  if (v[1] < minVal)
X    v[1] = minVal;
X  else if(v[1] > maxVal)
X    v[1] = maxVal;
X
X  if (v[2] < minVal)
X    v[2] = minVal;
X  else if(v[2] > maxVal)
X    v[2] = maxVal;
X
X  if (v[3] < minVal)
X    v[3] = minVal;
X  else if(v[3] > maxVal)
X    v[3] = maxVal;
X}
X
X/*!
X * @brief absolute value of v
X *
X * @param[in]	v	vector
X * @param[out]	dest	destination
X */
XCGLM_INLINE
Xvoid
Xglm_ivec4_abs(ivec4 v, ivec4 dest) {
X  dest[0] = abs(v[0]);
X  dest[1] = abs(v[1]);
X  dest[2] = abs(v[2]);
X  dest[3] = abs(v[3]);
X}
X
X#endif /* cglm_ivec4_h */
618946c8aba0876291f05b5ef37e08d1
echo x - cglm/euler.h
sed 's/^X//' >cglm/euler.h << 'df82d34723a3d343d8a8189bed7458d4'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X NOTE:
X  angles must be passed as [X-Angle, Y-Angle, Z-angle] order
X  For instance you don't pass angles as [Z-Angle, X-Angle, Y-angle] to
X  glm_euler_zxy funciton, All RELATED functions accept angles same order
X  which is [X, Y, Z].
X */
X
X/*
X Types:
X   enum glm_euler_seq
X
X Functions:
X   CGLM_INLINE glm_euler_seq glm_euler_order(int newOrder[3]);
X   CGLM_INLINE void glm_euler_angles(mat4 m, vec3 dest);
X   CGLM_INLINE void glm_euler(vec3 angles, mat4 dest);
X   CGLM_INLINE void glm_euler_xyz(vec3 angles, mat4 dest);
X   CGLM_INLINE void glm_euler_zyx(vec3 angles, mat4 dest);
X   CGLM_INLINE void glm_euler_zxy(vec3 angles, mat4 dest);
X   CGLM_INLINE void glm_euler_xzy(vec3 angles, mat4 dest);
X   CGLM_INLINE void glm_euler_yzx(vec3 angles, mat4 dest);
X   CGLM_INLINE void glm_euler_yxz(vec3 angles, mat4 dest);
X   CGLM_INLINE void glm_euler_by_order(vec3         angles,
X                                       glm_euler_seq ord,
X                                       mat4         dest);
X */
X
X#ifndef cglm_euler_h
X#define cglm_euler_h
X
X#include "common.h"
X
X/*!
X * if you have axis order like vec3 orderVec = [0, 1, 2] or [0, 2, 1]...
X * vector then you can convert it to this enum by doing this:
X * @code
X * glm_euler_seq order;
X * order = orderVec[0] | orderVec[1] << 2 | orderVec[2] << 4;
X * @endcode
X * you may need to explicit cast if required
X */
Xtypedef enum glm_euler_seq {
X  GLM_EULER_XYZ = 0 << 0 | 1 << 2 | 2 << 4,
X  GLM_EULER_XZY = 0 << 0 | 2 << 2 | 1 << 4,
X  GLM_EULER_YZX = 1 << 0 | 2 << 2 | 0 << 4,
X  GLM_EULER_YXZ = 1 << 0 | 0 << 2 | 2 << 4,
X  GLM_EULER_ZXY = 2 << 0 | 0 << 2 | 1 << 4,
X  GLM_EULER_ZYX = 2 << 0 | 1 << 2 | 0 << 4
X} glm_euler_seq;
X
XCGLM_INLINE
Xglm_euler_seq
Xglm_euler_order(int ord[3]) {
X  return (glm_euler_seq)(ord[0] << 0 | ord[1] << 2 | ord[2] << 4);
X}
X
X/*!
X * @brief extract euler angles (in radians) using xyz order
X *
X * @param[in]  m    affine transform
X * @param[out] dest angles vector [x, y, z]
X */
XCGLM_INLINE
Xvoid
Xglm_euler_angles(mat4 m, vec3 dest) {
X  float m00, m01, m10, m11, m20, m21, m22;
X  float thetaX, thetaY, thetaZ;
X
X  m00 = m[0][0];  m10 = m[1][0];  m20 = m[2][0];
X  m01 = m[0][1];  m11 = m[1][1];  m21 = m[2][1];
X                                  m22 = m[2][2];
X
X  if (m20 < 1.0f) {
X    if (m20 > -1.0f) {
X      thetaY = asinf(m20);
X      thetaX = atan2f(-m21, m22);
X      thetaZ = atan2f(-m10, m00);
X    } else { /* m20 == -1 */
X      /* Not a unique solution */
X      thetaY = -GLM_PI_2f;
X      thetaX = -atan2f(m01, m11);
X      thetaZ =  0.0f;
X    }
X  } else { /* m20 == +1 */
X    thetaY = GLM_PI_2f;
X    thetaX = atan2f(m01, m11);
X    thetaZ = 0.0f;
X  }
X
X  dest[0] = thetaX;
X  dest[1] = thetaY;
X  dest[2] = thetaZ;
X}
X
X/*!
X * @brief build rotation matrix from euler angles
X *
X * @param[in]  angles angles as vector [Xangle, Yangle, Zangle]
X * @param[out] dest   rotation matrix
X */
XCGLM_INLINE
Xvoid
Xglm_euler_xyz(vec3 angles, mat4 dest) {
X  float cx, cy, cz,
X        sx, sy, sz, czsx, cxcz, sysz;
X
X  sx   = sinf(angles[0]); cx = cosf(angles[0]);
X  sy   = sinf(angles[1]); cy = cosf(angles[1]);
X  sz   = sinf(angles[2]); cz = cosf(angles[2]);
X
X  czsx = cz * sx;
X  cxcz = cx * cz;
X  sysz = sy * sz;
X
X  dest[0][0] =  cy * cz;
X  dest[0][1] =  czsx * sy + cx * sz;
X  dest[0][2] = -cxcz * sy + sx * sz;
X  dest[1][0] = -cy * sz;
X  dest[1][1] =  cxcz - sx * sysz;
X  dest[1][2] =  czsx + cx * sysz;
X  dest[2][0] =  sy;
X  dest[2][1] = -cy * sx;
X  dest[2][2] =  cx * cy;
X  dest[0][3] =  0.0f;
X  dest[1][3] =  0.0f;
X  dest[2][3] =  0.0f;
X  dest[3][0] =  0.0f;
X  dest[3][1] =  0.0f;
X  dest[3][2] =  0.0f;
X  dest[3][3] =  1.0f;
X}
X
X/*!
X * @brief build rotation matrix from euler angles
X *
X * @param[in]  angles angles as vector [Xangle, Yangle, Zangle]
X * @param[out] dest   rotation matrix
X */
XCGLM_INLINE
Xvoid
Xglm_euler(vec3 angles, mat4 dest) {
X  glm_euler_xyz(angles, dest);
X}
X
X/*!
X * @brief build rotation matrix from euler angles
X *
X * @param[in]  angles angles as vector [Xangle, Yangle, Zangle]
X * @param[out] dest   rotation matrix
X */
XCGLM_INLINE
Xvoid
Xglm_euler_xzy(vec3 angles, mat4 dest) {
X  float cx, cy, cz,
X  sx, sy, sz, sxsy, cysx, cxsy, cxcy;
X
X  sx   = sinf(angles[0]); cx = cosf(angles[0]);
X  sy   = sinf(angles[1]); cy = cosf(angles[1]);
X  sz   = sinf(angles[2]); cz = cosf(angles[2]);
X
X  sxsy = sx * sy;
X  cysx = cy * sx;
X  cxsy = cx * sy;
X  cxcy = cx * cy;
X
X  dest[0][0] =  cy * cz;
X  dest[0][1] =  sxsy + cxcy * sz;
X  dest[0][2] = -cxsy + cysx * sz;
X  dest[1][0] = -sz;
X  dest[1][1] =  cx * cz;
X  dest[1][2] =  cz * sx;
X  dest[2][0] =  cz * sy;
X  dest[2][1] = -cysx + cxsy * sz;
X  dest[2][2] =  cxcy + sxsy * sz;
X  dest[0][3] =  0.0f;
X  dest[1][3] =  0.0f;
X  dest[2][3] =  0.0f;
X  dest[3][0] =  0.0f;
X  dest[3][1] =  0.0f;
X  dest[3][2] =  0.0f;
X  dest[3][3] =  1.0f;
X}
X
X
X/*!
X * @brief build rotation matrix from euler angles
X *
X * @param[in]  angles angles as vector [Xangle, Yangle, Zangle]
X * @param[out] dest   rotation matrix
X */
XCGLM_INLINE
Xvoid
Xglm_euler_yxz(vec3 angles, mat4 dest) {
X  float cx, cy, cz,
X        sx, sy, sz, cycz, sysz, czsy, cysz;
X
X  sx   = sinf(angles[0]); cx = cosf(angles[0]);
X  sy   = sinf(angles[1]); cy = cosf(angles[1]);
X  sz   = sinf(angles[2]); cz = cosf(angles[2]);
X
X  cycz = cy * cz;
X  sysz = sy * sz;
X  czsy = cz * sy;
X  cysz = cy * sz;
X
X  dest[0][0] =  cycz + sx * sysz;
X  dest[0][1] =  cx * sz;
X  dest[0][2] = -czsy + cysz * sx;
X  dest[1][0] = -cysz + czsy * sx;
X  dest[1][1] =  cx * cz;
X  dest[1][2] =  cycz * sx + sysz;
X  dest[2][0] =  cx * sy;
X  dest[2][1] = -sx;
X  dest[2][2] =  cx * cy;
X  dest[0][3] =  0.0f;
X  dest[1][3] =  0.0f;
X  dest[2][3] =  0.0f;
X  dest[3][0] =  0.0f;
X  dest[3][1] =  0.0f;
X  dest[3][2] =  0.0f;
X  dest[3][3] =  1.0f;
X}
X
X/*!
X * @brief build rotation matrix from euler angles
X *
X * @param[in]  angles angles as vector [Xangle, Yangle, Zangle]
X * @param[out] dest   rotation matrix
X */
XCGLM_INLINE
Xvoid
Xglm_euler_yzx(vec3 angles, mat4 dest) {
X  float cx, cy, cz,
X        sx, sy, sz, sxsy, cxcy, cysx, cxsy;
X
X  sx   = sinf(angles[0]); cx = cosf(angles[0]);
X  sy   = sinf(angles[1]); cy = cosf(angles[1]);
X  sz   = sinf(angles[2]); cz = cosf(angles[2]);
X
X  sxsy = sx * sy;
X  cxcy = cx * cy;
X  cysx = cy * sx;
X  cxsy = cx * sy;
X
X  dest[0][0] =  cy * cz;
X  dest[0][1] =  sz;
X  dest[0][2] = -cz * sy;
X  dest[1][0] =  sxsy - cxcy * sz;
X  dest[1][1] =  cx * cz;
X  dest[1][2] =  cysx + cxsy * sz;
X  dest[2][0] =  cxsy + cysx * sz;
X  dest[2][1] = -cz * sx;
X  dest[2][2] =  cxcy - sxsy * sz;
X  dest[0][3] =  0.0f;
X  dest[1][3] =  0.0f;
X  dest[2][3] =  0.0f;
X  dest[3][0] =  0.0f;
X  dest[3][1] =  0.0f;
X  dest[3][2] =  0.0f;
X  dest[3][3] =  1.0f;
X}
X
X/*!
X * @brief build rotation matrix from euler angles
X *
X * @param[in]  angles angles as vector [Xangle, Yangle, Zangle]
X * @param[out] dest   rotation matrix
X */
XCGLM_INLINE
Xvoid
Xglm_euler_zxy(vec3 angles, mat4 dest) {
X  float cx, cy, cz,
X        sx, sy, sz, cycz, sxsy, cysz;
X
X  sx   = sinf(angles[0]); cx = cosf(angles[0]);
X  sy   = sinf(angles[1]); cy = cosf(angles[1]);
X  sz   = sinf(angles[2]); cz = cosf(angles[2]);
X
X  cycz = cy * cz;
X  sxsy = sx * sy;
X  cysz = cy * sz;
X
X  dest[0][0] =  cycz - sxsy * sz;
X  dest[0][1] =  cz * sxsy + cysz;
X  dest[0][2] = -cx * sy;
X  dest[1][0] = -cx * sz;
X  dest[1][1] =  cx * cz;
X  dest[1][2] =  sx;
X  dest[2][0] =  cz * sy + cysz * sx;
X  dest[2][1] = -cycz * sx + sy * sz;
X  dest[2][2] =  cx * cy;
X  dest[0][3] =  0.0f;
X  dest[1][3] =  0.0f;
X  dest[2][3] =  0.0f;
X  dest[3][0] =  0.0f;
X  dest[3][1] =  0.0f;
X  dest[3][2] =  0.0f;
X  dest[3][3] =  1.0f;
X}
X
X/*!
X * @brief build rotation matrix from euler angles
X *
X * @param[in]  angles angles as vector [Xangle, Yangle, Zangle]
X * @param[out] dest   rotation matrix
X */
XCGLM_INLINE
Xvoid
Xglm_euler_zyx(vec3 angles, mat4 dest) {
X  float cx, cy, cz,
X        sx, sy, sz, czsx, cxcz, sysz;
X
X  sx   = sinf(angles[0]); cx = cosf(angles[0]);
X  sy   = sinf(angles[1]); cy = cosf(angles[1]);
X  sz   = sinf(angles[2]); cz = cosf(angles[2]);
X
X  czsx = cz * sx;
X  cxcz = cx * cz;
X  sysz = sy * sz;
X
X  dest[0][0] =  cy * cz;
X  dest[0][1] =  cy * sz;
X  dest[0][2] = -sy;
X  dest[1][0] =  czsx * sy - cx * sz;
X  dest[1][1] =  cxcz + sx * sysz;
X  dest[1][2] =  cy * sx;
X  dest[2][0] =  cxcz * sy + sx * sz;
X  dest[2][1] = -czsx + cx * sysz;
X  dest[2][2] =  cx * cy;
X  dest[0][3] =  0.0f;
X  dest[1][3] =  0.0f;
X  dest[2][3] =  0.0f;
X  dest[3][0] =  0.0f;
X  dest[3][1] =  0.0f;
X  dest[3][2] =  0.0f;
X  dest[3][3] =  1.0f;
X}
X
X/*!
X * @brief build rotation matrix from euler angles
X *
X * @param[in]  angles angles as vector [Xangle, Yangle, Zangle]
X * @param[in]  ord    euler order
X * @param[out] dest   rotation matrix
X */
XCGLM_INLINE
Xvoid
Xglm_euler_by_order(vec3 angles, glm_euler_seq ord, mat4 dest) {
X  float cx, cy, cz,
X        sx, sy, sz;
X
X  float cycz, cysz, cysx, cxcy,
X        czsy, cxcz, czsx, cxsz,
X        sysz;
X
X  sx = sinf(angles[0]); cx = cosf(angles[0]);
X  sy = sinf(angles[1]); cy = cosf(angles[1]);
X  sz = sinf(angles[2]); cz = cosf(angles[2]);
X
X  cycz = cy * cz; cysz = cy * sz;
X  cysx = cy * sx; cxcy = cx * cy;
X  czsy = cz * sy; cxcz = cx * cz;
X  czsx = cz * sx; cxsz = cx * sz;
X  sysz = sy * sz;
X
X  switch (ord) {
X    case GLM_EULER_XZY:
X      dest[0][0] =  cycz;
X      dest[0][1] =  sx * sy + cx * cysz;
X      dest[0][2] = -cx * sy + cysx * sz;
X      dest[1][0] = -sz;
X      dest[1][1] =  cxcz;
X      dest[1][2] =  czsx;
X      dest[2][0] =  czsy;
X      dest[2][1] = -cysx + cx * sysz;
X      dest[2][2] =  cxcy + sx * sysz;
X      break;
X    case GLM_EULER_XYZ:
X      dest[0][0] =  cycz;
X      dest[0][1] =  czsx * sy + cxsz;
X      dest[0][2] = -cx * czsy + sx * sz;
X      dest[1][0] = -cysz;
X      dest[1][1] =  cxcz - sx * sysz;
X      dest[1][2] =  czsx + cx * sysz;
X      dest[2][0] =  sy;
X      dest[2][1] = -cysx;
X      dest[2][2] =  cxcy;
X      break;
X    case GLM_EULER_YXZ:
X      dest[0][0] =  cycz + sx * sysz;
X      dest[0][1] =  cxsz;
X      dest[0][2] = -czsy + cysx * sz;
X      dest[1][0] =  czsx * sy - cysz;
X      dest[1][1] =  cxcz;
X      dest[1][2] =  cycz * sx + sysz;
X      dest[2][0] =  cx * sy;
X      dest[2][1] = -sx;
X      dest[2][2] =  cxcy;
X      break;
X    case GLM_EULER_YZX:
X      dest[0][0] =  cycz;
X      dest[0][1] =  sz;
X      dest[0][2] = -czsy;
X      dest[1][0] =  sx * sy - cx * cysz;
X      dest[1][1] =  cxcz;
X      dest[1][2] =  cysx + cx * sysz;
X      dest[2][0] =  cx * sy + cysx * sz;
X      dest[2][1] = -czsx;
X      dest[2][2] =  cxcy - sx * sysz;
X      break;
X    case GLM_EULER_ZXY:
X      dest[0][0] =  cycz - sx * sysz;
X      dest[0][1] =  czsx * sy + cysz;
X      dest[0][2] = -cx * sy;
X      dest[1][0] = -cxsz;
X      dest[1][1] =  cxcz;
X      dest[1][2] =  sx;
X      dest[2][0] =  czsy + cysx * sz;
X      dest[2][1] = -cycz * sx + sysz;
X      dest[2][2] =  cxcy;
X      break;
X    case GLM_EULER_ZYX:
X      dest[0][0] =  cycz;
X      dest[0][1] =  cysz;
X      dest[0][2] = -sy;
X      dest[1][0] =  czsx * sy - cxsz;
X      dest[1][1] =  cxcz + sx * sysz;
X      dest[1][2] =  cysx;
X      dest[2][0] =  cx * czsy + sx * sz;
X      dest[2][1] = -czsx + cx * sysz;
X      dest[2][2] =  cxcy;
X      break;
X  }
X
X  dest[0][3] = 0.0f;
X  dest[1][3] = 0.0f;
X  dest[2][3] = 0.0f;
X  dest[3][0] = 0.0f;
X  dest[3][1] = 0.0f;
X  dest[3][2] = 0.0f;
X  dest[3][3] = 1.0f;
X}
X
X#endif /* cglm_euler_h */
df82d34723a3d343d8a8189bed7458d4
echo x - cglm/util.h
sed 's/^X//' >cglm/util.h << 'd9a360d2017c6e6ea4b74e6a1ad64a86'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Functions:
X   CGLM_INLINE int   glm_sign(int val);
X   CGLM_INLINE float glm_signf(float val);
X   CGLM_INLINE float glm_rad(float deg);
X   CGLM_INLINE float glm_deg(float rad);
X   CGLM_INLINE void  glm_make_rad(float *deg);
X   CGLM_INLINE void  glm_make_deg(float *rad);
X   CGLM_INLINE float glm_pow2(float x);
X   CGLM_INLINE float glm_min(float a, float b);
X   CGLM_INLINE float glm_max(float a, float b);
X   CGLM_INLINE float glm_clamp(float val, float minVal, float maxVal);
X   CGLM_INLINE float glm_clamp_zo(float val, float minVal, float maxVal);
X   CGLM_INLINE float glm_lerp(float from, float to, float t);
X   CGLM_INLINE float glm_lerpc(float from, float to, float t);
X   CGLM_INLINE float glm_step(float edge, float x);
X   CGLM_INLINE float glm_smooth(float t);
X   CGLM_INLINE float glm_smoothstep(float edge0, float edge1, float x);
X   CGLM_INLINE float glm_smoothinterp(float from, float to, float t);
X   CGLM_INLINE float glm_smoothinterpc(float from, float to, float t);
X   CGLM_INLINE bool  glm_eq(float a, float b);
X   CGLM_INLINE float glm_percent(float from, float to, float current);
X   CGLM_INLINE float glm_percentc(float from, float to, float current);
X */
X
X#ifndef cglm_util_h
X#define cglm_util_h
X
X#include "common.h"
X
X#define GLM_MIN(X, Y) (((X) < (Y)) ? (X) : (Y))
X#define GLM_MAX(X, Y) (((X) > (Y)) ? (X) : (Y))
X
X/*!
X * @brief get sign of 32 bit integer as +1, -1, 0
X *
X * Important: It returns 0 for zero input
X *
X * @param val integer value
X */
XCGLM_INLINE
Xint
Xglm_sign(int val) {
X  return ((val >> 31) - (-val >> 31));
X}
X
X/*!
X * @brief get sign of 32 bit float as +1, -1, 0
X *
X * Important: It returns 0 for zero/NaN input
X *
X * @param val float value
X */
XCGLM_INLINE
Xfloat
Xglm_signf(float val) {
X  return (float)((val > 0.0f) - (val < 0.0f));
X}
X
X/*!
X * @brief convert degree to radians
X *
X * @param[in] deg angle in degrees
X */
XCGLM_INLINE
Xfloat
Xglm_rad(float deg) {
X  return deg * GLM_PIf / 180.0f;
X}
X
X/*!
X * @brief convert radians to degree
X *
X * @param[in] rad angle in radians
X */
XCGLM_INLINE
Xfloat
Xglm_deg(float rad) {
X  return rad * 180.0f / GLM_PIf;
X}
X
X/*!
X * @brief convert exsisting degree to radians. this will override degrees value
X *
X * @param[in, out] deg pointer to angle in degrees
X */
XCGLM_INLINE
Xvoid
Xglm_make_rad(float *deg) {
X  *deg = *deg * GLM_PIf / 180.0f;
X}
X
X/*!
X * @brief convert exsisting radians to degree. this will override radians value
X *
X * @param[in, out] rad pointer to angle in radians
X */
XCGLM_INLINE
Xvoid
Xglm_make_deg(float *rad) {
X  *rad = *rad * 180.0f / GLM_PIf;
X}
X
X/*!
X * @brief multiplies given parameter with itself = x * x or powf(x, 2)
X *
X * @param[in] x x
X */
XCGLM_INLINE
Xfloat
Xglm_pow2(float x) {
X  return x * x;
X}
X
X/*!
X * @brief find minimum of given two values
X *
X * @param[in] a number 1
X * @param[in] b number 2
X */
XCGLM_INLINE
Xfloat
Xglm_min(float a, float b) {
X  if (a < b)
X    return a;
X  return b;
X}
X
X/*!
X * @brief find maximum of given two values
X *
X * @param[in] a number 1
X * @param[in] b number 2
X */
XCGLM_INLINE
Xfloat
Xglm_max(float a, float b) {
X  if (a > b)
X    return a;
X  return b;
X}
X
X/*!
X * @brief clamp a number between min and max
X *
X * @param[in] val    value to clamp
X * @param[in] minVal minimum value
X * @param[in] maxVal maximum value
X */
XCGLM_INLINE
Xfloat
Xglm_clamp(float val, float minVal, float maxVal) {
X  return glm_min(glm_max(val, minVal), maxVal);
X}
X
X/*!
X * @brief clamp a number to zero and one
X *
X * @param[in] val value to clamp
X */
XCGLM_INLINE
Xfloat
Xglm_clamp_zo(float val) {
X  return glm_clamp(val, 0.0f, 1.0f);
X}
X
X/*!
X * @brief linear interpolation between two numbers
X *
X * formula:  from + t * (to - from)
X *
X * @param[in]   from from value
X * @param[in]   to   to value
X * @param[in]   t    interpolant (amount)
X */
XCGLM_INLINE
Xfloat
Xglm_lerp(float from, float to, float t) {
X  return from + t * (to - from);
X}
X
X/*!
X * @brief clamped linear interpolation between two numbers
X *
X * formula:  from + t * (to - from)
X *
X * @param[in]   from    from value
X * @param[in]   to      to value
X * @param[in]   t       interpolant (amount) clamped between 0 and 1
X */
XCGLM_INLINE
Xfloat
Xglm_lerpc(float from, float to, float t) {
X  return glm_lerp(from, to, glm_clamp_zo(t));
X}
X
X/*!
X * @brief threshold function
X *
X * @param[in]   edge    threshold
X * @param[in]   x       value to test against threshold
X * @return      returns 0.0 if x < edge, else 1.0
X */
XCGLM_INLINE
Xfloat
Xglm_step(float edge, float x) {
X  /* branching - no type conversion */
X  return (x < edge) ? 0.0f : 1.0f;
X  /*
X   * An alternative implementation without branching
X   * but with type conversion could be:
X   * return !(x < edge);
X   */
X}
X
X/*!
X * @brief smooth Hermite interpolation
X *
X * formula:  t^2 * (3-2t)
X *
X * @param[in]   t    interpolant (amount)
X */
XCGLM_INLINE
Xfloat
Xglm_smooth(float t) {
X  return t * t * (3.0f - 2.0f * t);
X}
X
X/*!
X * @brief threshold function with a smooth transition (according to OpenCL specs)
X *
X * formula:  t^2 * (3-2t)
X *
X * @param[in]   edge0 low threshold
X * @param[in]   edge1 high threshold
X * @param[in]   x     interpolant (amount)
X */
XCGLM_INLINE
Xfloat
Xglm_smoothstep(float edge0, float edge1, float x) {
X  float t;
X  t = glm_clamp_zo((x - edge0) / (edge1 - edge0));
X  return glm_smooth(t);
X}
X
X/*!
X * @brief smoothstep interpolation between two numbers
X *
X * formula:  from + smoothstep(t) * (to - from)
X *
X * @param[in]   from from value
X * @param[in]   to   to value
X * @param[in]   t    interpolant (amount)
X */
XCGLM_INLINE
Xfloat
Xglm_smoothinterp(float from, float to, float t) {
X  return from + glm_smooth(t) * (to - from);
X}
X
X/*!
X * @brief clamped smoothstep interpolation between two numbers
X *
X * formula:  from + smoothstep(t) * (to - from)
X *
X * @param[in]   from from value
X * @param[in]   to   to value
X * @param[in]   t    interpolant (amount) clamped between 0 and 1
X */
XCGLM_INLINE
Xfloat
Xglm_smoothinterpc(float from, float to, float t) {
X  return glm_smoothinterp(from, to, glm_clamp_zo(t));
X}
X
X/*!
X * @brief check if two float equal with using EPSILON
X *
X * @param[in]   a   a
X * @param[in]   b   b
X */
XCGLM_INLINE
Xbool
Xglm_eq(float a, float b) {
X  return fabsf(a - b) <= GLM_FLT_EPSILON;
X}
X
X/*!
X * @brief percentage of current value between start and end value
X *
X * maybe fraction could be alternative name.
X *
X * @param[in]   from    from value
X * @param[in]   to      to value
X * @param[in]   current current value
X */
XCGLM_INLINE
Xfloat
Xglm_percent(float from, float to, float current) {
X  float t;
X
X  if ((t = to - from) == 0.0f)
X    return 1.0f;
X
X  return (current - from) / t;
X}
X
X/*!
X * @brief clamped percentage of current value between start and end value
X *
X * @param[in]   from    from value
X * @param[in]   to      to value
X * @param[in]   current current value
X */
XCGLM_INLINE
Xfloat
Xglm_percentc(float from, float to, float current) {
X  return glm_clamp_zo(glm_percent(from, to, current));
X}
X
X/*!
X* @brief swap two float values
X*
X* @param[in]   a float value 1 (pointer)
X* @param[in]   b float value 2 (pointer)
X*/
XCGLM_INLINE
Xvoid
Xglm_swapf(float * __restrict a, float * __restrict b) {
X  float t;
X  t  = *a;
X  *a = *b;
X  *b = t;
X}
X
X#endif /* cglm_util_h */
d9a360d2017c6e6ea4b74e6a1ad64a86
echo x - cglm/quat.h
sed 's/^X//' >cglm/quat.h << '04c24ba264492706af55aaf3fb20addf'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Macros:
X   GLM_QUAT_IDENTITY_INIT
X   GLM_QUAT_IDENTITY
X
X Functions:
X   CGLM_INLINE void glm_quat_identity(versor q);
X   CGLM_INLINE void glm_quat_init(versor q, float x, float y, float z, float w);
X   CGLM_INLINE void glm_quat(versor q, float angle, float x, float y, float z);
X   CGLM_INLINE void glm_quatv(versor q, float angle, vec3 axis);
X   CGLM_INLINE void glm_quat_copy(versor q, versor dest);
X   CGLM_INLINE void glm_quat_from_vecs(vec3 a, vec3 b, versor dest);
X   CGLM_INLINE float glm_quat_norm(versor q);
X   CGLM_INLINE void glm_quat_normalize(versor q);
X   CGLM_INLINE void glm_quat_normalize_to(versor q, versor dest);
X   CGLM_INLINE float glm_quat_dot(versor p, versor q);
X   CGLM_INLINE void glm_quat_conjugate(versor q, versor dest);
X   CGLM_INLINE void glm_quat_inv(versor q, versor dest);
X   CGLM_INLINE void glm_quat_add(versor p, versor q, versor dest);
X   CGLM_INLINE void glm_quat_sub(versor p, versor q, versor dest);
X   CGLM_INLINE float glm_quat_real(versor q);
X   CGLM_INLINE void glm_quat_imag(versor q, vec3 dest);
X   CGLM_INLINE void glm_quat_imagn(versor q, vec3 dest);
X   CGLM_INLINE float glm_quat_imaglen(versor q);
X   CGLM_INLINE float glm_quat_angle(versor q);
X   CGLM_INLINE void glm_quat_axis(versor q, vec3 dest);
X   CGLM_INLINE void glm_quat_mul(versor p, versor q, versor dest);
X   CGLM_INLINE void glm_quat_mat4(versor q, mat4 dest);
X   CGLM_INLINE void glm_quat_mat4t(versor q, mat4 dest);
X   CGLM_INLINE void glm_quat_mat3(versor q, mat3 dest);
X   CGLM_INLINE void glm_quat_mat3t(versor q, mat3 dest);
X   CGLM_INLINE void glm_quat_lerp(versor from, versor to, float t, versor dest);
X   CGLM_INLINE void glm_quat_lerpc(versor from, versor to, float t, versor dest);
X   CGLM_INLINE void glm_quat_slerp(versor q, versor r, float t, versor dest);
X   CGLM_INLINE void glm_quat_nlerp(versor q, versor r, float t, versor dest);
X   CGLM_INLINE void glm_quat_look(vec3 eye, versor ori, mat4 dest);
X   CGLM_INLINE void glm_quat_for(vec3 dir, vec3 fwd, vec3 up, versor dest);
X   CGLM_INLINE void glm_quat_forp(vec3 from,
X                                  vec3 to,
X                                  vec3 fwd,
X                                  vec3 up,
X                                  versor dest);
X   CGLM_INLINE void glm_quat_rotatev(versor q, vec3 v, vec3 dest);
X   CGLM_INLINE void glm_quat_rotate(mat4 m, versor q, mat4 dest);
X   CGLM_INLINE void glm_quat_make(float * restrict src, versor dest);
X */
X
X#ifndef cglm_quat_h
X#define cglm_quat_h
X
X#include "common.h"
X#include "vec3.h"
X#include "vec4.h"
X#include "mat4.h"
X#include "mat3.h"
X#include "affine-mat.h"
X#include "affine.h"
X
X#ifdef CGLM_SSE_FP
X#  include "simd/sse2/quat.h"
X#endif
X
X#ifdef CGLM_NEON_FP
X#  include "simd/neon/quat.h"
X#endif
X
X#ifdef CGLM_SIMD_WASM
X#  include "simd/wasm/quat.h"
X#endif
X
XCGLM_INLINE void glm_quat_normalize(versor q);
X
X/*
X * IMPORTANT:
X * ----------------------------------------------------------------------------
X * cglm stores quat as [x, y, z, w] since v0.3.6
X *
X * it was [w, x, y, z] before v0.3.6 it has been changed to [x, y, z, w]
X * with v0.3.6 version.
X * ----------------------------------------------------------------------------
X */
X
X#define GLM_QUAT_IDENTITY_INIT  {0.0f, 0.0f, 0.0f, 1.0f}
X#define GLM_QUAT_IDENTITY       ((versor)GLM_QUAT_IDENTITY_INIT)
X
X/*!
X * @brief makes given quat to identity
X *
X * @param[in, out]  q  quaternion
X */
XCGLM_INLINE
Xvoid
Xglm_quat_identity(versor q) {
X  CGLM_ALIGN(16) versor v = GLM_QUAT_IDENTITY_INIT;
X  glm_vec4_copy(v, q);
X}
X
X/*!
X * @brief make given quaternion array's each element identity quaternion
X *
X * @param[in, out]  q     quat array (must be aligned (16)
X *                        if alignment is not disabled)
X *
X * @param[in]       count count of quaternions
X */
XCGLM_INLINE
Xvoid
Xglm_quat_identity_array(versor * __restrict q, size_t count) {
X  CGLM_ALIGN(16) versor v = GLM_QUAT_IDENTITY_INIT;
X  size_t i;
X
X  for (i = 0; i < count; i++) {
X    glm_vec4_copy(v, q[i]);
X  }
X}
X
X/*!
X * @brief inits quaterion with raw values
X *
X * @param[out]  q     quaternion
X * @param[in]   x     x
X * @param[in]   y     y
X * @param[in]   z     z
X * @param[in]   w     w (real part)
X */
XCGLM_INLINE
Xvoid
Xglm_quat_init(versor q, float x, float y, float z, float w) {
X  q[0] = x;
X  q[1] = y;
X  q[2] = z;
X  q[3] = w;
X}
X
X/*!
X * @brief creates NEW quaternion with axis vector
X *
X * @param[out]  q     quaternion
X * @param[in]   angle angle (radians)
X * @param[in]   axis  axis
X */
XCGLM_INLINE
Xvoid
Xglm_quatv(versor q, float angle, vec3 axis) {
X  CGLM_ALIGN(8) vec3 k;
X  float a, c, s;
X
X  a = angle * 0.5f;
X  c = cosf(a);
X  s = sinf(a);
X
X  glm_normalize_to(axis, k);
X
X  q[0] = s * k[0];
X  q[1] = s * k[1];
X  q[2] = s * k[2];
X  q[3] = c;
X}
X
X/*!
X * @brief creates NEW quaternion with individual axis components
X *
X * @param[out]  q     quaternion
X * @param[in]   angle angle (radians)
X * @param[in]   x     axis.x
X * @param[in]   y     axis.y
X * @param[in]   z     axis.z
X */
XCGLM_INLINE
Xvoid
Xglm_quat(versor q, float angle, float x, float y, float z) {
X  CGLM_ALIGN(8) vec3 axis = {x, y, z};
X  glm_quatv(q, angle, axis);
X}
X
X/*!
X * @brief copy quaternion to another one
X *
X * @param[in]  q     quaternion
X * @param[out] dest  destination
X */
XCGLM_INLINE
Xvoid
Xglm_quat_copy(versor q, versor dest) {
X  glm_vec4_copy(q, dest);
X}
X
X/*!
X * @brief compute quaternion rotating vector A to vector B
X *
X * @param[in]   a     vec3 (must have unit length)
X * @param[in]   b     vec3 (must have unit length)
X * @param[out]  dest  quaternion (of unit length)
X */
XCGLM_INLINE
Xvoid
Xglm_quat_from_vecs(vec3 a, vec3 b, versor dest) {
X  CGLM_ALIGN(8) vec3 axis;
X  float cos_theta;
X  float cos_half_theta;
X
X  cos_theta = glm_vec3_dot(a, b);
X  if (cos_theta >= 1.f - GLM_FLT_EPSILON) {  /*  a  b  */
X    glm_quat_identity(dest);
X    return;
X  }
X  if (cos_theta < -1.f + GLM_FLT_EPSILON) {  /*  angle(a, b) =   */
X    glm_vec3_ortho(a, axis);
X    cos_half_theta = 0.f;                    /*  cos /2 */
X  } else {
X    glm_vec3_cross(a, b, axis);
X    cos_half_theta = 1.0f + cos_theta;       /*  cos 0 + cos   */
X  }
X
X  glm_quat_init(dest, axis[0], axis[1], axis[2], cos_half_theta);
X  glm_quat_normalize(dest);
X}
X
X/*!
X * @brief returns norm (magnitude) of quaternion
X *
X * @param[in]  q  quaternion
X */
XCGLM_INLINE
Xfloat
Xglm_quat_norm(versor q) {
X  return glm_vec4_norm(q);
X}
X
X/*!
X * @brief normalize quaternion and store result in dest
X *
X * @param[in]   q     quaternion to normalze
X * @param[out]  dest  destination quaternion
X */
XCGLM_INLINE
Xvoid
Xglm_quat_normalize_to(versor q, versor dest) {
X#if defined(__wasm__) && defined(__wasm_simd128__)
X  glmm_128 xdot, x0;
X  float  dot;
X
X  x0   = glmm_load(q);
X  xdot = glmm_vdot(x0, x0);
X  /* dot  = _mm_cvtss_f32(xdot); */
X  dot  = wasm_f32x4_extract_lane(xdot, 0);
X
X  if (dot <= 0.0f) {
X    glm_quat_identity(dest);
X    return;
X  }
X
X  glmm_store(dest, wasm_f32x4_div(x0, wasm_f32x4_sqrt(xdot)));
X#elif defined( __SSE__ ) || defined( __SSE2__ )
X  __m128 xdot, x0;
X  float  dot;
X
X  x0   = glmm_load(q);
X  xdot = glmm_vdot(x0, x0);
X  dot  = _mm_cvtss_f32(xdot);
X
X  if (dot <= 0.0f) {
X    glm_quat_identity(dest);
X    return;
X  }
X
X  glmm_store(dest, _mm_div_ps(x0, _mm_sqrt_ps(xdot)));
X#else
X  float dot;
X
X  dot = glm_vec4_norm2(q);
X
X  if (dot <= 0.0f) {
X    glm_quat_identity(dest);
X    return;
X  }
X
X  glm_vec4_scale(q, 1.0f / sqrtf(dot), dest);
X#endif
X}
X
X/*!
X * @brief normalize quaternion
X *
X * @param[in, out]  q  quaternion
X */
XCGLM_INLINE
Xvoid
Xglm_quat_normalize(versor q) {
X  glm_quat_normalize_to(q, q);
X}
X
X/*!
X * @brief dot product of two quaternion
X *
X * @param[in]  p  quaternion 1
X * @param[in]  q  quaternion 2
X */
XCGLM_INLINE
Xfloat
Xglm_quat_dot(versor p, versor q) {
X  return glm_vec4_dot(p, q);
X}
X
X/*!
X * @brief conjugate of quaternion
X *
X * @param[in]   q     quaternion
X * @param[out]  dest  conjugate
X */
XCGLM_INLINE
Xvoid
Xglm_quat_conjugate(versor q, versor dest) {
X  glm_vec4_negate_to(q, dest);
X  dest[3] = -dest[3];
X}
X
X/*!
X * @brief inverse of non-zero quaternion
X *
X * @param[in]   q    quaternion
X * @param[out]  dest inverse quaternion
X */
XCGLM_INLINE
Xvoid
Xglm_quat_inv(versor q, versor dest) {
X  CGLM_ALIGN(16) versor conj;
X  glm_quat_conjugate(q, conj);
X  glm_vec4_scale(conj, 1.0f / glm_vec4_norm2(q), dest);
X}
X
X/*!
X * @brief add (componentwise) two quaternions and store result in dest
X *
X * @param[in]   p    quaternion 1
X * @param[in]   q    quaternion 2
X * @param[out]  dest result quaternion
X */
XCGLM_INLINE
Xvoid
Xglm_quat_add(versor p, versor q, versor dest) {
X  glm_vec4_add(p, q, dest);
X}
X
X/*!
X * @brief subtract (componentwise) two quaternions and store result in dest
X *
X * @param[in]   p    quaternion 1
X * @param[in]   q    quaternion 2
X * @param[out]  dest result quaternion
X */
XCGLM_INLINE
Xvoid
Xglm_quat_sub(versor p, versor q, versor dest) {
X  glm_vec4_sub(p, q, dest);
X}
X
X/*!
X * @brief returns real part of quaternion
X *
X * @param[in]   q    quaternion
X */
XCGLM_INLINE
Xfloat
Xglm_quat_real(versor q) {
X  return q[3];
X}
X
X/*!
X * @brief returns imaginary part of quaternion
X *
X * @param[in]   q    quaternion
X * @param[out]  dest imag
X */
XCGLM_INLINE
Xvoid
Xglm_quat_imag(versor q, vec3 dest) {
X  dest[0] = q[0];
X  dest[1] = q[1];
X  dest[2] = q[2];
X}
X
X/*!
X * @brief returns normalized imaginary part of quaternion
X *
X * @param[in]   q    quaternion
X */
XCGLM_INLINE
Xvoid
Xglm_quat_imagn(versor q, vec3 dest) {
X  glm_normalize_to(q, dest);
X}
X
X/*!
X * @brief returns length of imaginary part of quaternion
X *
X * @param[in]   q    quaternion
X */
XCGLM_INLINE
Xfloat
Xglm_quat_imaglen(versor q) {
X  return glm_vec3_norm(q);
X}
X
X/*!
X * @brief returns angle of quaternion
X *
X * @param[in]   q    quaternion
X */
XCGLM_INLINE
Xfloat
Xglm_quat_angle(versor q) {
X  /*
X   sin(theta / 2) = length(x*x + y*y + z*z)
X   cos(theta / 2) = w
X   theta          = 2 * atan(sin(theta / 2) / cos(theta / 2))
X   */
X  return 2.0f * atan2f(glm_quat_imaglen(q), glm_quat_real(q));
X}
X
X/*!
X * @brief axis of quaternion
X *
X * @param[in]   q    quaternion
X * @param[out]  dest axis of quaternion
X */
XCGLM_INLINE
Xvoid
Xglm_quat_axis(versor q, vec3 dest) {
X  glm_quat_imagn(q, dest);
X}
X
X/*!
X * @brief multiplies two quaternion and stores result in dest
X *        this is also called Hamilton Product
X *
X * According to WikiPedia:
X * The product of two rotation quaternions [clarification needed] will be
X * equivalent to the rotation q followed by the rotation p
X *
X * @param[in]   p     quaternion 1
X * @param[in]   q     quaternion 2
X * @param[out]  dest  result quaternion
X */
XCGLM_INLINE
Xvoid
Xglm_quat_mul(versor p, versor q, versor dest) {
X  /*
X    + (a1 b2 + b1 a2 + c1 d2  d1 c2)i
X    + (a1 c2  b1 d2 + c1 a2 + d1 b2)j
X    + (a1 d2 + b1 c2  c1 b2 + d1 a2)k
X       a1 a2  b1 b2  c1 c2  d1 d2
X   */
X#if defined(__wasm__) && defined(__wasm_simd128__)
X  glm_quat_mul_wasm(p, q, dest);
X#elif defined( __SSE__ ) || defined( __SSE2__ )
X  glm_quat_mul_sse2(p, q, dest);
X#elif defined(CGLM_NEON_FP)
X  glm_quat_mul_neon(p, q, dest);
X#else
X  dest[0] = p[3] * q[0] + p[0] * q[3] + p[1] * q[2] - p[2] * q[1];
X  dest[1] = p[3] * q[1] - p[0] * q[2] + p[1] * q[3] + p[2] * q[0];
X  dest[2] = p[3] * q[2] + p[0] * q[1] - p[1] * q[0] + p[2] * q[3];
X  dest[3] = p[3] * q[3] - p[0] * q[0] - p[1] * q[1] - p[2] * q[2];
X#endif
X}
X
X/*!
X * @brief convert quaternion to mat4
X *
X * @param[in]   q     quaternion
X * @param[out]  dest  result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_quat_mat4(versor q, mat4 dest) {
X  float w, x, y, z,
X        xx, yy, zz,
X        xy, yz, xz,
X        wx, wy, wz, norm, s;
X
X  norm = glm_quat_norm(q);
X  s    = norm > 0.0f ? 2.0f / norm : 0.0f;
X
X  x = q[0];
X  y = q[1];
X  z = q[2];
X  w = q[3];
X
X  xx = s * x * x;   xy = s * x * y;   wx = s * w * x;
X  yy = s * y * y;   yz = s * y * z;   wy = s * w * y;
X  zz = s * z * z;   xz = s * x * z;   wz = s * w * z;
X
X  dest[0][0] = 1.0f - yy - zz;
X  dest[1][1] = 1.0f - xx - zz;
X  dest[2][2] = 1.0f - xx - yy;
X
X  dest[0][1] = xy + wz;
X  dest[1][2] = yz + wx;
X  dest[2][0] = xz + wy;
X
X  dest[1][0] = xy - wz;
X  dest[2][1] = yz - wx;
X  dest[0][2] = xz - wy;
X
X  dest[0][3] = 0.0f;
X  dest[1][3] = 0.0f;
X  dest[2][3] = 0.0f;
X  dest[3][0] = 0.0f;
X  dest[3][1] = 0.0f;
X  dest[3][2] = 0.0f;
X  dest[3][3] = 1.0f;
X}
X
X/*!
X * @brief convert quaternion to mat4 (transposed)
X *
X * @param[in]   q     quaternion
X * @param[out]  dest  result matrix as transposed
X */
XCGLM_INLINE
Xvoid
Xglm_quat_mat4t(versor q, mat4 dest) {
X  float w, x, y, z,
X        xx, yy, zz,
X        xy, yz, xz,
X        wx, wy, wz, norm, s;
X
X  norm = glm_quat_norm(q);
X  s    = norm > 0.0f ? 2.0f / norm : 0.0f;
X
X  x = q[0];
X  y = q[1];
X  z = q[2];
X  w = q[3];
X
X  xx = s * x * x;   xy = s * x * y;   wx = s * w * x;
X  yy = s * y * y;   yz = s * y * z;   wy = s * w * y;
X  zz = s * z * z;   xz = s * x * z;   wz = s * w * z;
X
X  dest[0][0] = 1.0f - yy - zz;
X  dest[1][1] = 1.0f - xx - zz;
X  dest[2][2] = 1.0f - xx - yy;
X
X  dest[1][0] = xy + wz;
X  dest[2][1] = yz + wx;
X  dest[0][2] = xz + wy;
X
X  dest[0][1] = xy - wz;
X  dest[1][2] = yz - wx;
X  dest[2][0] = xz - wy;
X
X  dest[0][3] = 0.0f;
X  dest[1][3] = 0.0f;
X  dest[2][3] = 0.0f;
X  dest[3][0] = 0.0f;
X  dest[3][1] = 0.0f;
X  dest[3][2] = 0.0f;
X  dest[3][3] = 1.0f;
X}
X
X/*!
X * @brief convert quaternion to mat3
X *
X * @param[in]   q     quaternion
X * @param[out]  dest  result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_quat_mat3(versor q, mat3 dest) {
X  float w, x, y, z,
X        xx, yy, zz,
X        xy, yz, xz,
X        wx, wy, wz, norm, s;
X
X  norm = glm_quat_norm(q);
X  s    = norm > 0.0f ? 2.0f / norm : 0.0f;
X
X  x = q[0];
X  y = q[1];
X  z = q[2];
X  w = q[3];
X
X  xx = s * x * x;   xy = s * x * y;   wx = s * w * x;
X  yy = s * y * y;   yz = s * y * z;   wy = s * w * y;
X  zz = s * z * z;   xz = s * x * z;   wz = s * w * z;
X
X  dest[0][0] = 1.0f - yy - zz;
X  dest[1][1] = 1.0f - xx - zz;
X  dest[2][2] = 1.0f - xx - yy;
X
X  dest[0][1] = xy + wz;
X  dest[1][2] = yz + wx;
X  dest[2][0] = xz + wy;
X
X  dest[1][0] = xy - wz;
X  dest[2][1] = yz - wx;
X  dest[0][2] = xz - wy;
X}
X
X/*!
X * @brief convert quaternion to mat3 (transposed)
X *
X * @param[in]   q     quaternion
X * @param[out]  dest  result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_quat_mat3t(versor q, mat3 dest) {
X  float w, x, y, z,
X        xx, yy, zz,
X        xy, yz, xz,
X        wx, wy, wz, norm, s;
X
X  norm = glm_quat_norm(q);
X  s    = norm > 0.0f ? 2.0f / norm : 0.0f;
X
X  x = q[0];
X  y = q[1];
X  z = q[2];
X  w = q[3];
X
X  xx = s * x * x;   xy = s * x * y;   wx = s * w * x;
X  yy = s * y * y;   yz = s * y * z;   wy = s * w * y;
X  zz = s * z * z;   xz = s * x * z;   wz = s * w * z;
X
X  dest[0][0] = 1.0f - yy - zz;
X  dest[1][1] = 1.0f - xx - zz;
X  dest[2][2] = 1.0f - xx - yy;
X
X  dest[1][0] = xy + wz;
X  dest[2][1] = yz + wx;
X  dest[0][2] = xz + wy;
X
X  dest[0][1] = xy - wz;
X  dest[1][2] = yz - wx;
X  dest[2][0] = xz - wy;
X}
X
X/*!
X * @brief interpolates between two quaternions
X *        using linear interpolation (LERP)
X *
X * @param[in]   from  from
X * @param[in]   to    to
X * @param[in]   t     interpolant (amount)
X * @param[out]  dest  result quaternion
X */
XCGLM_INLINE
Xvoid
Xglm_quat_lerp(versor from, versor to, float t, versor dest) {
X  glm_vec4_lerp(from, to, t, dest);
X}
X
X/*!
X * @brief interpolates between two quaternions
X *        using linear interpolation (LERP)
X *
X * @param[in]   from  from
X * @param[in]   to    to
X * @param[in]   t     interpolant (amount) clamped between 0 and 1
X * @param[out]  dest  result quaternion
X */
XCGLM_INLINE
Xvoid
Xglm_quat_lerpc(versor from, versor to, float t, versor dest) {
X  glm_vec4_lerpc(from, to, t, dest);
X}
X
X/*!
X * @brief interpolates between two quaternions
X *        taking the shortest rotation path using
X *        normalized linear interpolation (NLERP)
X *
X * @param[in]   from  from
X * @param[in]   to    to
X * @param[in]   t     interpolant (amount)
X * @param[out]  dest  result quaternion
X */
XCGLM_INLINE
Xvoid
Xglm_quat_nlerp(versor from, versor to, float t, versor dest) {
X  versor target;
X  float  dot;
X  
X  dot = glm_vec4_dot(from, to);
X  
X  glm_vec4_scale(to, (dot >= 0) ? 1.0f : -1.0f, target);
X  glm_quat_lerp(from, target, t, dest);
X  glm_quat_normalize(dest);
X}
X
X/*!
X * @brief interpolates between two quaternions
X *        using spherical linear interpolation (SLERP)
X *
X * @param[in]   from  from
X * @param[in]   to    to
X * @param[in]   t     amout
X * @param[out]  dest  result quaternion
X */
XCGLM_INLINE
Xvoid
Xglm_quat_slerp(versor from, versor to, float t, versor dest) {
X  CGLM_ALIGN(16) vec4 q1, q2;
X  float cosTheta, sinTheta, angle;
X
X  cosTheta = glm_quat_dot(from, to);
X  glm_quat_copy(from, q1);
X
X  if (fabsf(cosTheta) >= 1.0f) {
X    glm_quat_copy(q1, dest);
X    return;
X  }
X
X  if (cosTheta < 0.0f) {
X    glm_vec4_negate(q1);
X    cosTheta = -cosTheta;
X  }
X
X  sinTheta = sqrtf(1.0f - cosTheta * cosTheta);
X
X  /* LERP to avoid zero division */
X  if (fabsf(sinTheta) < 0.001f) {
X    glm_quat_lerp(from, to, t, dest);
X    return;
X  }
X
X  /* SLERP */
X  angle = acosf(cosTheta);
X  glm_vec4_scale(q1, sinf((1.0f - t) * angle), q1);
X  glm_vec4_scale(to, sinf(t * angle), q2);
X
X  glm_vec4_add(q1, q2, q1);
X  glm_vec4_scale(q1, 1.0f / sinTheta, dest);
X}
X
X/*!
X * @brief creates view matrix using quaternion as camera orientation
X *
X * @param[in]   eye   eye
X * @param[in]   ori   orientation in world space as quaternion
X * @param[out]  dest  view matrix
X */
XCGLM_INLINE
Xvoid
Xglm_quat_look(vec3 eye, versor ori, mat4 dest) {
X  /* orientation */
X  glm_quat_mat4t(ori, dest);
X
X  /* translate */
X  glm_mat4_mulv3(dest, eye, 1.0f, dest[3]);
X  glm_vec3_negate(dest[3]);
X}
X
X/*!
X * @brief creates look rotation quaternion
X *
X * @param[in]   dir   direction to look
X * @param[in]   up    up vector
X * @param[out]  dest  destination quaternion
X */
XCGLM_INLINE
Xvoid
Xglm_quat_for(vec3 dir, vec3 up, versor dest) {
X  CGLM_ALIGN_MAT mat3 m;
X
X  glm_vec3_normalize_to(dir, m[2]); 
X
X  /* No need to negate in LH, but we use RH here */
X  glm_vec3_negate(m[2]);
X  
X  glm_vec3_crossn(up, m[2], m[0]);
X  glm_vec3_cross(m[2], m[0], m[1]);
X
X  glm_mat3_quat(m, dest);
X}
X
X/*!
X * @brief creates look rotation quaternion using source and
X *        destination positions p suffix stands for position
X *
X * @param[in]   from  source point
X * @param[in]   to    destination point
X * @param[in]   up    up vector
X * @param[out]  dest  destination quaternion
X */
XCGLM_INLINE
Xvoid
Xglm_quat_forp(vec3 from, vec3 to, vec3 up, versor dest) {
X  CGLM_ALIGN(8) vec3 dir;
X  glm_vec3_sub(to, from, dir);
X  glm_quat_for(dir, up, dest);
X}
X
X/*!
X * @brief rotate vector using using quaternion
X *
X * @param[in]   q     quaternion
X * @param[in]   v     vector to rotate
X * @param[out]  dest  rotated vector
X */
XCGLM_INLINE
Xvoid
Xglm_quat_rotatev(versor q, vec3 v, vec3 dest) {
X  CGLM_ALIGN(16) versor p;
X  CGLM_ALIGN(8)  vec3   u, v1, v2;
X  float s;
X
X  glm_quat_normalize_to(q, p);
X  glm_quat_imag(p, u);
X  s = glm_quat_real(p);
X
X  glm_vec3_scale(u, 2.0f * glm_vec3_dot(u, v), v1);
X  glm_vec3_scale(v, s * s - glm_vec3_dot(u, u), v2);
X  glm_vec3_add(v1, v2, v1);
X
X  glm_vec3_cross(u, v, v2);
X  glm_vec3_scale(v2, 2.0f * s, v2);
X
X  glm_vec3_add(v1, v2, dest);
X}
X
X/*!
X * @brief rotate existing transform matrix using quaternion
X *
X * @param[in]   m     existing transform matrix
X * @param[in]   q     quaternion
X * @param[out]  dest  rotated matrix/transform
X */
XCGLM_INLINE
Xvoid
Xglm_quat_rotate(mat4 m, versor q, mat4 dest) {
X  CGLM_ALIGN_MAT mat4 rot;
X  glm_quat_mat4(q, rot);
X  glm_mul_rot(m, rot, dest);
X}
X
X/*!
X * @brief rotate existing transform matrix using quaternion at pivot point
X *
X * @param[in, out]   m     existing transform matrix
X * @param[in]        q     quaternion
X * @param[out]       pivot pivot
X */
XCGLM_INLINE
Xvoid
Xglm_quat_rotate_at(mat4 m, versor q, vec3 pivot) {
X  CGLM_ALIGN(8) vec3 pivotInv;
X
X  glm_vec3_negate_to(pivot, pivotInv);
X
X  glm_translate(m, pivot);
X  glm_quat_rotate(m, q, m);
X  glm_translate(m, pivotInv);
X}
X
X/*!
X * @brief rotate NEW transform matrix using quaternion at pivot point
X *
X * this creates rotation matrix, it assumes you don't have a matrix
X *
X * this should work faster than glm_quat_rotate_at because it reduces
X * one glm_translate.
X *
X * @param[out]  m     existing transform matrix
X * @param[in]   q     quaternion
X * @param[in]   pivot pivot
X */
XCGLM_INLINE
Xvoid
Xglm_quat_rotate_atm(mat4 m, versor q, vec3 pivot) {
X  CGLM_ALIGN(8) vec3 pivotInv;
X
X  glm_vec3_negate_to(pivot, pivotInv);
X
X  glm_translate_make(m, pivot);
X  glm_quat_rotate(m, q, m);
X  glm_translate(m, pivotInv);
X}
X
X/*!
X * @brief Create quaternion from pointer
X *
X * @param[in]  src  pointer to an array of floats
X * @param[out] dest quaternion
X */
XCGLM_INLINE
Xvoid
Xglm_quat_make(float * __restrict src, versor dest) {
X  dest[0] = src[0]; dest[1] = src[1];
X  dest[2] = src[2]; dest[3] = src[3];
X}
X
X#endif /* cglm_quat_h */
04c24ba264492706af55aaf3fb20addf
echo x - cglm/plane.h
sed 's/^X//' >cglm/plane.h << 'ef16300b3def293d45202ced392bd452'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_plane_h
X#define cglm_plane_h
X
X#include "common.h"
X#include "vec3.h"
X#include "vec4.h"
X
X/*
X Plane equation:  Ax + By + Cz + D = 0;
X
X It stored in vec4 as [A, B, C, D]. (A, B, C) is normal and D is distance
X*/
X
X/*
X Functions:
X   CGLM_INLINE void  glm_plane_normalize(vec4 plane);
X */
X
X/*!
X * @brief normalizes a plane
X *
X * @param[in, out] plane plane to normalize
X */
XCGLM_INLINE
Xvoid
Xglm_plane_normalize(vec4 plane) {
X  float norm;
X  
X  if ((norm = glm_vec3_norm(plane)) == 0.0f) {
X    glm_vec4_zero(plane);
X    return;
X  }
X  
X  glm_vec4_scale(plane, 1.0f / norm, plane);
X}
X
X#endif /* cglm_plane_h */
ef16300b3def293d45202ced392bd452
echo x - cglm/frustum.h
sed 's/^X//' >cglm/frustum.h << '01c658057a2f261c6e0a32a04d5a5f8b'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_frustum_h
X#define cglm_frustum_h
X
X#include "common.h"
X#include "plane.h"
X#include "vec3.h"
X#include "vec4.h"
X#include "mat4.h"
X
X#define GLM_LBN 0 /* left  bottom near */
X#define GLM_LTN 1 /* left  top    near */
X#define GLM_RTN 2 /* right top    near */
X#define GLM_RBN 3 /* right bottom near */
X
X#define GLM_LBF 4 /* left  bottom far  */
X#define GLM_LTF 5 /* left  top    far  */
X#define GLM_RTF 6 /* right top    far  */
X#define GLM_RBF 7 /* right bottom far  */
X
X#define GLM_LEFT   0
X#define GLM_RIGHT  1
X#define GLM_BOTTOM 2
X#define GLM_TOP    3
X#define GLM_NEAR   4
X#define GLM_FAR    5
X
X/* you can override clip space coords
X   but you have to provide all with same name
X   e.g.: define GLM_CSCOORD_LBN {0.0f, 0.0f, 1.0f, 1.0f} */
X#ifndef GLM_CUSTOM_CLIPSPACE
X
X/* near */
X#define GLM_CSCOORD_LBN {-1.0f, -1.0f, -1.0f, 1.0f}
X#define GLM_CSCOORD_LTN {-1.0f,  1.0f, -1.0f, 1.0f}
X#define GLM_CSCOORD_RTN { 1.0f,  1.0f, -1.0f, 1.0f}
X#define GLM_CSCOORD_RBN { 1.0f, -1.0f, -1.0f, 1.0f}
X
X/* far */
X#define GLM_CSCOORD_LBF {-1.0f, -1.0f,  1.0f, 1.0f}
X#define GLM_CSCOORD_LTF {-1.0f,  1.0f,  1.0f, 1.0f}
X#define GLM_CSCOORD_RTF { 1.0f,  1.0f,  1.0f, 1.0f}
X#define GLM_CSCOORD_RBF { 1.0f, -1.0f,  1.0f, 1.0f}
X
X#endif
X
X/*!
X * @brief extracts view frustum planes
X *
X * planes' space:
X *  1- if m = proj:     View Space
X *  2- if m = viewProj: World Space
X *  3- if m = MVP:      Object Space
X *
X * You probably want to extract planes in world space so use viewProj as m
X * Computing viewProj:
X *   glm_mat4_mul(proj, view, viewProj);
X *
X * Exracted planes order: [left, right, bottom, top, near, far]
X *
X * @param[in]  m    matrix (see brief)
X * @param[out] dest extracted view frustum planes (see brief)
X */
XCGLM_INLINE
Xvoid
Xglm_frustum_planes(mat4 m, vec4 dest[6]) {
X  mat4 t;
X
X  glm_mat4_transpose_to(m, t);
X
X  glm_vec4_add(t[3], t[0], dest[0]); /* left   */
X  glm_vec4_sub(t[3], t[0], dest[1]); /* right  */
X  glm_vec4_add(t[3], t[1], dest[2]); /* bottom */
X  glm_vec4_sub(t[3], t[1], dest[3]); /* top    */
X  glm_vec4_add(t[3], t[2], dest[4]); /* near   */
X  glm_vec4_sub(t[3], t[2], dest[5]); /* far    */
X
X  glm_plane_normalize(dest[0]);
X  glm_plane_normalize(dest[1]);
X  glm_plane_normalize(dest[2]);
X  glm_plane_normalize(dest[3]);
X  glm_plane_normalize(dest[4]);
X  glm_plane_normalize(dest[5]);
X}
X
X/*!
X * @brief extracts view frustum corners using clip-space coordinates
X *
X * corners' space:
X *  1- if m = invViewProj: World Space
X *  2- if m = invMVP:      Object Space
X *
X * You probably want to extract corners in world space so use invViewProj
X * Computing invViewProj:
X *   glm_mat4_mul(proj, view, viewProj);
X *   ...
X *   glm_mat4_inv(viewProj, invViewProj);
X *
X * if you have a near coord at i index, you can get it's far coord by i + 4
X *
X * Find center coordinates:
X *   for (j = 0; j < 4; j++) {
X *     glm_vec3_center(corners[i], corners[i + 4], centerCorners[i]);
X *   }
X *
X * @param[in]  invMat matrix (see brief)
X * @param[out] dest   exracted view frustum corners (see brief)
X */
XCGLM_INLINE
Xvoid
Xglm_frustum_corners(mat4 invMat, vec4 dest[8]) {
X  vec4 c[8];
X
X  /* indexOf(nearCoord) = indexOf(farCoord) + 4 */
X  vec4 csCoords[8] = {
X    GLM_CSCOORD_LBN,
X    GLM_CSCOORD_LTN,
X    GLM_CSCOORD_RTN,
X    GLM_CSCOORD_RBN,
X
X    GLM_CSCOORD_LBF,
X    GLM_CSCOORD_LTF,
X    GLM_CSCOORD_RTF,
X    GLM_CSCOORD_RBF
X  };
X
X  glm_mat4_mulv(invMat, csCoords[0], c[0]);
X  glm_mat4_mulv(invMat, csCoords[1], c[1]);
X  glm_mat4_mulv(invMat, csCoords[2], c[2]);
X  glm_mat4_mulv(invMat, csCoords[3], c[3]);
X  glm_mat4_mulv(invMat, csCoords[4], c[4]);
X  glm_mat4_mulv(invMat, csCoords[5], c[5]);
X  glm_mat4_mulv(invMat, csCoords[6], c[6]);
X  glm_mat4_mulv(invMat, csCoords[7], c[7]);
X
X  glm_vec4_scale(c[0], 1.0f / c[0][3], dest[0]);
X  glm_vec4_scale(c[1], 1.0f / c[1][3], dest[1]);
X  glm_vec4_scale(c[2], 1.0f / c[2][3], dest[2]);
X  glm_vec4_scale(c[3], 1.0f / c[3][3], dest[3]);
X  glm_vec4_scale(c[4], 1.0f / c[4][3], dest[4]);
X  glm_vec4_scale(c[5], 1.0f / c[5][3], dest[5]);
X  glm_vec4_scale(c[6], 1.0f / c[6][3], dest[6]);
X  glm_vec4_scale(c[7], 1.0f / c[7][3], dest[7]);
X}
X
X/*!
X * @brief finds center of view frustum
X *
X * @param[in]  corners view frustum corners
X * @param[out] dest    view frustum center
X */
XCGLM_INLINE
Xvoid
Xglm_frustum_center(vec4 corners[8], vec4 dest) {
X  vec4 center;
X
X  glm_vec4_copy(corners[0], center);
X
X  glm_vec4_add(corners[1], center, center);
X  glm_vec4_add(corners[2], center, center);
X  glm_vec4_add(corners[3], center, center);
X  glm_vec4_add(corners[4], center, center);
X  glm_vec4_add(corners[5], center, center);
X  glm_vec4_add(corners[6], center, center);
X  glm_vec4_add(corners[7], center, center);
X
X  glm_vec4_scale(center, 0.125f, dest);
X}
X
X/*!
X * @brief finds bounding box of frustum relative to given matrix e.g. view mat
X *
X * @param[in]  corners view frustum corners
X * @param[in]  m       matrix to convert existing conners
X * @param[out] box     bounding box as array [min, max]
X */
XCGLM_INLINE
Xvoid
Xglm_frustum_box(vec4 corners[8], mat4 m, vec3 box[2]) {
X  vec4 v;
X  vec3 min, max;
X  int  i;
X
X  glm_vec3_broadcast(FLT_MAX, min);
X  glm_vec3_broadcast(-FLT_MAX, max);
X
X  for (i = 0; i < 8; i++) {
X    glm_mat4_mulv(m, corners[i], v);
X
X    min[0] = glm_min(min[0], v[0]);
X    min[1] = glm_min(min[1], v[1]);
X    min[2] = glm_min(min[2], v[2]);
X
X    max[0] = glm_max(max[0], v[0]);
X    max[1] = glm_max(max[1], v[1]);
X    max[2] = glm_max(max[2], v[2]);
X  }
X
X  glm_vec3_copy(min, box[0]);
X  glm_vec3_copy(max, box[1]);
X}
X
X/*!
X * @brief finds planes corners which is between near and far planes (parallel)
X *
X * this will be helpful if you want to split a frustum e.g. CSM/PSSM. This will
X * find planes' corners but you will need to one more plane.
X * Actually you have it, it is near, far or created previously with this func ;)
X *
X * @param[in]  corners view  frustum corners
X * @param[in]  splitDist     split distance
X * @param[in]  farDist       far distance (zFar)
X * @param[out] planeCorners  plane corners [LB, LT, RT, RB]
X */
XCGLM_INLINE
Xvoid
Xglm_frustum_corners_at(vec4  corners[8],
X                       float splitDist,
X                       float farDist,
X                       vec4  planeCorners[4]) {
X  vec4  corner;
X  float dist, sc;
X
X  /* because distance and scale is same for all */
X  dist = glm_vec3_distance(corners[GLM_RTF], corners[GLM_RTN]);
X  sc   = dist * (splitDist / farDist);
X
X  /* left bottom */
X  glm_vec4_sub(corners[GLM_LBF], corners[GLM_LBN], corner);
X  glm_vec4_scale_as(corner, sc, corner);
X  glm_vec4_add(corners[GLM_LBN], corner, planeCorners[0]);
X
X  /* left top */
X  glm_vec4_sub(corners[GLM_LTF], corners[GLM_LTN], corner);
X  glm_vec4_scale_as(corner, sc, corner);
X  glm_vec4_add(corners[GLM_LTN], corner, planeCorners[1]);
X
X  /* right top */
X  glm_vec4_sub(corners[GLM_RTF], corners[GLM_RTN], corner);
X  glm_vec4_scale_as(corner, sc, corner);
X  glm_vec4_add(corners[GLM_RTN], corner, planeCorners[2]);
X
X  /* right bottom */
X  glm_vec4_sub(corners[GLM_RBF], corners[GLM_RBN], corner);
X  glm_vec4_scale_as(corner, sc, corner);
X  glm_vec4_add(corners[GLM_RBN], corner, planeCorners[3]);
X}
X
X#endif /* cglm_frustum_h */
01c658057a2f261c6e0a32a04d5a5f8b
echo x - cglm/box.h
sed 's/^X//' >cglm/box.h << '20d63fee5723077625ce950a94b6d469'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_box_h
X#define cglm_box_h
X
X#include "common.h"
X#include "vec3.h"
X#include "vec4.h"
X#include "util.h"
X
X/*!
X * @brief apply transform to Axis-Aligned Bounding Box
X *
X * @param[in]  box  bounding box
X * @param[in]  m    transform matrix
X * @param[out] dest transformed bounding box
X */
XCGLM_INLINE
Xvoid
Xglm_aabb_transform(vec3 box[2], mat4 m, vec3 dest[2]) {
X  vec3 v[2], xa, xb, ya, yb, za, zb;
X
X  glm_vec3_scale(m[0], box[0][0], xa);
X  glm_vec3_scale(m[0], box[1][0], xb);
X
X  glm_vec3_scale(m[1], box[0][1], ya);
X  glm_vec3_scale(m[1], box[1][1], yb);
X
X  glm_vec3_scale(m[2], box[0][2], za);
X  glm_vec3_scale(m[2], box[1][2], zb);
X
X  /* translation + min(xa, xb) + min(ya, yb) + min(za, zb) */
X  glm_vec3(m[3], v[0]);
X  glm_vec3_minadd(xa, xb, v[0]);
X  glm_vec3_minadd(ya, yb, v[0]);
X  glm_vec3_minadd(za, zb, v[0]);
X
X  /* translation + max(xa, xb) + max(ya, yb) + max(za, zb) */
X  glm_vec3(m[3], v[1]);
X  glm_vec3_maxadd(xa, xb, v[1]);
X  glm_vec3_maxadd(ya, yb, v[1]);
X  glm_vec3_maxadd(za, zb, v[1]);
X
X  glm_vec3_copy(v[0], dest[0]);
X  glm_vec3_copy(v[1], dest[1]);
X}
X
X/*!
X * @brief merges two AABB bounding box and creates new one
X *
X * two box must be in same space, if one of box is in different space then
X * you should consider to convert it's space by glm_box_space
X *
X * @param[in]  box1 bounding box 1
X * @param[in]  box2 bounding box 2
X * @param[out] dest merged bounding box
X */
XCGLM_INLINE
Xvoid
Xglm_aabb_merge(vec3 box1[2], vec3 box2[2], vec3 dest[2]) {
X  dest[0][0] = glm_min(box1[0][0], box2[0][0]);
X  dest[0][1] = glm_min(box1[0][1], box2[0][1]);
X  dest[0][2] = glm_min(box1[0][2], box2[0][2]);
X
X  dest[1][0] = glm_max(box1[1][0], box2[1][0]);
X  dest[1][1] = glm_max(box1[1][1], box2[1][1]);
X  dest[1][2] = glm_max(box1[1][2], box2[1][2]);
X}
X
X/*!
X * @brief crops a bounding box with another one.
X *
X * this could be useful for gettng a bbox which fits with view frustum and
X * object bounding boxes. In this case you crop view frustum box with objects
X * box
X *
X * @param[in]  box     bounding box 1
X * @param[in]  cropBox crop box
X * @param[out] dest    cropped bounding box
X */
XCGLM_INLINE
Xvoid
Xglm_aabb_crop(vec3 box[2], vec3 cropBox[2], vec3 dest[2]) {
X  dest[0][0] = glm_max(box[0][0], cropBox[0][0]);
X  dest[0][1] = glm_max(box[0][1], cropBox[0][1]);
X  dest[0][2] = glm_max(box[0][2], cropBox[0][2]);
X
X  dest[1][0] = glm_min(box[1][0], cropBox[1][0]);
X  dest[1][1] = glm_min(box[1][1], cropBox[1][1]);
X  dest[1][2] = glm_min(box[1][2], cropBox[1][2]);
X}
X
X/*!
X * @brief crops a bounding box with another one.
X *
X * this could be useful for gettng a bbox which fits with view frustum and
X * object bounding boxes. In this case you crop view frustum box with objects
X * box
X *
X * @param[in]  box      bounding box
X * @param[in]  cropBox  crop box
X * @param[in]  clampBox miniumum box
X * @param[out] dest     cropped bounding box
X */
XCGLM_INLINE
Xvoid
Xglm_aabb_crop_until(vec3 box[2],
X                    vec3 cropBox[2],
X                    vec3 clampBox[2],
X                    vec3 dest[2]) {
X  glm_aabb_crop(box, cropBox, dest);
X  glm_aabb_merge(clampBox, dest, dest);
X}
X
X/*!
X * @brief check if AABB intersects with frustum planes
X *
X * this could be useful for frustum culling using AABB.
X *
X * OPTIMIZATION HINT:
X *  if planes order is similar to LEFT, RIGHT, BOTTOM, TOP, NEAR, FAR
X *  then this method should run even faster because it would only use two
X *  planes if object is not inside the two planes
X *  fortunately cglm extracts planes as this order! just pass what you got!
X *
X * @param[in]  box     bounding box
X * @param[in]  planes  frustum planes
X */
XCGLM_INLINE
Xbool
Xglm_aabb_frustum(vec3 box[2], vec4 planes[6]) {
X  float *p, dp;
X  int    i;
X
X  for (i = 0; i < 6; i++) {
X    p  = planes[i];
X    dp = p[0] * box[p[0] > 0.0f][0]
X       + p[1] * box[p[1] > 0.0f][1]
X       + p[2] * box[p[2] > 0.0f][2];
X
X    if (dp < -p[3])
X      return false;
X  }
X
X  return true;
X}
X
X/*!
X * @brief invalidate AABB min and max values
X *
X * @param[in, out]  box bounding box
X */
XCGLM_INLINE
Xvoid
Xglm_aabb_invalidate(vec3 box[2]) {
X  glm_vec3_broadcast(FLT_MAX,  box[0]);
X  glm_vec3_broadcast(-FLT_MAX, box[1]);
X}
X
X/*!
X * @brief check if AABB is valid or not
X *
X * @param[in]  box bounding box
X */
XCGLM_INLINE
Xbool
Xglm_aabb_isvalid(vec3 box[2]) {
X  return glm_vec3_max(box[0]) != FLT_MAX
X         && glm_vec3_min(box[1]) != -FLT_MAX;
X}
X
X/*!
X * @brief distance between of min and max
X *
X * @param[in]  box bounding box
X */
XCGLM_INLINE
Xfloat
Xglm_aabb_size(vec3 box[2]) {
X  return glm_vec3_distance(box[0], box[1]);
X}
X
X/*!
X * @brief radius of sphere which surrounds AABB
X *
X * @param[in]  box bounding box
X */
XCGLM_INLINE
Xfloat
Xglm_aabb_radius(vec3 box[2]) {
X  return glm_aabb_size(box) * 0.5f;
X}
X
X/*!
X * @brief computes center point of AABB
X *
X * @param[in]   box  bounding box
X * @param[out]  dest center of bounding box
X */
XCGLM_INLINE
Xvoid
Xglm_aabb_center(vec3 box[2], vec3 dest) {
X  glm_vec3_center(box[0], box[1], dest);
X}
X
X/*!
X * @brief check if two AABB intersects
X *
X * @param[in]   box    bounding box
X * @param[in]   other  other bounding box
X */
XCGLM_INLINE
Xbool
Xglm_aabb_aabb(vec3 box[2], vec3 other[2]) {
X  return (box[0][0] <= other[1][0] && box[1][0] >= other[0][0])
X      && (box[0][1] <= other[1][1] && box[1][1] >= other[0][1])
X      && (box[0][2] <= other[1][2] && box[1][2] >= other[0][2]);
X}
X
X/*!
X * @brief check if AABB intersects with sphere
X *
X * https://github.com/erich666/GraphicsGems/blob/master/gems/BoxSphere.c
X * Solid Box - Solid Sphere test.
X *
X * Sphere Representation in cglm: [center.x, center.y, center.z, radii]
X *
X * @param[in]   box    solid bounding box
X * @param[in]   s      solid sphere
X */
XCGLM_INLINE
Xbool
Xglm_aabb_sphere(vec3 box[2], vec4 s) {
X  float dmin;
X  int   a, b, c;
X
X  a = (s[0] < box[0][0]) + (s[0] > box[1][0]);
X  b = (s[1] < box[0][1]) + (s[1] > box[1][1]);
X  c = (s[2] < box[0][2]) + (s[2] > box[1][2]);
X
X  dmin  = glm_pow2((s[0] - box[!(a - 1)][0]) * (a != 0))
X        + glm_pow2((s[1] - box[!(b - 1)][1]) * (b != 0))
X        + glm_pow2((s[2] - box[!(c - 1)][2]) * (c != 0));
X
X  return dmin <= glm_pow2(s[3]);
X}
X
X/*!
X * @brief check if point is inside of AABB
X *
X * @param[in]   box    bounding box
X * @param[in]   point  point
X */
XCGLM_INLINE
Xbool
Xglm_aabb_point(vec3 box[2], vec3 point) {
X  return (point[0] >= box[0][0] && point[0] <= box[1][0])
X      && (point[1] >= box[0][1] && point[1] <= box[1][1])
X      && (point[2] >= box[0][2] && point[2] <= box[1][2]);
X}
X
X/*!
X * @brief check if AABB contains other AABB
X *
X * @param[in]   box    bounding box
X * @param[in]   other  other bounding box
X */
XCGLM_INLINE
Xbool
Xglm_aabb_contains(vec3 box[2], vec3 other[2]) {
X  return (box[0][0] <= other[0][0] && box[1][0] >= other[1][0])
X      && (box[0][1] <= other[0][1] && box[1][1] >= other[1][1])
X      && (box[0][2] <= other[0][2] && box[1][2] >= other[1][2]);
X}
X
X#endif /* cglm_box_h */
20d63fee5723077625ce950a94b6d469
echo x - cglm/color.h
sed 's/^X//' >cglm/color.h << '75775576c252bf6b3ef7896fe3394e85'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_color_h
X#define cglm_color_h
X
X#include "common.h"
X#include "vec3.h"
X
X/*!
X * @brief averages the color channels into one value
X *
X * @param[in]  rgb RGB color
X */
XCGLM_INLINE
Xfloat
Xglm_luminance(vec3 rgb) {
X  vec3 l = {0.212671f, 0.715160f, 0.072169f};
X  return glm_dot(rgb, l);
X}
X
X#endif /* cglm_color_h */
75775576c252bf6b3ef7896fe3394e85
echo x - cglm/project.h
sed 's/^X//' >cglm/project.h << 'd53373bd0b9407e49d349fae772049f0'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_project_h
X#define cglm_project_h
X
X#include "common.h"
X#include "vec3.h"
X#include "vec4.h"
X#include "mat4.h"
X
X#ifndef CGLM_CLIPSPACE_INCLUDE_ALL
X#  if CGLM_CONFIG_CLIP_CONTROL & CGLM_CLIP_CONTROL_ZO_BIT
X#    include "clipspace/project_zo.h"
X#  elif CGLM_CONFIG_CLIP_CONTROL & CGLM_CLIP_CONTROL_NO_BIT
X#    include "clipspace/project_no.h"
X#  endif
X#else
X#  include "clipspace/project_zo.h"
X#  include "clipspace/project_no.h"
X#endif
X
X/*!
X * @brief maps the specified viewport coordinates into specified space [1]
X *        the matrix should contain projection matrix.
X *
X * if you don't have ( and don't want to have ) an inverse matrix then use
X * glm_unproject version. You may use existing inverse of matrix in somewhere
X * else, this is why glm_unprojecti exists to save save inversion cost
X *
X * [1] space:
X *  1- if m = invProj:     View Space
X *  2- if m = invViewProj: World Space
X *  3- if m = invMVP:      Object Space
X *
X * You probably want to map the coordinates into object space
X * so use invMVP as m
X *
X * Computing viewProj:
X *   glm_mat4_mul(proj, view, viewProj);
X *   glm_mat4_mul(viewProj, model, MVP);
X *   glm_mat4_inv(viewProj, invMVP);
X *
X * @param[in]  pos      point/position in viewport coordinates
X * @param[in]  invMat   matrix (see brief)
X * @param[in]  vp       viewport as [x, y, width, height]
X * @param[out] dest     unprojected coordinates
X */
XCGLM_INLINE
Xvoid
Xglm_unprojecti(vec3 pos, mat4 invMat, vec4 vp, vec3 dest) {
X#if CGLM_CONFIG_CLIP_CONTROL & CGLM_CLIP_CONTROL_ZO_BIT
X  glm_unprojecti_zo(pos, invMat, vp, dest);
X#elif CGLM_CONFIG_CLIP_CONTROL & CGLM_CLIP_CONTROL_NO_BIT
X  glm_unprojecti_no(pos, invMat, vp, dest);
X#endif
X}
X
X/*!
X * @brief maps the specified viewport coordinates into specified space [1]
X *        the matrix should contain projection matrix.
X *
X * this is same as glm_unprojecti except this function get inverse matrix for
X * you.
X *
X * [1] space:
X *  1- if m = proj:     View Space
X *  2- if m = viewProj: World Space
X *  3- if m = MVP:      Object Space
X *
X * You probably want to map the coordinates into object space
X * so use MVP as m
X *
X * Computing viewProj and MVP:
X *   glm_mat4_mul(proj, view, viewProj);
X *   glm_mat4_mul(viewProj, model, MVP);
X *
X * @param[in]  pos      point/position in viewport coordinates
X * @param[in]  m        matrix (see brief)
X * @param[in]  vp       viewport as [x, y, width, height]
X * @param[out] dest     unprojected coordinates
X */
XCGLM_INLINE
Xvoid
Xglm_unproject(vec3 pos, mat4 m, vec4 vp, vec3 dest) {
X  mat4 inv;
X  glm_mat4_inv(m, inv);
X  glm_unprojecti(pos, inv, vp, dest);
X}
X
X/*!
X * @brief map object coordinates to window coordinates
X *
X * Computing MVP:
X *   glm_mat4_mul(proj, view, viewProj);
X *   glm_mat4_mul(viewProj, model, MVP);
X *
X * @param[in]  pos      object coordinates
X * @param[in]  m        MVP matrix
X * @param[in]  vp       viewport as [x, y, width, height]
X * @param[out] dest     projected coordinates
X */
XCGLM_INLINE
Xvoid
Xglm_project(vec3 pos, mat4 m, vec4 vp, vec3 dest) {
X#if CGLM_CONFIG_CLIP_CONTROL & CGLM_CLIP_CONTROL_ZO_BIT
X  glm_project_zo(pos, m, vp, dest);
X#elif CGLM_CONFIG_CLIP_CONTROL & CGLM_CLIP_CONTROL_NO_BIT
X  glm_project_no(pos, m, vp, dest);
X#endif
X}
X
X/*!
X * @brief map object's z coordinate to window coordinates
X *
X * Computing MVP:
X *   glm_mat4_mul(proj, view, viewProj);
X *   glm_mat4_mul(viewProj, model, MVP);
X *
X * @param[in]  v  object coordinates
X * @param[in]  m  MVP matrix
X *
X * @returns projected z coordinate
X */
XCGLM_INLINE
Xfloat
Xglm_project_z(vec3 v, mat4 m) {
X#if CGLM_CONFIG_CLIP_CONTROL & CGLM_CLIP_CONTROL_ZO_BIT
X  return glm_project_z_zo(v, m);
X#elif CGLM_CONFIG_CLIP_CONTROL & CGLM_CLIP_CONTROL_NO_BIT
X  return glm_project_z_no(v, m);
X#endif
X}
X
X/*!
X * @brief define a picking region
X *
X * @param[in]  center   center [x, y] of a picking region in window coordinates
X * @param[in]  size     size [width, height] of the picking region in window coordinates
X * @param[in]  vp       viewport as [x, y, width, height]
X * @param[out] dest     projected coordinates
X */
XCGLM_INLINE
Xvoid
Xglm_pickmatrix(vec2 center, vec2 size, vec4 vp, mat4 dest) {
X  mat4 res;
X  vec3 v;
X
X  if (size[0] <= 0.0f || size[1] <= 0.0f)
X    return;
X  
X  /* Translate and scale the picked region to the entire window */
X  v[0] = (vp[2] - 2.0f * (center[0] - vp[0])) / size[0];
X  v[1] = (vp[3] - 2.0f * (center[1] - vp[1])) / size[1];
X  v[2] = 0.0f;
X
X  glm_translate_make(res, v);
X  
X  v[0] = vp[2] / size[0];
X  v[1] = vp[3] / size[1];
X  v[2] = 1.0f;
X
X  glm_scale(res, v);
X
X  glm_mat4_copy(res, dest);
X}
X
X#endif /* cglm_project_h */
d53373bd0b9407e49d349fae772049f0
echo x - cglm/sphere.h
sed 's/^X//' >cglm/sphere.h << '5b4f60bf1225b79f60850db0e2432643'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_sphere_h
X#define cglm_sphere_h
X
X#include "common.h"
X#include "mat4.h"
X
X/*
X  Sphere Representation in cglm: [center.x, center.y, center.z, radii]
X
X  You could use this representation or you can convert it to vec4 before call
X  any function
X */
X
X/*!
X * @brief helper for getting sphere radius
X *
X * @param[in]   s  sphere
X *
X * @return returns radii
X */
XCGLM_INLINE
Xfloat
Xglm_sphere_radii(vec4 s) {
X  return s[3];
X}
X
X/*!
X * @brief apply transform to sphere, it is just wrapper for glm_mat4_mulv3
X *
X * @param[in]  s    sphere
X * @param[in]  m    transform matrix
X * @param[out] dest transformed sphere
X */
XCGLM_INLINE
Xvoid
Xglm_sphere_transform(vec4 s, mat4 m, vec4 dest) {
X  glm_mat4_mulv3(m, s, 1.0f, dest);
X  dest[3] = s[3];
X}
X
X/*!
X * @brief merges two spheres and creates a new one
X *
X * two sphere must be in same space, for instance if one in world space then
X * the other must be in world space too, not in local space.
X *
X * @param[in]  s1   sphere 1
X * @param[in]  s2   sphere 2
X * @param[out] dest merged/extended sphere
X */
XCGLM_INLINE
Xvoid
Xglm_sphere_merge(vec4 s1, vec4 s2, vec4 dest) {
X  float dist, radii;
X
X  dist  = glm_vec3_distance(s1, s2);
X  radii = dist + s1[3] + s2[3];
X
X  radii = glm_max(radii, s1[3]);
X  radii = glm_max(radii, s2[3]);
X
X  glm_vec3_center(s1, s2, dest);
X  dest[3] = radii;
X}
X
X/*!
X * @brief check if two sphere intersects
X *
X * @param[in]   s1  sphere
X * @param[in]   s2  other sphere
X */
XCGLM_INLINE
Xbool
Xglm_sphere_sphere(vec4 s1, vec4 s2) {
X  return glm_vec3_distance2(s1, s2) <= glm_pow2(s1[3] + s2[3]);
X}
X
X/*!
X * @brief check if sphere intersects with point
X *
X * @param[in]   s      sphere
X * @param[in]   point  point
X */
XCGLM_INLINE
Xbool
Xglm_sphere_point(vec4 s, vec3 point) {
X  float rr;
X  rr = s[3] * s[3];
X  return glm_vec3_distance2(point, s) <= rr;
X}
X
X#endif /* cglm_sphere_h */
5b4f60bf1225b79f60850db0e2432643
echo x - cglm/ease.h
sed 's/^X//' >cglm/ease.h << 'f1bdf77d83be982a4e70fb1f888a17d4'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_ease_h
X#define cglm_ease_h
X
X#include "common.h"
X
XCGLM_INLINE
Xfloat
Xglm_ease_linear(float t) {
X  return t;
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_sine_in(float t) {
X  return sinf((t - 1.0f) * GLM_PI_2f) + 1.0f;
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_sine_out(float t) {
X  return sinf(t * GLM_PI_2f);
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_sine_inout(float t) {
X  return 0.5f * (1.0f - cosf(t * GLM_PIf));
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_quad_in(float t) {
X  return t * t;
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_quad_out(float t) {
X  return -(t * (t - 2.0f));
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_quad_inout(float t) {
X  float tt;
X
X  tt = t * t;
X  if (t < 0.5f)
X    return 2.0f * tt;
X
X  return (-2.0f * tt) + (4.0f * t) - 1.0f;
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_cubic_in(float t) {
X  return t * t * t;
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_cubic_out(float t) {
X  float f;
X  f = t - 1.0f;
X  return f * f * f + 1.0f;
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_cubic_inout(float t) {
X  float f;
X
X  if (t < 0.5f)
X    return 4.0f * t * t * t;
X
X  f = 2.0f * t - 2.0f;
X
X  return 0.5f * f * f * f + 1.0f;
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_quart_in(float t) {
X  float f;
X  f = t * t;
X  return f * f;
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_quart_out(float t) {
X  float f;
X
X  f = t - 1.0f;
X
X  return f * f * f * (1.0f - t) + 1.0f;
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_quart_inout(float t) {
X  float f, g;
X
X  if (t < 0.5f) {
X    f = t * t;
X    return 8.0f * f * f;
X  }
X
X  f = t - 1.0f;
X  g = f * f;
X
X  return -8.0f * g * g + 1.0f;
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_quint_in(float t) {
X  float f;
X  f = t * t;
X  return f * f * t;
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_quint_out(float t) {
X  float f, g;
X
X  f = t - 1.0f;
X  g = f * f;
X
X  return g * g * f + 1.0f;
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_quint_inout(float t) {
X  float f, g;
X
X  if (t < 0.5f) {
X    f = t * t;
X    return 16.0f * f * f * t;
X  }
X
X  f = 2.0f * t - 2.0f;
X  g = f * f;
X
X  return 0.5f * g * g * f + 1.0f;
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_exp_in(float t) {
X  if (t == 0.0f)
X    return t;
X
X  return powf(2.0f,  10.0f * (t - 1.0f));
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_exp_out(float t) {
X  if (t == 1.0f)
X    return t;
X
X  return 1.0f - powf(2.0f, -10.0f * t);
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_exp_inout(float t) {
X  if (t == 0.0f || t == 1.0f)
X    return t;
X
X  if (t < 0.5f)
X    return 0.5f * powf(2.0f, (20.0f * t) - 10.0f);
X
X  return -0.5f * powf(2.0f, (-20.0f * t) + 10.0f) + 1.0f;
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_circ_in(float t) {
X  return 1.0f - sqrtf(1.0f - (t * t));
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_circ_out(float t) {
X  return sqrtf((2.0f - t) * t);
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_circ_inout(float t) {
X  if (t < 0.5f)
X    return 0.5f * (1.0f - sqrtf(1.0f - 4.0f * (t * t)));
X
X  return 0.5f * (sqrtf(-((2.0f * t) - 3.0f) * ((2.0f * t) - 1.0f)) + 1.0f);
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_back_in(float t) {
X  float o, z;
X
X  o = 1.70158f;
X  z = ((o + 1.0f) * t) - o;
X
X  return t * t * z;
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_back_out(float t) {
X  float o, z, n;
X
X  o = 1.70158f;
X  n = t - 1.0f;
X  z = (o + 1.0f) * n + o;
X
X  return n * n * z + 1.0f;
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_back_inout(float t) {
X  float o, z, n, m, s, x;
X
X  o = 1.70158f;
X  s = o * 1.525f;
X  x = 0.5;
X  n = t / 0.5f;
X
X  if (n < 1.0f) {
X    z = (s + 1) * n - s;
X    m = n * n * z;
X    return x * m;
X  }
X
X  n -= 2.0f;
X  z  = (s + 1.0f) * n + s;
X  m  = (n * n * z) + 2;
X
X  return x * m;
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_elast_in(float t) {
X  return sinf(13.0f * GLM_PI_2f * t) * powf(2.0f, 10.0f * (t - 1.0f));
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_elast_out(float t) {
X  return sinf(-13.0f * GLM_PI_2f * (t + 1.0f)) * powf(2.0f, -10.0f * t) + 1.0f;
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_elast_inout(float t) {
X  float a;
X
X  a = 2.0f * t;
X
X  if (t < 0.5f)
X    return 0.5f * sinf(13.0f * GLM_PI_2f * a)
X                * powf(2.0f, 10.0f * (a - 1.0f));
X
X  return 0.5f * (sinf(-13.0f * GLM_PI_2f * a)
X                 * powf(2.0f, -10.0f * (a - 1.0f)) + 2.0f);
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_bounce_out(float t) {
X  float tt;
X
X  tt = t * t;
X
X  if (t < (4.0f / 11.0f))
X    return (121.0f * tt) / 16.0f;
X
X  if (t < 8.0f / 11.0f)
X    return ((363.0f / 40.0f) * tt) - ((99.0f / 10.0f) * t) + (17.0f / 5.0f);
X
X  if (t < (9.0f / 10.0f))
X    return (4356.0f / 361.0f) * tt
X            - (35442.0f / 1805.0f) * t
X            + (16061.0f / 1805.0f);
X
X  return ((54.0f / 5.0f) * tt) - ((513.0f / 25.0f) * t) + (268.0f / 25.0f);
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_bounce_in(float t) {
X  return 1.0f - glm_ease_bounce_out(1.0f - t);
X}
X
XCGLM_INLINE
Xfloat
Xglm_ease_bounce_inout(float t) {
X  if (t < 0.5f)
X    return 0.5f * (1.0f - glm_ease_bounce_out(t * 2.0f));
X
X  return 0.5f * glm_ease_bounce_out(t * 2.0f - 1.0f) + 0.5f;
X}
X
X#endif /* cglm_ease_h */
f1bdf77d83be982a4e70fb1f888a17d4
echo x - cglm/curve.h
sed 's/^X//' >cglm/curve.h << 'f676abf880a4119f5e2fddaded9d7dfc'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_curve_h
X#define cglm_curve_h
X
X#include "common.h"
X#include "vec4.h"
X#include "mat4.h"
X
X/*!
X * @brief helper function to calculate S*M*C multiplication for curves
X *
X * This function does not encourage you to use SMC,
X * instead it is a helper if you use SMC.
X *
X * if you want to specify S as vector then use more generic glm_mat4_rmc() func.
X *
X * Example usage:
X *  B(s) = glm_smc(s, GLM_BEZIER_MAT, (vec4){p0, c0, c1, p1})
X *
X * @param[in]  s  parameter between 0 and 1 (this will be [s3, s2, s, 1])
X * @param[in]  m  basis matrix
X * @param[in]  c  position/control vector
X *
X * @return B(s)
X */
XCGLM_INLINE
Xfloat
Xglm_smc(float s, mat4 m, vec4 c) {
X  vec4 vs;
X  glm_vec4_cubic(s, vs);
X  return glm_mat4_rmc(vs, m, c);
X}
X
X#endif /* cglm_curve_h */
f676abf880a4119f5e2fddaded9d7dfc
echo x - cglm/bezier.h
sed 's/^X//' >cglm/bezier.h << '25bfb9b54b305be1de485e1f3d083cd6'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_bezier_h
X#define cglm_bezier_h
X
X#include "common.h"
X
X#define GLM_BEZIER_MAT_INIT  {{-1.0f,  3.0f, -3.0f,  1.0f},                   \
X                              { 3.0f, -6.0f,  3.0f,  0.0f},                   \
X                              {-3.0f,  3.0f,  0.0f,  0.0f},                   \
X                              { 1.0f,  0.0f,  0.0f,  0.0f}}
X#define GLM_HERMITE_MAT_INIT {{ 2.0f, -3.0f,  0.0f,  1.0f},                   \
X                              {-2.0f,  3.0f,  0.0f,  0.0f},                   \
X                              { 1.0f, -2.0f,  1.0f,  0.0f},                   \
X                              { 1.0f, -1.0f,  0.0f,  0.0f}}
X/* for C only */
X#define GLM_BEZIER_MAT  ((mat4)GLM_BEZIER_MAT_INIT)
X#define GLM_HERMITE_MAT ((mat4)GLM_HERMITE_MAT_INIT)
X
X#define CGLM_DECASTEL_EPS   1e-9f
X#define CGLM_DECASTEL_MAX   1000
X#define CGLM_DECASTEL_SMALL 1e-20f
X
X/*!
X * @brief cubic bezier interpolation
X *
X * Formula:
X *  B(s) = P0*(1-s)^3 + 3*C0*s*(1-s)^2 + 3*C1*s^2*(1-s) + P1*s^3
X *
X * similar result using matrix:
X *  B(s) = glm_smc(t, GLM_BEZIER_MAT, (vec4){p0, c0, c1, p1})
X *
X * glm_eq(glm_smc(...), glm_bezier(...)) should return TRUE
X *
X * @param[in]  s    parameter between 0 and 1
X * @param[in]  p0   begin point
X * @param[in]  c0   control point 1
X * @param[in]  c1   control point 2
X * @param[in]  p1   end point
X *
X * @return B(s)
X */
XCGLM_INLINE
Xfloat
Xglm_bezier(float s, float p0, float c0, float c1, float p1) {
X  float x, xx, ss, xs3, a;
X
X  x   = 1.0f - s;
X  xx  = x * x;
X  ss  = s * s;
X  xs3 = (s - ss) * 3.0f;
X  a   = p0 * xx + c0 * xs3;
X
X  return a + s * (c1 * xs3 + p1 * ss - a);
X}
X
X/*!
X * @brief cubic hermite interpolation
X *
X * Formula:
X *  H(s) = P0*(2*s^3 - 3*s^2 + 1) + T0*(s^3 - 2*s^2 + s)
X *            + P1*(-2*s^3 + 3*s^2) + T1*(s^3 - s^2)
X *
X * similar result using matrix:
X *  H(s) = glm_smc(t, GLM_HERMITE_MAT, (vec4){p0, p1, c0, c1})
X *
X * glm_eq(glm_smc(...), glm_hermite(...)) should return TRUE
X *
X * @param[in]  s    parameter between 0 and 1
X * @param[in]  p0   begin point
X * @param[in]  t0   tangent 1
X * @param[in]  t1   tangent 2
X * @param[in]  p1   end point
X *
X * @return H(s)
X */
XCGLM_INLINE
Xfloat
Xglm_hermite(float s, float p0, float t0, float t1, float p1) {
X  float ss, d, a, b, c, e, f;
X
X  ss = s  * s;
X  a  = ss + ss;
X  c  = a  + ss;
X  b  = a  * s;
X  d  = s  * ss;
X  f  = d  - ss;
X  e  = b  - c;
X
X  return p0 * (e + 1.0f) + t0 * (f - ss + s) + t1 * f - p1 * e;
X}
X
X/*!
X * @brief iterative way to solve cubic equation
X *
X * @param[in]  prm  parameter between 0 and 1
X * @param[in]  p0   begin point
X * @param[in]  c0   control point 1
X * @param[in]  c1   control point 2
X * @param[in]  p1   end point
X *
X * @return parameter to use in cubic equation
X */
XCGLM_INLINE
Xfloat
Xglm_decasteljau(float prm, float p0, float c0, float c1, float p1) {
X  float u, v, a, b, c, d, e, f;
X  int   i;
X
X  if (prm - p0 < CGLM_DECASTEL_SMALL)
X    return 0.0f;
X
X  if (p1 - prm < CGLM_DECASTEL_SMALL)
X    return 1.0f;
X
X  u  = 0.0f;
X  v  = 1.0f;
X
X  for (i = 0; i < CGLM_DECASTEL_MAX; i++) {
X    /* de Casteljau Subdivision */
X    a  = (p0 + c0) * 0.5f;
X    b  = (c0 + c1) * 0.5f;
X    c  = (c1 + p1) * 0.5f;
X    d  = (a  + b)  * 0.5f;
X    e  = (b  + c)  * 0.5f;
X    f  = (d  + e)  * 0.5f; /* this one is on the curve! */
X
X    /* The curve point is close enough to our wanted t */
X    if (fabsf(f - prm) < CGLM_DECASTEL_EPS)
X      return glm_clamp_zo((u  + v) * 0.5f);
X
X    /* dichotomy */
X    if (f < prm) {
X      p0 = f;
X      c0 = e;
X      c1 = c;
X      u  = (u  + v) * 0.5f;
X    } else {
X      c0 = a;
X      c1 = d;
X      p1 = f;
X      v  = (u  + v) * 0.5f;
X    }
X  }
X
X  return glm_clamp_zo((u  + v) * 0.5f);
X}
X
X#endif /* cglm_bezier_h */
25bfb9b54b305be1de485e1f3d083cd6
echo x - cglm/applesimd.h
sed 's/^X//' >cglm/applesimd.h << 'd98bdb2b357fab453623f93915a548fe'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_applesimd_h
X#define cglm_applesimd_h
X#if defined(__APPLE__)                                                        \
X    && defined(SIMD_COMPILER_HAS_REQUIRED_FEATURES)                           \
X    && defined(SIMD_BASE)                                                     \
X    && defined(SIMD_TYPES)                                                    \
X    && defined(SIMD_VECTOR_TYPES)
X
X#include "common.h"
X
X/*!
X* @brief converts mat4 to Apple's simd type simd_float4x4
X* @return simd_float4x4
X*/
XCGLM_INLINE
Xsimd_float4x4
Xglm_mat4_applesimd(mat4 m) {
X  simd_float4x4 t;
X  
X  t.columns[0][0] = m[0][0];
X  t.columns[0][1] = m[0][1];
X  t.columns[0][2] = m[0][2];
X  t.columns[0][3] = m[0][3];
X
X  t.columns[1][0] = m[1][0];
X  t.columns[1][1] = m[1][1];
X  t.columns[1][2] = m[1][2];
X  t.columns[1][3] = m[1][3];
X
X  t.columns[2][0] = m[2][0];
X  t.columns[2][1] = m[2][1];
X  t.columns[2][2] = m[2][2];
X  t.columns[2][3] = m[2][3];
X
X  t.columns[3][0] = m[3][0];
X  t.columns[3][1] = m[3][1];
X  t.columns[3][2] = m[3][2];
X  t.columns[3][3] = m[3][3];
X
X  return t;
X}
X
X/*!
X* @brief converts mat3 to Apple's simd type simd_float3x3
X* @return simd_float3x3
X*/
XCGLM_INLINE
Xsimd_float3x3
Xglm_mat3_applesimd(mat3 m) {
X  simd_float3x3 t;
X  
X  t.columns[0][0] = m[0][0];
X  t.columns[0][1] = m[0][1];
X  t.columns[0][2] = m[0][2];
X
X  t.columns[1][0] = m[1][0];
X  t.columns[1][1] = m[1][1];
X  t.columns[1][2] = m[1][2];
X
X  t.columns[2][0] = m[2][0];
X  t.columns[2][1] = m[2][1];
X  t.columns[2][2] = m[2][2];
X
X  return t;
X}
X
X/*!
X* @brief converts vec4 to Apple's simd type simd_float4
X* @return simd_float4
X*/
XCGLM_INLINE
Xsimd_float4
Xglm_vec4_applesimd(vec4 v) {
X  return (simd_float4){v[0], v[1], v[2], v[3]};
X}
X
X/*!
X* @brief converts vec3 to Apple's simd type simd_float3
X* @return v
X*/
XCGLM_INLINE
Xsimd_float3
Xglm_vec3_applesimd(vec3 v) {
X  return (simd_float3){v[0], v[1], v[2]};
X}
X
X#endif
X#endif /* cglm_applesimd_h */
d98bdb2b357fab453623f93915a548fe
echo x - cglm/ray.h
sed 's/^X//' >cglm/ray.h << 'b81b55c3ab609e2501627a166b4359b9'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Functions:
X   CGLM_INLINE bool glm_line_triangle_intersect(vec3   origin,
X                                                vec3   direction,
X                                                vec3   v0,
X                                                vec3   v1,
X                                                vec3   v2,
X                                                float *d);
X*/
X
X#ifndef cglm_ray_h
X#define cglm_ray_h
X
X#include "vec3.h"
X
X/*!
X * @brief MllerTrumbore ray-triangle intersection algorithm
X * 
X * @param[in] origin         origin of ray
X * @param[in] direction      direction of ray
X * @param[in] v0             first vertex of triangle
X * @param[in] v1             second vertex of triangle
X * @param[in] v2             third vertex of triangle
X * @param[in, out] d         distance to intersection
X * @return whether there is intersection
X */
X
XCGLM_INLINE
Xbool
Xglm_ray_triangle(vec3   origin,
X                 vec3   direction,
X                 vec3   v0,
X                 vec3   v1,
X                 vec3   v2,
X                 float *d) {
X  vec3        edge1, edge2, p, t, q;
X  float       det, inv_det, u, v, dist;
X  const float epsilon = 0.000001f;
X
X  glm_vec3_sub(v1, v0, edge1);
X  glm_vec3_sub(v2, v0, edge2);
X  glm_vec3_cross(direction, edge2, p);
X
X  det = glm_vec3_dot(edge1, p);
X  if (det > -epsilon && det < epsilon)
X    return false;
X
X  inv_det = 1.0f / det;
X  
X  glm_vec3_sub(origin, v0, t);
X
X  u = inv_det * glm_vec3_dot(t, p);
X  if (u < 0.0f || u > 1.0f)
X    return false;
X
X  glm_vec3_cross(t, edge1, q);
X
X  v = inv_det * glm_vec3_dot(direction, q);
X  if (v < 0.0f || u + v > 1.0f)
X    return false;
X
X  dist = inv_det * glm_vec3_dot(edge2, q);
X
X  if (d)
X    *d = dist;
X
X  return dist > epsilon;
X}
X
X#endif
b81b55c3ab609e2501627a166b4359b9
echo x - cglm/affine2d.h
sed 's/^X//' >cglm/affine2d.h << '93e8c81d0bf09b6ba72a5cab550ec47d'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Functions:
X   CGLM_INLINE void glm_translate2d(mat3 m, vec2 v)
X   CGLM_INLINE void glm_translate2d_to(mat3 m, vec2 v, mat3 dest)
X   CGLM_INLINE void glm_translate2d_x(mat3 m, float x)
X   CGLM_INLINE void glm_translate2d_y(mat3 m, float y)
X   CGLM_INLINE void glm_translate2d_make(mat3 m, vec2 v)
X   CGLM_INLINE void glm_scale2d_to(mat3 m, vec2 v, mat3 dest)
X   CGLM_INLINE void glm_scale2d_make(mat3 m, vec2 v)
X   CGLM_INLINE void glm_scale2d(mat3 m, vec2 v)
X   CGLM_INLINE void glm_scale2d_uni(mat3 m, float s)
X   CGLM_INLINE void glm_rotate2d_make(mat3 m, float angle)
X   CGLM_INLINE void glm_rotate2d(mat3 m, float angle)
X   CGLM_INLINE void glm_rotate2d_to(mat3 m, float angle, mat3 dest)
X */
X
X#ifndef cglm_affine2d_h
X#define cglm_affine2d_h
X
X#include "common.h"
X#include "util.h"
X#include "vec2.h"
X#include "mat3.h"
X
X/*!
X * @brief translate existing 2d transform matrix by v vector
X *        and stores result in same matrix
X *
X * @param[in, out]  m  affine transfrom
X * @param[in]       v  translate vector [x, y]
X */
XCGLM_INLINE
Xvoid
Xglm_translate2d(mat3 m, vec2 v) {
X  m[2][0] = m[0][0] * v[0] + m[1][0] * v[1] + m[2][0];
X  m[2][1] = m[0][1] * v[0] + m[1][1] * v[1] + m[2][1];
X  m[2][2] = m[0][2] * v[0] + m[1][2] * v[1] + m[2][2];
X}
X
X/*!
X * @brief translate existing 2d transform matrix by v vector
X *        and store result in dest
X *
X * source matrix will remain same
X *
X * @param[in]  m    affine transfrom
X * @param[in]  v    translate vector [x, y]
X * @param[out] dest translated matrix
X */
XCGLM_INLINE
Xvoid
Xglm_translate2d_to(mat3 m, vec2 v, mat3 dest) {
X  glm_mat3_copy(m, dest);
X  glm_translate2d(dest, v);
X}
X
X/*!
X * @brief translate existing 2d transform matrix by x factor
X *
X * @param[in, out]  m  affine transfrom
X * @param[in]       x  x factor
X */
XCGLM_INLINE
Xvoid
Xglm_translate2d_x(mat3 m, float x) {
X  m[2][0] = m[0][0] * x + m[2][0];
X  m[2][1] = m[0][1] * x + m[2][1];
X  m[2][2] = m[0][2] * x + m[2][2];
X}
X
X/*!
X * @brief translate existing 2d transform matrix by y factor
X *
X * @param[in, out]  m  affine transfrom
X * @param[in]       y  y factor
X */
XCGLM_INLINE
Xvoid
Xglm_translate2d_y(mat3 m, float y) {
X  m[2][0] = m[1][0] * y + m[2][0];
X  m[2][1] = m[1][1] * y + m[2][1];
X  m[2][2] = m[1][2] * y + m[2][2];
X}
X
X/*!
X * @brief creates NEW translate 2d transform matrix by v vector
X *
X * @param[out]  m  affine transfrom
X * @param[in]   v  translate vector [x, y]
X */
XCGLM_INLINE
Xvoid
Xglm_translate2d_make(mat3 m, vec2 v) {
X  glm_mat3_identity(m);
X  m[2][0] = v[0];
X  m[2][1] = v[1];
X}
X
X/*!
X * @brief scale existing 2d transform matrix by v vector
X *        and store result in dest
X *
X * @param[in]  m    affine transfrom
X * @param[in]  v    scale vector [x, y]
X * @param[out] dest scaled matrix
X */
XCGLM_INLINE
Xvoid
Xglm_scale2d_to(mat3 m, vec2 v, mat3 dest) {
X  dest[0][0] = m[0][0] * v[0];
X  dest[0][1] = m[0][1] * v[0];
X  dest[0][2] = m[0][2] * v[0];
X  
X  dest[1][0] = m[1][0] * v[1];
X  dest[1][1] = m[1][1] * v[1];
X  dest[1][2] = m[1][2] * v[1];
X  
X  dest[2][0] = m[2][0];
X  dest[2][1] = m[2][1];
X  dest[2][2] = m[2][2];
X}
X
X/*!
X * @brief creates NEW 2d scale matrix by v vector
X *
X * @param[out]  m  affine transfrom
X * @param[in]   v  scale vector [x, y]
X */
XCGLM_INLINE
Xvoid
Xglm_scale2d_make(mat3 m, vec2 v) {
X  glm_mat3_identity(m);
X  m[0][0] = v[0];
X  m[1][1] = v[1];
X}
X
X/*!
X * @brief scales existing 2d transform matrix by v vector
X *        and stores result in same matrix
X *
X * @param[in, out]  m  affine transfrom
X * @param[in]       v  scale vector [x, y]
X */
XCGLM_INLINE
Xvoid
Xglm_scale2d(mat3 m, vec2 v) {
X  m[0][0] = m[0][0] * v[0];
X  m[0][1] = m[0][1] * v[0];
X  m[0][2] = m[0][2] * v[0];
X
X  m[1][0] = m[1][0] * v[1];
X  m[1][1] = m[1][1] * v[1];
X  m[1][2] = m[1][2] * v[1];
X}
X
X/*!
X * @brief applies uniform scale to existing 2d transform matrix v = [s, s]
X *        and stores result in same matrix
X *
X * @param[in, out]  m  affine transfrom
X * @param[in]       s  scale factor
X */
XCGLM_INLINE
Xvoid
Xglm_scale2d_uni(mat3 m, float s) {
X  m[0][0] = m[0][0] * s;
X  m[0][1] = m[0][1] * s;
X  m[0][2] = m[0][2] * s;
X
X  m[1][0] = m[1][0] * s;
X  m[1][1] = m[1][1] * s;
X  m[1][2] = m[1][2] * s;
X}
X
X/*!
X * @brief creates NEW rotation matrix by angle around Z axis
X *
X * @param[out] m     affine transfrom
X * @param[in]  angle angle (radians)
X */
XCGLM_INLINE
Xvoid
Xglm_rotate2d_make(mat3 m, float angle) {
X  float c, s;
X
X  s = sinf(angle);
X  c = cosf(angle);
X  
X  m[0][0] = c;
X  m[0][1] = s;
X  m[0][2] = 0;
X
X  m[1][0] = -s;
X  m[1][1] = c;
X  m[1][2] = 0;
X  
X  m[2][0] = 0.0f;
X  m[2][1] = 0.0f;
X  m[2][2] = 1.0f;
X}
X
X/*!
X * @brief rotate existing 2d transform matrix around Z axis by angle
X *         and store result in same matrix
X *
X * @param[in, out]  m      affine transfrom
X * @param[in]       angle  angle (radians)
X */
XCGLM_INLINE
Xvoid
Xglm_rotate2d(mat3 m, float angle) {
X  float m00 = m[0][0],  m10 = m[1][0],
X        m01 = m[0][1],  m11 = m[1][1],
X        m02 = m[0][2],  m12 = m[1][2];
X  float c, s;
X
X  s = sinf(angle);
X  c = cosf(angle);
X  
X  m[0][0] = m00 * c + m10 * s;
X  m[0][1] = m01 * c + m11 * s;
X  m[0][2] = m02 * c + m12 * s;
X
X  m[1][0] = m00 * -s + m10 * c;
X  m[1][1] = m01 * -s + m11 * c;
X  m[1][2] = m02 * -s + m12 * c;
X}
X
X/*!
X * @brief rotate existing 2d transform matrix around Z axis by angle
X *        and store result in dest
X *
X * @param[in]  m      affine transfrom
X * @param[in]  angle  angle (radians)
X * @param[out] dest   destination
X */
XCGLM_INLINE
Xvoid
Xglm_rotate2d_to(mat3 m, float angle, mat3 dest) {
X  float m00 = m[0][0],  m10 = m[1][0],
X        m01 = m[0][1],  m11 = m[1][1],
X        m02 = m[0][2],  m12 = m[1][2];
X  float c, s;
X
X  s = sinf(angle);
X  c = cosf(angle);
X  
X  dest[0][0] = m00 * c + m10 * s;
X  dest[0][1] = m01 * c + m11 * s;
X  dest[0][2] = m02 * c + m12 * s;
X
X  dest[1][0] = m00 * -s + m10 * c;
X  dest[1][1] = m01 * -s + m11 * c;
X  dest[1][2] = m02 * -s + m12 * c;
X  
X  dest[2][0] = m[2][0];
X  dest[2][1] = m[2][1];
X  dest[2][2] = m[2][2];
X}
X
X#endif /* cglm_affine2d_h */
93e8c81d0bf09b6ba72a5cab550ec47d
echo c - cglm/call
mkdir -p cglm/call > /dev/null 2>&1
echo x - cglm/call/mat4.h
sed 's/^X//' >cglm/call/mat4.h << '9891ee2f42ed2712f286cd8ddb32b304'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_mat_h
X#define cglmc_mat_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../cglm.h"
X
X/* DEPRECATED! use _copy, _ucopy versions */
X#define glmc_mat4_udup(mat, dest) glmc_mat4_ucopy(mat, dest)
X#define glmc_mat4_dup(mat, dest)  glmc_mat4_copy(mat, dest)
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4_ucopy(mat4 mat, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4_copy(mat4 mat, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4_identity(mat4 mat);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4_identity_array(mat4 * __restrict mat, size_t count);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4_zero(mat4 mat);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4_pick3(mat4 mat, mat3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4_pick3t(mat4 mat, mat3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4_ins3(mat3 mat, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4_mul(mat4 m1, mat4 m2, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4_mulN(mat4 * __restrict matrices[], uint32_t len, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4_mulv(mat4 m, vec4 v, vec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4_mulv3(mat4 m, vec3 v, float last, vec3 dest);
X
XCGLM_EXPORT
Xfloat
Xglmc_mat4_trace(mat4 m);
X
XCGLM_EXPORT
Xfloat
Xglmc_mat4_trace3(mat4 m);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4_quat(mat4 m, versor dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4_transpose_to(mat4 m, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4_transpose(mat4 m);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4_scale_p(mat4 m, float s);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4_scale(mat4 m, float s);
X
XCGLM_EXPORT
Xfloat
Xglmc_mat4_det(mat4 mat);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4_inv(mat4 mat, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4_inv_precise(mat4 mat, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4_inv_fast(mat4 mat, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4_swap_col(mat4 mat, int col1, int col2);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4_swap_row(mat4 mat, int row1, int row2);
X
XCGLM_EXPORT
Xfloat
Xglmc_mat4_rmc(vec4 r, mat4 m, vec4 c);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4_make(float * __restrict src, mat4 dest);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_mat_h */
9891ee2f42ed2712f286cd8ddb32b304
echo x - cglm/call/mat4x2.h
sed 's/^X//' >cglm/call/mat4x2.h << '497832bd8af8f629e9b32db44686f8d2'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_mat4x2_h
X#define cglmc_mat4x2_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../cglm.h"
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4x2_copy(mat4x2 mat, mat4x2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4x2_zero(mat4x2 mat);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4x2_make(float * __restrict src, mat4x2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4x2_mul(mat4x2 m1, mat2x4 m2, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4x2_mulv(mat4x2 m, vec2 v, vec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4x2_transpose(mat4x2 m, mat2x4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4x2_scale(mat4x2 m, float s);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_mat4x2_h */
497832bd8af8f629e9b32db44686f8d2
echo x - cglm/call/mat4x3.h
sed 's/^X//' >cglm/call/mat4x3.h << '77e3ece1fed67f7da299fd8b6dccdb2b'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_mat4x3_h
X#define cglmc_mat4x3_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../cglm.h"
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4x3_copy(mat4x3 mat, mat4x3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4x3_zero(mat4x3 mat);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4x3_make(float * __restrict src, mat4x3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4x3_mul(mat4x3 m1, mat3x4 m2, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4x3_mulv(mat4x3 m, vec3 v, vec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4x3_transpose(mat4x3 m, mat3x4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4x3_scale(mat4x3 m, float s);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_mat4x3_h */
77e3ece1fed67f7da299fd8b6dccdb2b
echo x - cglm/call/mat3.h
sed 's/^X//' >cglm/call/mat3.h << 'bef8d4ac2c3b0d0be7520619180c9e61'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_mat3_h
X#define cglmc_mat3_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../cglm.h"
X
X/* DEPRECATED! use _copy, _ucopy versions */
X#define glmc_mat3_dup(mat, dest)  glmc_mat3_copy(mat, dest)
X
XCGLM_EXPORT
Xvoid
Xglmc_mat3_copy(mat3 mat, mat3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat3_identity(mat3 mat);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat3_zero(mat3 mat);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat3_identity_array(mat3 * __restrict mat, size_t count);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat3_mul(mat3 m1, mat3 m2, mat3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat3_transpose_to(mat3 m, mat3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat3_transpose(mat3 m);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat3_mulv(mat3 m, vec3 v, vec3 dest);
X
XCGLM_EXPORT
Xfloat
Xglmc_mat3_trace(mat3 m);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat3_quat(mat3 m, versor dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat3_scale(mat3 m, float s);
X
XCGLM_EXPORT
Xfloat
Xglmc_mat3_det(mat3 mat);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat3_inv(mat3 mat, mat3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat3_swap_col(mat3 mat, int col1, int col2);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat3_swap_row(mat3 mat, int row1, int row2);
X
XCGLM_EXPORT
Xfloat
Xglmc_mat3_rmc(vec3 r, mat3 m, vec3 c);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat3_make(float * __restrict src, mat3 dest);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_mat3_h */
bef8d4ac2c3b0d0be7520619180c9e61
echo x - cglm/call/mat3x2.h
sed 's/^X//' >cglm/call/mat3x2.h << 'e27825dc7edd0f8a469ef90840557d79'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_mat3x2_h
X#define cglmc_mat3x2_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../cglm.h"
X
XCGLM_EXPORT
Xvoid
Xglmc_mat3x2_copy(mat3x2 mat, mat3x2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat3x2_zero(mat3x2 mat);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat3x2_make(float * __restrict src, mat3x2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat3x2_mul(mat3x2 m1, mat2x3 m2, mat3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat3x2_mulv(mat3x2 m, vec2 v, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat3x2_transpose(mat3x2 m, mat2x3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat3x2_scale(mat3x2 m, float s);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_mat3x2_h */
e27825dc7edd0f8a469ef90840557d79
echo x - cglm/call/mat3x4.h
sed 's/^X//' >cglm/call/mat3x4.h << '680c2fe4a2be27e7b14227d737821d6d'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_mat3x4_h
X#define cglmc_mat3x4_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../cglm.h"
X
XCGLM_EXPORT
Xvoid
Xglmc_mat3x4_copy(mat3x4 mat, mat3x4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat3x4_zero(mat3x4 mat);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat3x4_make(float * __restrict src, mat3x4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat3x4_mul(mat3x4 m1, mat4x3 m2, mat3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat3x4_mulv(mat3x4 m, vec4 v, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat3x4_transpose(mat3x4 m, mat4x3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat3x4_scale(mat3x4 m, float s);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_mat3x4_h */
680c2fe4a2be27e7b14227d737821d6d
echo x - cglm/call/mat2.h
sed 's/^X//' >cglm/call/mat2.h << 'a383f2a736991f33f39ca56a7c20a816'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_mat2_h
X#define cglmc_mat2_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../cglm.h"
X
XCGLM_EXPORT
Xvoid
Xglmc_mat2_copy(mat2 mat, mat2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat2_identity(mat2 mat);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat2_identity_array(mat2 * __restrict mat, size_t count);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat2_zero(mat2 mat);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat2_mul(mat2 m1, mat2 m2, mat2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat2_transpose_to(mat2 m, mat2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat2_transpose(mat2 m);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat2_mulv(mat2 m, vec2 v, vec2 dest);
X
XCGLM_EXPORT
Xfloat
Xglmc_mat2_trace(mat2 m);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat2_scale(mat2 m, float s);
X
XCGLM_EXPORT
Xfloat
Xglmc_mat2_det(mat2 mat);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat2_inv(mat2 mat, mat2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat2_swap_col(mat2 mat, int col1, int col2);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat2_swap_row(mat2 mat, int row1, int row2);
X
XCGLM_EXPORT
Xfloat
Xglmc_mat2_rmc(vec2 r, mat2 m, vec2 c);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat2_make(float * __restrict src, mat2 dest);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_mat2_h */
a383f2a736991f33f39ca56a7c20a816
echo x - cglm/call/mat2x3.h
sed 's/^X//' >cglm/call/mat2x3.h << 'fecb27fce3187936068243c0ff525476'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_mat2x3_h
X#define cglmc_mat2x3_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../cglm.h"
X
XCGLM_EXPORT
Xvoid
Xglmc_mat2x3_copy(mat2x3 mat, mat2x3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat2x3_zero(mat2x3 mat);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat2x3_make(float * __restrict src, mat2x3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat2x3_mul(mat2x3 m1, mat3x2 m2, mat2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat2x3_mulv(mat2x3 m, vec3 v, vec2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat2x3_transpose(mat2x3 m, mat3x2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat2x3_scale(mat2x3 m, float s);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_mat2x3_h */
fecb27fce3187936068243c0ff525476
echo x - cglm/call/mat2x4.h
sed 's/^X//' >cglm/call/mat2x4.h << '05c3d810d1258ac4e7f4ad24b715abfe'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_mat2x4_h
X#define cglmc_mat2x4_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../cglm.h"
X
XCGLM_EXPORT
Xvoid
Xglmc_mat2x4_copy(mat2x4 mat, mat2x4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat2x4_zero(mat2x4 mat);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat2x4_make(float * __restrict src, mat2x4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat2x4_mul(mat2x4 m1, mat4x2 m2, mat2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat2x4_mulv(mat2x4 m, vec4 v, vec2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat2x4_transpose(mat2x4 m, mat4x2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat2x4_scale(mat2x4 m, float s);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_mat2x4_h */
05c3d810d1258ac4e7f4ad24b715abfe
echo x - cglm/call/vec2.h
sed 's/^X//' >cglm/call/vec2.h << 'd54e3dacd1c830b3575034f71ba3b283'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_vec2_h
X#define cglmc_vec2_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../cglm.h"
X
XCGLM_EXPORT
Xvoid
Xglmc_vec2(float * __restrict v, vec2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec2_copy(vec2 a, vec2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec2_zero(vec2 v);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec2_one(vec2 v);
X
XCGLM_EXPORT
Xfloat
Xglmc_vec2_dot(vec2 a, vec2 b);
X
XCGLM_EXPORT
Xfloat
Xglmc_vec2_cross(vec2 a, vec2 b);
X
XCGLM_EXPORT
Xfloat
Xglmc_vec2_norm2(vec2 v);
X
XCGLM_EXPORT
Xfloat
Xglmc_vec2_norm(vec2 v);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec2_add(vec2 a, vec2 b, vec2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec2_adds(vec2 v, float s, vec2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec2_sub(vec2 a, vec2 b, vec2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec2_subs(vec2 v, float s, vec2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec2_mul(vec2 a, vec2 b, vec2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec2_scale(vec2 v, float s, vec2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec2_scale_as(vec2 v, float s, vec2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec2_div(vec2 a, vec2 b, vec2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec2_divs(vec2 v, float s, vec2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec2_addadd(vec2 a, vec2 b, vec2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec2_subadd(vec2 a, vec2 b, vec2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec2_muladd(vec2 a, vec2 b, vec2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec2_muladds(vec2 a, float s, vec2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec2_maxadd(vec2 a, vec2 b, vec2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec2_minadd(vec2 a, vec2 b, vec2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec2_subsub(vec2 a, vec2 b, vec2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec2_addsub(vec2 a, vec2 b, vec2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec2_mulsub(vec2 a, vec2 b, vec2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec2_mulsubs(vec2 a, float s, vec2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec2_maxsub(vec2 a, vec2 b, vec2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec2_minsub(vec2 a, vec2 b, vec2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec2_negate_to(vec2 v, vec2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec2_negate(vec2 v);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec2_normalize(vec2 v);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec2_normalize_to(vec2 v, vec2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec2_rotate(vec2 v, float angle, vec2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec2_center(vec2 a, vec2 b, vec2 dest);
X
XCGLM_EXPORT
Xfloat
Xglmc_vec2_distance2(vec2 a, vec2 b);
X
XCGLM_EXPORT
Xfloat
Xglmc_vec2_distance(vec2 a, vec2 b);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec2_maxv(vec2 a, vec2 b, vec2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec2_minv(vec2 a, vec2 b, vec2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec2_clamp(vec2 v, float minval, float maxval);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec2_abs(vec2 v, vec2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec2_lerp(vec2 from, vec2 to, float t, vec2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec2_complex_mul(vec2 a, vec2 b, vec2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec2_complex_div(vec2 a, vec2 b, vec2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec2_complex_conjugate(vec2 a, vec2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec2_make(float * __restrict src, vec2 dest);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_vec2_h */
d54e3dacd1c830b3575034f71ba3b283
echo x - cglm/call/vec3.h
sed 's/^X//' >cglm/call/vec3.h << '01a5053946175fd441c0055c8f08c8e7'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_vec3_h
X#define cglmc_vec3_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../cglm.h"
X
X/* DEPRECATED! use _copy, _ucopy versions */
X#define glmc_vec_dup(v, dest)          glmc_vec3_copy(v, dest)
X#define glmc_vec3_flipsign(v)          glmc_vec3_negate(v)
X#define glmc_vec3_flipsign_to(v, dest) glmc_vec3_negate_to(v, dest)
X#define glmc_vec3_inv(v)               glmc_vec3_negate(v)
X#define glmc_vec3_inv_to(v, dest)      glmc_vec3_negate_to(v, dest)
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3(vec4 v4, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_copy(vec3 a, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_zero(vec3 v);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_one(vec3 v);
X
XCGLM_EXPORT
Xfloat
Xglmc_vec3_dot(vec3 a, vec3 b);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_cross(vec3 a, vec3 b, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_crossn(vec3 a, vec3 b, vec3 dest);
X
XCGLM_EXPORT
Xfloat
Xglmc_vec3_norm(vec3 v);
X
XCGLM_EXPORT
Xfloat
Xglmc_vec3_norm2(vec3 v);
X    
XCGLM_EXPORT
Xfloat
Xglmc_vec3_norm_one(vec3 v);
X
XCGLM_EXPORT
Xfloat
Xglmc_vec3_norm_inf(vec3 v);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_normalize_to(vec3 v, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_normalize(vec3 v);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_add(vec3 a, vec3 b, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_adds(vec3 v, float s, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_sub(vec3 a, vec3 b, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_subs(vec3 v, float s, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_mul(vec3 a, vec3 b, vec3 d);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_scale(vec3 v, float s, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_scale_as(vec3 v, float s, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_div(vec3 a, vec3 b, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_divs(vec3 a, float s, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_addadd(vec3 a, vec3 b, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_subadd(vec3 a, vec3 b, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_muladd(vec3 a, vec3 b, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_muladds(vec3 a, float s, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_maxadd(vec3 a, vec3 b, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_minadd(vec3 a, vec3 b, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_subsub(vec3 a, vec3 b, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_addsub(vec3 a, vec3 b, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_mulsub(vec3 a, vec3 b, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_mulsubs(vec3 a, float s, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_maxsub(vec3 a, vec3 b, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_minsub(vec3 a, vec3 b, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_negate(vec3 v);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_negate_to(vec3 v, vec3 dest);
X
XCGLM_EXPORT
Xfloat
Xglmc_vec3_angle(vec3 a, vec3 b);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_rotate(vec3 v, float angle, vec3 axis);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_rotate_m4(mat4 m, vec3 v, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_rotate_m3(mat3 m, vec3 v, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_proj(vec3 a, vec3 b, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_center(vec3 a, vec3 b, vec3 dest);
X
XCGLM_EXPORT
Xfloat
Xglmc_vec3_distance2(vec3 a, vec3 b);
X
XCGLM_EXPORT
Xfloat
Xglmc_vec3_distance(vec3 a, vec3 b);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_maxv(vec3 a, vec3 b, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_minv(vec3 a, vec3 b, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_clamp(vec3 v, float minVal, float maxVal);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_ortho(vec3 v, vec3 dest);
X    
XCGLM_EXPORT
Xvoid
Xglmc_vec3_lerp(vec3 from, vec3 to, float t, vec3 dest);
X    
XCGLM_EXPORT
Xvoid
Xglmc_vec3_lerpc(vec3 from, vec3 to, float t, vec3 dest);
X    
XCGLM_INLINE
Xvoid
Xglmc_vec3_mix(vec3 from, vec3 to, float t, vec3 dest) {
X  glmc_vec3_lerp(from, to, t, dest);
X}
X
XCGLM_INLINE
Xvoid
Xglmc_vec3_mixc(vec3 from, vec3 to, float t, vec3 dest) {
X  glmc_vec3_lerpc(from, to, t, dest);
X}
X    
XCGLM_EXPORT
Xvoid
Xglmc_vec3_step_uni(float edge, vec3 x, vec3 dest);
X    
XCGLM_EXPORT
Xvoid
Xglmc_vec3_step(vec3 edge, vec3 x, vec3 dest);
X    
XCGLM_EXPORT
Xvoid
Xglmc_vec3_smoothstep_uni(float edge0, float edge1, vec3 x, vec3 dest);
X    
XCGLM_EXPORT
Xvoid
Xglmc_vec3_smoothstep(vec3 edge0, vec3 edge1, vec3 x, vec3 dest);
X    
XCGLM_EXPORT
Xvoid
Xglmc_vec3_smoothinterp(vec3 from, vec3 to, float t, vec3 dest);
X    
XCGLM_EXPORT
Xvoid
Xglmc_vec3_smoothinterpc(vec3 from, vec3 to, float t, vec3 dest);
X
X/* ext */
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_mulv(vec3 a, vec3 b, vec3 d);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_broadcast(float val, vec3 d);
X    
XCGLM_EXPORT
Xvoid
Xglmc_vec3_fill(vec3 v, float val);
X
XCGLM_EXPORT
Xbool
Xglmc_vec3_eq(vec3 v, float val);
X
XCGLM_EXPORT
Xbool
Xglmc_vec3_eq_eps(vec3 v, float val);
X
XCGLM_EXPORT
Xbool
Xglmc_vec3_eq_all(vec3 v);
X
XCGLM_EXPORT
Xbool
Xglmc_vec3_eqv(vec3 a, vec3 b);
X
XCGLM_EXPORT
Xbool
Xglmc_vec3_eqv_eps(vec3 a, vec3 b);
X
XCGLM_EXPORT
Xfloat
Xglmc_vec3_max(vec3 v);
X
XCGLM_EXPORT
Xfloat
Xglmc_vec3_min(vec3 v);
X
XCGLM_EXPORT
Xbool
Xglmc_vec3_isnan(vec3 v);
X
XCGLM_EXPORT
Xbool
Xglmc_vec3_isinf(vec3 v);
X
XCGLM_EXPORT
Xbool
Xglmc_vec3_isvalid(vec3 v);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_sign(vec3 v, vec3 dest);
X    
XCGLM_EXPORT
Xvoid
Xglmc_vec3_abs(vec3 v, vec3 dest);
X    
XCGLM_EXPORT
Xvoid
Xglmc_vec3_fract(vec3 v, vec3 dest);
X    
XCGLM_EXPORT
Xfloat
Xglmc_vec3_hadd(vec3 v);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_sqrt(vec3 v, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_make(float * __restrict src, vec3 dest);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_vec3_h */
01a5053946175fd441c0055c8f08c8e7
echo x - cglm/call/vec4.h
sed 's/^X//' >cglm/call/vec4.h << 'cfaf9fd6154726ea70347e93b486f962'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_vec4_h
X#define cglmc_vec4_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../cglm.h"
X
X/* DEPRECATED! use _copy, _ucopy versions */
X#define glmc_vec4_dup3(v, dest)         glmc_vec4_copy3(v, dest)
X#define glmc_vec4_dup(v, dest)          glmc_vec4_copy(v, dest)
X#define glmc_vec4_flipsign(v)           glmc_vec4_negate(v)
X#define glmc_vec4_flipsign_to(v, dest)  glmc_vec4_negate_to(v, dest)
X#define glmc_vec4_inv(v)                glmc_vec4_negate(v)
X#define glmc_vec4_inv_to(v, dest)       glmc_vec4_negate_to(v, dest)
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4(vec3 v3, float last, vec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_zero(vec4 v);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_one(vec4 v);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_copy3(vec4 v, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_copy(vec4 v, vec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_ucopy(vec4 v, vec4 dest);
X
XCGLM_EXPORT
Xfloat
Xglmc_vec4_dot(vec4 a, vec4 b);
X
XCGLM_EXPORT
Xfloat
Xglmc_vec4_norm(vec4 v);
X
XCGLM_EXPORT
Xfloat
Xglmc_vec4_norm2(vec4 v);
X    
XCGLM_EXPORT
Xfloat
Xglmc_vec4_norm_one(vec4 v);
X
XCGLM_EXPORT
Xfloat
Xglmc_vec4_norm_inf(vec4 v);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_normalize_to(vec4 v, vec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_normalize(vec4 v);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_add(vec4 a, vec4 b, vec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_adds(vec4 v, float s, vec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_sub(vec4 a, vec4 b, vec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_subs(vec4 v, float s, vec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_mul(vec4 a, vec4 b, vec4 d);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_scale(vec4 v, float s, vec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_scale_as(vec4 v, float s, vec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_div(vec4 a, vec4 b, vec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_divs(vec4 v, float s, vec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_addadd(vec4 a, vec4 b, vec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_subadd(vec4 a, vec4 b, vec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_muladd(vec4 a, vec4 b, vec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_muladds(vec4 a, float s, vec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_maxadd(vec4 a, vec4 b, vec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_minadd(vec4 a, vec4 b, vec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_subsub(vec4 a, vec4 b, vec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_addsub(vec4 a, vec4 b, vec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_mulsub(vec4 a, vec4 b, vec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_mulsubs(vec4 a, float s, vec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_maxsub(vec4 a, vec4 b, vec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_minsub(vec4 a, vec4 b, vec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_negate(vec4 v);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_negate_to(vec4 v, vec4 dest);
X    
XCGLM_EXPORT
Xfloat
Xglmc_vec4_distance(vec4 a, vec4 b);
X    
XCGLM_EXPORT
Xfloat
Xglmc_vec4_distance2(vec4 a, vec4 b);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_maxv(vec4 a, vec4 b, vec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_minv(vec4 a, vec4 b, vec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_clamp(vec4 v, float minVal, float maxVal);
X    
XCGLM_EXPORT
Xvoid
Xglmc_vec4_lerp(vec4 from, vec4 to, float t, vec4 dest);
X    
XCGLM_EXPORT
Xvoid
Xglmc_vec4_lerpc(vec4 from, vec4 to, float t, vec4 dest);
X    
XCGLM_INLINE
Xvoid
Xglmc_vec4_mix(vec4 from, vec4 to, float t, vec4 dest) {
X  glmc_vec4_lerp(from, to, t, dest);
X}
X
XCGLM_INLINE
Xvoid
Xglmc_vec4_mixc(vec4 from, vec4 to, float t, vec4 dest) {
X  glmc_vec4_lerpc(from, to, t, dest);
X}
X    
XCGLM_EXPORT
Xvoid
Xglmc_vec4_step_uni(float edge, vec4 x, vec4 dest);
X    
XCGLM_EXPORT
Xvoid
Xglmc_vec4_step(vec4 edge, vec4 x, vec4 dest);
X    
XCGLM_EXPORT
Xvoid
Xglmc_vec4_smoothstep_uni(float edge0, float edge1, vec4 x, vec4 dest);
X    
XCGLM_EXPORT
Xvoid
Xglmc_vec4_smoothstep(vec4 edge0, vec4 edge1, vec4 x, vec4 dest);
X    
XCGLM_EXPORT
Xvoid
Xglmc_vec4_smoothinterp(vec4 from, vec4 to, float t, vec4 dest);
X    
XCGLM_EXPORT
Xvoid
Xglmc_vec4_smoothinterpc(vec4 from, vec4 to, float t, vec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_cubic(float s, vec4 dest);
X
X/* ext */
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_mulv(vec4 a, vec4 b, vec4 d);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_broadcast(float val, vec4 d);
X    
XCGLM_EXPORT
Xvoid
Xglmc_vec4_fill(vec4 v, float val);
X
XCGLM_EXPORT
Xbool
Xglmc_vec4_eq(vec4 v, float val);
X
XCGLM_EXPORT
Xbool
Xglmc_vec4_eq_eps(vec4 v, float val);
X
XCGLM_EXPORT
Xbool
Xglmc_vec4_eq_all(vec4 v);
X
XCGLM_EXPORT
Xbool
Xglmc_vec4_eqv(vec4 a, vec4 b);
X
XCGLM_EXPORT
Xbool
Xglmc_vec4_eqv_eps(vec4 a, vec4 b);
X
XCGLM_EXPORT
Xfloat
Xglmc_vec4_max(vec4 v);
X
XCGLM_EXPORT
Xfloat
Xglmc_vec4_min(vec4 v);
X
XCGLM_EXPORT
Xbool
Xglmc_vec4_isnan(vec4 v);
X
XCGLM_EXPORT
Xbool
Xglmc_vec4_isinf(vec4 v);
X
XCGLM_EXPORT
Xbool
Xglmc_vec4_isvalid(vec4 v);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_sign(vec4 v, vec4 dest);
X    
XCGLM_EXPORT
Xvoid
Xglmc_vec4_abs(vec4 v, vec4 dest);
X    
XCGLM_EXPORT
Xvoid
Xglmc_vec4_fract(vec4 v, vec4 dest);
X    
XCGLM_EXPORT
Xfloat
Xglmc_vec4_hadd(vec4 v);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_sqrt(vec4 v, vec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_make(float * __restrict src, vec4 dest);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_vec4_h */
X
cfaf9fd6154726ea70347e93b486f962
echo x - cglm/call/ivec2.h
sed 's/^X//' >cglm/call/ivec2.h << 'd4d31a80a66c490d33f5f0e8a51bdb77'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_ivec2_h
X#define cglmc_ivec2_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../cglm.h"
X
XCGLM_EXPORT
Xvoid
Xglmc_ivec2(int * __restrict v, ivec2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ivec2_copy(ivec2 a, ivec2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ivec2_zero(ivec2 v);
X
XCGLM_EXPORT
Xvoid
Xglmc_ivec2_one(ivec2 v);
X
XCGLM_EXPORT
Xvoid
Xglmc_ivec2_add(ivec2 a, ivec2 b, ivec2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ivec2_adds(ivec2 v, int s, ivec2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ivec2_sub(ivec2 a, ivec2 b, ivec2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ivec2_subs(ivec2 v, int s, ivec2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ivec2_mul(ivec2 a, ivec2 b, ivec2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ivec2_scale(ivec2 v, int s, ivec2 dest);
X
XCGLM_EXPORT
Xint
Xglmc_ivec2_distance2(ivec2 a, ivec2 b);
X
XCGLM_EXPORT
Xfloat
Xglmc_ivec2_distance(ivec2 a, ivec2 b);
X
XCGLM_EXPORT
Xvoid
Xglmc_ivec2_fill(ivec2 v, int val);
X
XCGLM_EXPORT
Xbool
Xglmc_ivec2_eq(ivec2 v, int val);
X
XCGLM_EXPORT
Xbool
Xglmc_ivec2_eqv(ivec2 a, ivec2 b);
X
XCGLM_EXPORT
Xvoid
Xglmc_ivec2_maxv(ivec2 a, ivec2 b, ivec2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ivec2_minv(ivec2 a, ivec2 b, ivec2 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ivec2_clamp(ivec2 v, int minVal, int maxVal);
X
XCGLM_EXPORT
Xvoid
Xglmc_ivec2_abs(ivec2 v, ivec2 dest);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_ivec2_h */
d4d31a80a66c490d33f5f0e8a51bdb77
echo x - cglm/call/ivec3.h
sed 's/^X//' >cglm/call/ivec3.h << 'b4771744e96ee5fbcbb12867b24fbbe4'
X/*
X * Copyright (c);, Recep Aslantas.
X *
X * MIT License (MIT);, http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_ivec3_h
X#define cglmc_ivec3_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../cglm.h"
X
XCGLM_EXPORT
Xvoid
Xglmc_ivec3(ivec4 v4, ivec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ivec3_copy(ivec3 a, ivec3 dest);
X
XCGLM_EXPORT
Xvoid 
Xglmc_ivec3_zero(ivec3 v);
X
XCGLM_EXPORT
Xvoid
Xglmc_ivec3_one(ivec3 v);
X
XCGLM_EXPORT
Xvoid
Xglmc_ivec3_add(ivec3 a, ivec3 b, ivec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ivec3_adds(ivec3 v, int s, ivec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ivec3_sub(ivec3 a, ivec3 b, ivec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ivec3_subs(ivec3 v, int s, ivec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ivec3_mul(ivec3 a, ivec3 b, ivec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ivec3_scale(ivec3 v, int s, ivec3 dest);
X
XCGLM_EXPORT
Xint
Xglmc_ivec3_distance2(ivec3 a, ivec3 b);
X
XCGLM_EXPORT
Xfloat
Xglmc_ivec3_distance(ivec3 a, ivec3 b);
X
XCGLM_EXPORT
Xvoid
Xglmc_ivec3_fill(ivec3 v, int val);
X
XCGLM_EXPORT
Xbool
Xglmc_ivec3_eq(ivec3 v, int val);
X
XCGLM_EXPORT
Xbool
Xglmc_ivec3_eqv(ivec3 a, ivec3 b);
X
XCGLM_EXPORT
Xvoid
Xglmc_ivec3_maxv(ivec3 a, ivec3 b, ivec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ivec3_minv(ivec3 a, ivec3 b, ivec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ivec3_clamp(ivec3 v, int minVal, int maxVal);
X
XCGLM_EXPORT
Xvoid
Xglmc_ivec3_abs(ivec3 v, ivec3 dest);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_ivec3_h */
b4771744e96ee5fbcbb12867b24fbbe4
echo x - cglm/call/ivec4.h
sed 's/^X//' >cglm/call/ivec4.h << 'c87bc81b49429d6c2b0458cfaa93dba4'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_ivec4_h
X#define cglmc_ivec4_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../cglm.h"
X
XCGLM_EXPORT
Xvoid
Xglmc_ivec4(ivec3 v3, int last, ivec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ivec4_copy(ivec4 a, ivec4 dest);
X
XCGLM_EXPORT
Xvoid 
Xglmc_ivec4_zero(ivec4 v);
X
XCGLM_EXPORT
Xvoid
Xglmc_ivec4_one(ivec4 v);
X
XCGLM_EXPORT
Xvoid
Xglmc_ivec4_add(ivec4 a, ivec4 b, ivec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ivec4_adds(ivec4 v, int s, ivec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ivec4_sub(ivec4 a, ivec4 b, ivec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ivec4_subs(ivec4 v, int s, ivec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ivec4_mul(ivec4 a, ivec4 b, ivec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ivec4_scale(ivec4 v, int s, ivec4 dest);
X
XCGLM_EXPORT
Xint
Xglmc_ivec4_distance2(ivec4 a, ivec4 b);
X
XCGLM_EXPORT
Xfloat
Xglmc_ivec4_distance(ivec4 a, ivec4 b);
X
XCGLM_EXPORT
Xvoid
Xglmc_ivec4_maxv(ivec4 a, ivec4 b, ivec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ivec4_minv(ivec4 a, ivec4 b, ivec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ivec4_clamp(ivec4 v, int minVal, int maxVal);
X
XCGLM_EXPORT
Xvoid
Xglmc_ivec4_abs(ivec4 v, ivec4 dest);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_ivec4_h */
c87bc81b49429d6c2b0458cfaa93dba4
echo x - cglm/call/io.h
sed 's/^X//' >cglm/call/io.h << 'd221e3bcee931504c48e3be6ef46a8cc'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_io_h
X#define cglmc_io_h
X
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../cglm.h"
X
XCGLM_EXPORT
Xvoid
Xglmc_mat4_print(mat4   matrix,
X                FILE * __restrict ostream);
X
XCGLM_EXPORT
Xvoid
Xglmc_mat3_print(mat3 matrix,
X                FILE * __restrict ostream);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec4_print(vec4 vec,
X                FILE * __restrict ostream);
X
XCGLM_EXPORT
Xvoid
Xglmc_vec3_print(vec3 vec,
X                FILE * __restrict ostream);
X
XCGLM_EXPORT
Xvoid
Xglmc_versor_print(versor vec,
X                  FILE * __restrict ostream);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_io_h */
d221e3bcee931504c48e3be6ef46a8cc
echo x - cglm/call/cam.h
sed 's/^X//' >cglm/call/cam.h << '336f38d27c90d38bbdfe7e3afdea7c3e'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_cam_h
X#define cglmc_cam_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../cglm.h"
X
XCGLM_EXPORT
Xvoid
Xglmc_frustum(float left,   float right,
X             float bottom, float top,
X             float nearZ,  float farZ,
X             mat4  dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ortho(float left,   float right,
X           float bottom, float top,
X           float nearZ,  float farZ,
X           mat4  dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ortho_aabb(vec3 box[2], mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ortho_aabb_p(vec3 box[2], float padding, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ortho_aabb_pz(vec3 box[2], float padding, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ortho_default(float aspect, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ortho_default_s(float aspect, float size, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_perspective(float fovy, float aspect, float nearZ, float farZ, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_persp_move_far(mat4 proj, float deltaFar);
X
XCGLM_EXPORT
Xvoid
Xglmc_perspective_default(float aspect, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_perspective_resize(float aspect, mat4 proj);
X
XCGLM_EXPORT
Xvoid
Xglmc_lookat(vec3 eye, vec3 center, vec3 up, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_look(vec3 eye, vec3 dir, vec3 up, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_look_anyup(vec3 eye, vec3 dir, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_persp_decomp(mat4 proj,
X                  float * __restrict nearZ,
X                  float * __restrict farZ,
X                  float * __restrict top,
X                  float * __restrict bottom,
X                  float * __restrict left,
X                  float * __restrict right);
X
XCGLM_EXPORT
Xvoid
Xglmc_persp_decompv(mat4 proj, float dest[6]);
X
XCGLM_EXPORT
Xvoid
Xglmc_persp_decomp_x(mat4 proj,
X                    float * __restrict left,
X                    float * __restrict right);
X
XCGLM_EXPORT
Xvoid
Xglmc_persp_decomp_y(mat4 proj,
X                    float * __restrict top,
X                    float * __restrict bottom);
X
XCGLM_EXPORT
Xvoid
Xglmc_persp_decomp_z(mat4 proj,
X                    float * __restrict nearZ,
X                    float * __restrict farZ);
X
XCGLM_EXPORT
Xvoid
Xglmc_persp_decomp_far(mat4 proj, float * __restrict farZ);
X
XCGLM_EXPORT
Xvoid
Xglmc_persp_decomp_near(mat4 proj, float * __restrict nearZ);
X
XCGLM_EXPORT
Xfloat
Xglmc_persp_fovy(mat4 proj);
X
XCGLM_EXPORT
Xfloat
Xglmc_persp_aspect(mat4 proj);
X
XCGLM_EXPORT
Xvoid
Xglmc_persp_sizes(mat4 proj, float fovy, vec4 dest);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_cam_h */
336f38d27c90d38bbdfe7e3afdea7c3e
echo x - cglm/call/quat.h
sed 's/^X//' >cglm/call/quat.h << '480d19b5aa34c1fe3734d6263bbd4989'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_quat_h
X#define cglmc_quat_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../cglm.h"
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_identity(versor q);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_identity_array(versor * __restrict q, size_t count);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_init(versor q, float x, float y, float z, float w);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat(versor q, float angle, float x, float y, float z);
X
XCGLM_EXPORT
Xvoid
Xglmc_quatv(versor q, float angle, vec3 axis);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_copy(versor q, versor dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_from_vecs(vec3 a, vec3 b, versor dest);
X
XCGLM_EXPORT
Xfloat
Xglmc_quat_norm(versor q);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_normalize_to(versor q, versor dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_normalize(versor q);
X
XCGLM_EXPORT
Xfloat
Xglmc_quat_dot(versor p, versor q);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_conjugate(versor q, versor dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_inv(versor q, versor dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_add(versor p, versor q, versor dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_sub(versor p, versor q, versor dest);
X
XCGLM_EXPORT
Xfloat
Xglmc_quat_real(versor q);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_imag(versor q, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_imagn(versor q, vec3 dest);
X
XCGLM_EXPORT
Xfloat
Xglmc_quat_imaglen(versor q);
X
XCGLM_EXPORT
Xfloat
Xglmc_quat_angle(versor q);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_axis(versor q, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_mul(versor p, versor q, versor dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_mat4(versor q, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_mat4t(versor q, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_mat3(versor q, mat3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_mat3t(versor q, mat3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_lerp(versor from, versor to, float t, versor dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_lerpc(versor from, versor to, float t, versor dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_nlerp(versor q, versor r, float t, versor dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_slerp(versor q, versor r, float t, versor dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_look(vec3 eye, versor ori, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_for(vec3 dir, vec3 up, versor dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_forp(vec3 from, vec3 to, vec3 up, versor dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_rotatev(versor from, vec3 to, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_rotate(mat4 m, versor q, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_rotate_at(mat4 model, versor q, vec3 pivot);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_rotate_atm(mat4 m, versor q, vec3 pivot);
X
XCGLM_EXPORT
Xvoid
Xglmc_quat_make(float * __restrict src, versor dest);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_quat_h */
480d19b5aa34c1fe3734d6263bbd4989
echo x - cglm/call/euler.h
sed 's/^X//' >cglm/call/euler.h << '2376cb5100d07b3b2e025fc374b970e8'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_euler_h
X#define cglmc_euler_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../cglm.h"
X
XCGLM_EXPORT
Xvoid
Xglmc_euler_angles(mat4 m, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_euler(vec3 angles, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_euler_xyz(vec3 angles,  mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_euler_zyx(vec3 angles,  mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_euler_zxy(vec3 angles, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_euler_xzy(vec3 angles, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_euler_yzx(vec3 angles, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_euler_yxz(vec3 angles, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_euler_by_order(vec3 angles, glm_euler_seq axis, mat4 dest);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_euler_h */
2376cb5100d07b3b2e025fc374b970e8
echo x - cglm/call/plane.h
sed 's/^X//' >cglm/call/plane.h << '2e82d286dfb332b800a4c02ae997e089'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_plane_h
X#define cglmc_plane_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../cglm.h"
X
XCGLM_EXPORT
Xvoid
Xglmc_plane_normalize(vec4 plane);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_plane_h */
2e82d286dfb332b800a4c02ae997e089
echo x - cglm/call/frustum.h
sed 's/^X//' >cglm/call/frustum.h << '6b24446124a17a42c33a56ab4b086519'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_frustum_h
X#define cglmc_frustum_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../cglm.h"
X
XCGLM_EXPORT
Xvoid
Xglmc_frustum_planes(mat4 m, vec4 dest[6]);
X
XCGLM_EXPORT
Xvoid
Xglmc_frustum_corners(mat4 invMat, vec4 dest[8]);
X
XCGLM_EXPORT
Xvoid
Xglmc_frustum_center(vec4 corners[8], vec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_frustum_box(vec4 corners[8], mat4 m, vec3 box[2]);
X
XCGLM_EXPORT
Xvoid
Xglmc_frustum_corners_at(vec4  corners[8],
X                        float splitDist,
X                        float farDist,
X                        vec4  planeCorners[4]);
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_frustum_h */
6b24446124a17a42c33a56ab4b086519
echo x - cglm/call/box.h
sed 's/^X//' >cglm/call/box.h << '6c5946d926d405365843ff644268538d'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_box_h
X#define cglmc_box_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../cglm.h"
X
XCGLM_EXPORT
Xvoid
Xglmc_aabb_transform(vec3 box[2], mat4 m, vec3 dest[2]);
X
XCGLM_EXPORT
Xvoid
Xglmc_aabb_merge(vec3 box1[2], vec3 box2[2], vec3 dest[2]);
X
XCGLM_EXPORT
Xvoid
Xglmc_aabb_crop(vec3 box[2], vec3 cropBox[2], vec3 dest[2]);
X
XCGLM_EXPORT
Xvoid
Xglmc_aabb_crop_until(vec3 box[2],
X                     vec3 cropBox[2],
X                     vec3 clampBox[2],
X                     vec3 dest[2]);
X
XCGLM_EXPORT
Xbool
Xglmc_aabb_frustum(vec3 box[2], vec4 planes[6]);
X
XCGLM_EXPORT
Xvoid
Xglmc_aabb_invalidate(vec3 box[2]);
X
XCGLM_EXPORT
Xbool
Xglmc_aabb_isvalid(vec3 box[2]);
X
XCGLM_EXPORT
Xfloat
Xglmc_aabb_size(vec3 box[2]);
X
XCGLM_EXPORT
Xfloat
Xglmc_aabb_radius(vec3 box[2]);
X
XCGLM_EXPORT
Xvoid
Xglmc_aabb_center(vec3 box[2], vec3 dest);
X
XCGLM_EXPORT
Xbool
Xglmc_aabb_aabb(vec3 box[2], vec3 other[2]);
X
XCGLM_EXPORT
Xbool
Xglmc_aabb_point(vec3 box[2], vec3 point);
X
XCGLM_EXPORT
Xbool
Xglmc_aabb_contains(vec3 box[2], vec3 other[2]);
X
XCGLM_EXPORT
Xbool
Xglmc_aabb_sphere(vec3 box[2], vec4 s);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_box_h */
X
6c5946d926d405365843ff644268538d
echo x - cglm/call/project.h
sed 's/^X//' >cglm/call/project.h << 'dce23cbd205852cf97ef743c178f3a4a'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_project_h
X#define cglmc_project_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../cglm.h"
X
XCGLM_EXPORT
Xvoid
Xglmc_unprojecti(vec3 pos, mat4 invMat, vec4 vp, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_unproject(vec3 pos, mat4 m, vec4 vp, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_project(vec3 pos, mat4 m, vec4 vp, vec3 dest);
X
XCGLM_EXPORT
Xfloat
Xglmc_project_z(vec3 pos, mat4 m);
X
XCGLM_EXPORT
Xvoid
Xglmc_pickmatrix(vec2 center, vec2 size, vec4 vp, mat4 dest);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_project_h */
X
X
dce23cbd205852cf97ef743c178f3a4a
echo x - cglm/call/sphere.h
sed 's/^X//' >cglm/call/sphere.h << '573e7f9ff899061cccd24dd4d868c026'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_sphere_h
X#define cglmc_sphere_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../cglm.h"
X
XCGLM_EXPORT
Xfloat
Xglmc_sphere_radii(vec4 s);
X
XCGLM_EXPORT
Xvoid
Xglmc_sphere_transform(vec4 s, mat4 m, vec4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_sphere_merge(vec4 s1, vec4 s2, vec4 dest);
X
XCGLM_EXPORT
Xbool
Xglmc_sphere_sphere(vec4 s1, vec4 s2);
X
XCGLM_EXPORT
Xbool
Xglmc_sphere_point(vec4 s, vec3 point);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_sphere_h */
573e7f9ff899061cccd24dd4d868c026
echo x - cglm/call/ease.h
sed 's/^X//' >cglm/call/ease.h << '710779c270d39b542b041307792d573f'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_ease_h
X#define cglmc_ease_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../cglm.h"
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_linear(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_sine_in(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_sine_out(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_sine_inout(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_quad_in(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_quad_out(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_quad_inout(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_cubic_in(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_cubic_out(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_cubic_inout(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_quart_in(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_quart_out(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_quart_inout(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_quint_in(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_quint_out(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_quint_inout(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_exp_in(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_exp_out(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_exp_inout(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_circ_in(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_circ_out(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_circ_inout(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_back_in(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_back_out(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_back_inout(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_elast_in(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_elast_out(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_elast_inout(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_bounce_out(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_bounce_in(float t);
X
XCGLM_EXPORT
Xfloat
Xglmc_ease_bounce_inout(float t);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_ease_h */
710779c270d39b542b041307792d573f
echo x - cglm/call/curve.h
sed 's/^X//' >cglm/call/curve.h << '6590266d691d78ff0608b19443556c75'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_curve_h
X#define cglmc_curve_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../cglm.h"
X
XCGLM_EXPORT
Xfloat
Xglmc_smc(float s, mat4 m, vec4 c);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_curve_h */
6590266d691d78ff0608b19443556c75
echo x - cglm/call/bezier.h
sed 's/^X//' >cglm/call/bezier.h << '2321d08cf4d33eaba2b9056577b4509b'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_bezier_h
X#define cglmc_bezier_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../cglm.h"
X
XCGLM_EXPORT
Xfloat
Xglmc_bezier(float s, float p0, float c0, float c1, float p1);
X
XCGLM_EXPORT
Xfloat
Xglmc_hermite(float s, float p0, float t0, float t1, float p1);
X
XCGLM_EXPORT
Xfloat
Xglmc_decasteljau(float prm, float p0, float c0, float c1, float p1);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_bezier_h */
2321d08cf4d33eaba2b9056577b4509b
echo x - cglm/call/ray.h
sed 's/^X//' >cglm/call/ray.h << '799e04e7b55497b678bfcc85ae107391'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_ray_h
X#define cglmc_ray_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X#include "../cglm.h"
X
XCGLM_EXPORT
Xbool
Xglmc_ray_triangle(vec3   origin,
X                  vec3   direction,
X                  vec3   v0,
X                  vec3   v1,
X                  vec3   v2,
X                  float *d);
X    
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_ray_h */
799e04e7b55497b678bfcc85ae107391
echo x - cglm/call/affine.h
sed 's/^X//' >cglm/call/affine.h << 'f80e95f571dce8350cac70eff8a67116'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_affine_h
X#define cglmc_affine_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../cglm.h"
X
XCGLM_EXPORT
Xvoid
Xglmc_translate_make(mat4 m, vec3 v);
X
XCGLM_EXPORT
Xvoid
Xglmc_translate_to(mat4 m, vec3 v, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_translate(mat4 m, vec3 v);
X
XCGLM_EXPORT
Xvoid
Xglmc_translate_x(mat4 m, float to);
X
XCGLM_EXPORT
Xvoid
Xglmc_translate_y(mat4 m, float to);
X
XCGLM_EXPORT
Xvoid
Xglmc_translate_z(mat4 m, float to);
X
XCGLM_EXPORT
Xvoid
Xglmc_scale_make(mat4 m, vec3 v);
X
XCGLM_EXPORT
Xvoid
Xglmc_scale_to(mat4 m, vec3 v, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_scale(mat4 m, vec3 v);
X
XCGLM_EXPORT
Xvoid
Xglmc_scale_uni(mat4 m, float s);
X
XCGLM_EXPORT
Xvoid
Xglmc_rotate_x(mat4 m, float rad, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_rotate_y(mat4 m, float rad, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_rotate_z(mat4 m, float rad, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_rotate_make(mat4 m, float angle, vec3 axis);
X
XCGLM_EXPORT
Xvoid
Xglmc_rotate(mat4 m, float angle, vec3 axis);
X
XCGLM_EXPORT
Xvoid
Xglmc_rotate_at(mat4 m, vec3 pivot, float angle, vec3 axis);
X
XCGLM_EXPORT
Xvoid
Xglmc_rotate_atm(mat4 m, vec3 pivot, float angle, vec3 axis);
X
XCGLM_EXPORT
Xvoid
Xglmc_spin(mat4 m, float angle, vec3 axis);
X
XCGLM_EXPORT
Xvoid
Xglmc_decompose_scalev(mat4 m, vec3 s);
X
XCGLM_EXPORT
Xbool
Xglmc_uniscaled(mat4 m);
X
XCGLM_EXPORT
Xvoid
Xglmc_decompose_rs(mat4 m, mat4 r, vec3 s);
X
XCGLM_EXPORT
Xvoid
Xglmc_decompose(mat4 m, vec4 t, mat4 r, vec3 s);
X
X/* affine-post */
X
XCGLM_EXPORT
Xvoid
Xglmc_translated(mat4 m, vec3 v);
X
XCGLM_EXPORT
Xvoid
Xglmc_translated_to(mat4 m, vec3 v, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_translated_x(mat4 m, float x);
X
XCGLM_EXPORT
Xvoid
Xglmc_translated_y(mat4 m, float y);
X
XCGLM_EXPORT
Xvoid
Xglmc_translated_z(mat4 m, float z);
X
XCGLM_EXPORT
Xvoid
Xglmc_rotated_x(mat4 m, float angle, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_rotated_y(mat4 m, float angle, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_rotated_z(mat4 m, float angle, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_rotated(mat4 m, float angle, vec3 axis);
X
XCGLM_EXPORT
Xvoid
Xglmc_rotated_at(mat4 m, vec3 pivot, float angle, vec3 axis);
X
XCGLM_EXPORT
Xvoid
Xglmc_spinned(mat4 m, float angle, vec3 axis);
X
X/* affine-mat */
X
XCGLM_EXPORT
Xvoid
Xglmc_mul(mat4 m1, mat4 m2, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_mul_rot(mat4 m1, mat4 m2, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_inv_tr(mat4 mat);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_affine_h */
f80e95f571dce8350cac70eff8a67116
echo x - cglm/call/affine2d.h
sed 's/^X//' >cglm/call/affine2d.h << '9aaea3762209057ad60897069251e181'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_affine2d_h
X#define cglmc_affine2d_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../cglm.h"
X
XCGLM_EXPORT
Xvoid
Xglmc_translate2d_make(mat3 m, vec2 v);
X
XCGLM_EXPORT
Xvoid
Xglmc_translate2d_to(mat3 m, vec2 v, mat3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_translate2d(mat3 m, vec2 v);
X
XCGLM_EXPORT
Xvoid
Xglmc_translate2d_x(mat3 m, float to);
X
XCGLM_EXPORT
Xvoid
Xglmc_translate2d_y(mat3 m, float to);
X
XCGLM_EXPORT
Xvoid
Xglmc_scale2d_to(mat3 m, vec2 v, mat3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_scale2d_make(mat3 m, vec2 v);
X
XCGLM_EXPORT
Xvoid
Xglmc_scale2d(mat3 m, vec2 v);
X
XCGLM_EXPORT
Xvoid
Xglmc_scale2d_uni(mat3 m, float s);
X
XCGLM_EXPORT
Xvoid
Xglmc_rotate2d_make(mat3 m, float angle);
X
XCGLM_EXPORT
Xvoid
Xglmc_rotate2d(mat3 m, float angle);
X
XCGLM_EXPORT
Xvoid
Xglmc_rotate2d_to(mat3 m, float angle, mat3 dest);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_affine2d_h */
9aaea3762209057ad60897069251e181
echo c - cglm/call/clipspace
mkdir -p cglm/call/clipspace > /dev/null 2>&1
echo x - cglm/call/clipspace/persp_lh_no.h
sed 's/^X//' >cglm/call/clipspace/persp_lh_no.h << 'ecbb139ce7c8a1db594212679f13ff6a'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_persp_lh_no_h
X#define cglmc_persp_lh_no_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../../cglm.h"
X
XCGLM_EXPORT
Xvoid
Xglmc_frustum_lh_no(float left,    float right,
X                   float bottom,  float top,
X                   float nearZ,   float farZ,
X                   mat4  dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_perspective_lh_no(float fovy,
X                       float aspect,
X                       float nearVal,
X                       float farVal,
X                       mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_persp_move_far_lh_no(mat4 proj, float deltaFar);
X
XCGLM_EXPORT
Xvoid
Xglmc_persp_decomp_lh_no(mat4 proj,
X                        float * __restrict nearZ, float * __restrict farZ,
X                        float * __restrict top,   float * __restrict bottom,
X                        float * __restrict left,  float * __restrict right);
X
XCGLM_EXPORT
Xvoid
Xglmc_persp_decompv_lh_no(mat4 proj, float dest[6]);
X
XCGLM_EXPORT
Xvoid
Xglmc_persp_decomp_x_lh_no(mat4 proj,
X                          float * __restrict left,
X                          float * __restrict right);
X
XCGLM_EXPORT
Xvoid
Xglmc_persp_decomp_y_lh_no(mat4 proj,
X                          float * __restrict top,
X                          float * __restrict bottom);
X
XCGLM_EXPORT
Xvoid
Xglmc_persp_decomp_z_lh_no(mat4 proj,
X                          float * __restrict nearZ,
X                          float * __restrict farZ);
X
XCGLM_EXPORT
Xvoid
Xglmc_persp_decomp_far_lh_no(mat4 proj, float * __restrict farZ);
X
XCGLM_EXPORT
Xvoid
Xglmc_persp_decomp_near_lh_no(mat4 proj, float * __restrict nearZ);
X
XCGLM_EXPORT
Xvoid
Xglmc_persp_sizes_lh_no(mat4 proj, float fovy, vec4 dest);
X
XCGLM_EXPORT
Xfloat
Xglmc_persp_fovy_lh_no(mat4 proj);
X
XCGLM_EXPORT
Xfloat
Xglmc_persp_aspect_lh_no(mat4 proj);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_persp_lh_no_h */
ecbb139ce7c8a1db594212679f13ff6a
echo x - cglm/call/clipspace/persp_lh_zo.h
sed 's/^X//' >cglm/call/clipspace/persp_lh_zo.h << 'ede9e7158958ec3fb0f1d473a29c0de9'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_persp_lh_zo_h
X#define cglmc_persp_lh_zo_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../../cglm.h"
X
XCGLM_EXPORT
Xvoid
Xglmc_frustum_lh_zo(float left,    float right,
X                   float bottom,  float top,
X                   float nearZ,   float farZ,
X                   mat4  dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_perspective_lh_zo(float fovy,
X                       float aspect,
X                       float nearVal,
X                       float farVal,
X                       mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_persp_move_far_lh_zo(mat4 proj, float deltaFar);
X
XCGLM_EXPORT
Xvoid
Xglmc_persp_decomp_lh_zo(mat4 proj,
X                        float * __restrict nearZ, float * __restrict farZ,
X                        float * __restrict top,   float * __restrict bottom,
X                        float * __restrict left,  float * __restrict right);
X
XCGLM_EXPORT
Xvoid
Xglmc_persp_decompv_lh_zo(mat4 proj, float dest[6]);
X
XCGLM_EXPORT
Xvoid
Xglmc_persp_decomp_x_lh_zo(mat4 proj,
X                          float * __restrict left,
X                          float * __restrict right);
X
XCGLM_EXPORT
Xvoid
Xglmc_persp_decomp_y_lh_zo(mat4 proj,
X                          float * __restrict top,
X                          float * __restrict bottom);
X
XCGLM_EXPORT
Xvoid
Xglmc_persp_decomp_z_lh_zo(mat4 proj,
X                          float * __restrict nearZ,
X                          float * __restrict farZ);
X
XCGLM_EXPORT
Xvoid
Xglmc_persp_decomp_far_lh_zo(mat4 proj, float * __restrict farZ);
X
XCGLM_EXPORT
Xvoid
Xglmc_persp_decomp_near_lh_zo(mat4 proj, float * __restrict nearZ);
X
XCGLM_EXPORT
Xvoid
Xglmc_persp_sizes_lh_zo(mat4 proj, float fovy, vec4 dest);
X
XCGLM_EXPORT
Xfloat
Xglmc_persp_fovy_lh_zo(mat4 proj);
X
XCGLM_EXPORT
Xfloat
Xglmc_persp_aspect_lh_zo(mat4 proj);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_persp_lh_zo_h */
ede9e7158958ec3fb0f1d473a29c0de9
echo x - cglm/call/clipspace/persp_rh_no.h
sed 's/^X//' >cglm/call/clipspace/persp_rh_no.h << '169ea73590ae023a76a53eca866fb482'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_persp_rh_no_h
X#define cglmc_persp_rh_no_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../../cglm.h"
X
XCGLM_EXPORT
Xvoid
Xglmc_frustum_rh_no(float left,    float right,
X                   float bottom,  float top,
X                   float nearZ,   float farZ,
X                   mat4  dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_perspective_rh_no(float fovy,
X                       float aspect,
X                       float nearVal,
X                       float farVal,
X                       mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_persp_move_far_rh_no(mat4 proj, float deltaFar);
X
XCGLM_EXPORT
Xvoid
Xglmc_persp_decomp_rh_no(mat4 proj,
X                        float * __restrict nearZ, float * __restrict farZ,
X                        float * __restrict top,   float * __restrict bottom,
X                        float * __restrict left,  float * __restrict right);
X
XCGLM_EXPORT
Xvoid
Xglmc_persp_decompv_rh_no(mat4 proj, float dest[6]);
X
XCGLM_EXPORT
Xvoid
Xglmc_persp_decomp_x_rh_no(mat4 proj,
X                          float * __restrict left,
X                          float * __restrict right);
X
XCGLM_EXPORT
Xvoid
Xglmc_persp_decomp_y_rh_no(mat4 proj,
X                          float * __restrict top,
X                          float * __restrict bottom);
X
XCGLM_EXPORT
Xvoid
Xglmc_persp_decomp_z_rh_no(mat4 proj,
X                          float * __restrict nearZ,
X                          float * __restrict farZ);
X
XCGLM_EXPORT
Xvoid
Xglmc_persp_decomp_far_rh_no(mat4 proj, float * __restrict farZ);
X
XCGLM_EXPORT
Xvoid
Xglmc_persp_decomp_near_rh_no(mat4 proj, float * __restrict nearZ);
X
XCGLM_EXPORT
Xvoid
Xglmc_persp_sizes_rh_no(mat4 proj, float fovy, vec4 dest);
X
XCGLM_EXPORT
Xfloat
Xglmc_persp_fovy_rh_no(mat4 proj);
X
XCGLM_EXPORT
Xfloat
Xglmc_persp_aspect_rh_no(mat4 proj);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_persp_rh_no_h */
169ea73590ae023a76a53eca866fb482
echo x - cglm/call/clipspace/persp_rh_zo.h
sed 's/^X//' >cglm/call/clipspace/persp_rh_zo.h << 'adbfb5decdeaead5297fb41eb5450767'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_persp_rh_zo_h
X#define cglmc_persp_rh_zo_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../../cglm.h"
X
XCGLM_EXPORT
Xvoid
Xglmc_frustum_rh_zo(float left,    float right,
X                   float bottom,  float top,
X                   float nearZ,   float farZ,
X                   mat4  dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_perspective_rh_zo(float fovy,
X                       float aspect,
X                       float nearVal,
X                       float farVal,
X                       mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_persp_move_far_rh_zo(mat4 proj, float deltaFar);
X
XCGLM_EXPORT
Xvoid
Xglmc_persp_decomp_rh_zo(mat4 proj,
X                        float * __restrict nearZ, float * __restrict farZ,
X                        float * __restrict top,   float * __restrict bottom,
X                        float * __restrict left,  float * __restrict right);
X
XCGLM_EXPORT
Xvoid
Xglmc_persp_decompv_rh_zo(mat4 proj, float dest[6]);
X
XCGLM_EXPORT
Xvoid
Xglmc_persp_decomp_x_rh_zo(mat4 proj,
X                          float * __restrict left,
X                          float * __restrict right);
X
XCGLM_EXPORT
Xvoid
Xglmc_persp_decomp_y_rh_zo(mat4 proj,
X                          float * __restrict top,
X                          float * __restrict bottom);
X
XCGLM_EXPORT
Xvoid
Xglmc_persp_decomp_z_rh_zo(mat4 proj,
X                          float * __restrict nearZ,
X                          float * __restrict farZ);
X
XCGLM_EXPORT
Xvoid
Xglmc_persp_decomp_far_rh_zo(mat4 proj, float * __restrict farZ);
X
XCGLM_EXPORT
Xvoid
Xglmc_persp_decomp_near_rh_zo(mat4 proj, float * __restrict nearZ);
X
XCGLM_EXPORT
Xvoid
Xglmc_persp_sizes_rh_zo(mat4 proj, float fovy, vec4 dest);
X
XCGLM_EXPORT
Xfloat
Xglmc_persp_fovy_rh_zo(mat4 proj);
X
XCGLM_EXPORT
Xfloat
Xglmc_persp_aspect_rh_zo(mat4 proj);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_persp_rh_zo_h */
adbfb5decdeaead5297fb41eb5450767
echo x - cglm/call/clipspace/ortho_lh_no.h
sed 's/^X//' >cglm/call/clipspace/ortho_lh_no.h << '9f94c3a632bd8f736e1517759aaea431'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_ortho_lh_no_h
X#define cglmc_ortho_lh_no_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../../cglm.h"
X
XCGLM_EXPORT
Xvoid
Xglmc_ortho_lh_no(float left,    float right,
X                 float bottom,  float top,
X                 float nearZ,   float farZ,
X                 mat4  dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ortho_aabb_lh_no(vec3 box[2], mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ortho_aabb_p_lh_no(vec3 box[2], float padding, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ortho_aabb_pz_lh_no(vec3 box[2], float padding, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ortho_default_lh_no(float aspect, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ortho_default_s_lh_no(float aspect, float size, mat4 dest);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_ortho_lh_no_h */
9f94c3a632bd8f736e1517759aaea431
echo x - cglm/call/clipspace/ortho_lh_zo.h
sed 's/^X//' >cglm/call/clipspace/ortho_lh_zo.h << 'd5b92e164d97150de65b91739d0994e6'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_ortho_lh_zo_h
X#define cglmc_ortho_lh_zo_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../../cglm.h"
X
XCGLM_EXPORT
Xvoid
Xglmc_ortho_lh_zo(float left,    float right,
X                 float bottom,  float top,
X                 float nearZ,   float farZ,
X                 mat4  dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ortho_aabb_lh_zo(vec3 box[2], mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ortho_aabb_p_lh_zo(vec3 box[2], float padding, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ortho_aabb_pz_lh_zo(vec3 box[2], float padding, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ortho_default_lh_zo(float aspect, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ortho_default_s_lh_zo(float aspect, float size, mat4 dest);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_ortho_lh_zo_h */
d5b92e164d97150de65b91739d0994e6
echo x - cglm/call/clipspace/ortho_rh_no.h
sed 's/^X//' >cglm/call/clipspace/ortho_rh_no.h << 'cbc759ceb233c24ec45053107bc77625'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_ortho_rh_no_h
X#define cglmc_ortho_rh_no_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../../cglm.h"
X
XCGLM_EXPORT
Xvoid
Xglmc_ortho_rh_no(float left,    float right,
X                 float bottom,  float top,
X                 float nearZ,   float farZ,
X                 mat4  dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ortho_aabb_rh_no(vec3 box[2], mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ortho_aabb_p_rh_no(vec3 box[2], float padding, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ortho_aabb_pz_rh_no(vec3 box[2], float padding, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ortho_default_rh_no(float aspect, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ortho_default_s_rh_no(float aspect, float size, mat4 dest);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_ortho_rh_no_h */
cbc759ceb233c24ec45053107bc77625
echo x - cglm/call/clipspace/ortho_rh_zo.h
sed 's/^X//' >cglm/call/clipspace/ortho_rh_zo.h << '51e51183aa8f30a58849611987804b4b'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_ortho_rh_zo_h
X#define cglmc_ortho_rh_zo_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../../cglm.h"
X
XCGLM_EXPORT
Xvoid
Xglmc_ortho_rh_zo(float left,    float right,
X                 float bottom,  float top,
X                 float nearZ,   float farZ,
X                 mat4  dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ortho_aabb_rh_zo(vec3 box[2], mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ortho_aabb_p_rh_zo(vec3 box[2], float padding, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ortho_aabb_pz_rh_zo(vec3 box[2], float padding, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ortho_default_rh_zo(float aspect, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_ortho_default_s_rh_zo(float aspect, float size, mat4 dest);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_ortho_rh_zo_h */
51e51183aa8f30a58849611987804b4b
echo x - cglm/call/clipspace/view_lh_no.h
sed 's/^X//' >cglm/call/clipspace/view_lh_no.h << '41bddd2fadbc96a05291b422ea7e143c'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_view_lh_no_h
X#define cglmc_view_lh_no_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../../cglm.h"
X
XCGLM_EXPORT
Xvoid
Xglmc_lookat_lh_no(vec3 eye, vec3 center, vec3 up, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_look_lh_no(vec3 eye, vec3 dir, vec3 up, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_look_anyup_lh_no(vec3 eye, vec3 dir, mat4 dest);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_view_lh_no_h */
41bddd2fadbc96a05291b422ea7e143c
echo x - cglm/call/clipspace/view_lh_zo.h
sed 's/^X//' >cglm/call/clipspace/view_lh_zo.h << '6193208fcbe74f8beea9e3cadf8b612d'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_view_lh_zo_h
X#define cglmc_view_lh_zo_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../../cglm.h"
X
XCGLM_EXPORT
Xvoid
Xglmc_lookat_lh_zo(vec3 eye, vec3 center, vec3 up, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_look_lh_zo(vec3 eye, vec3 dir, vec3 up, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_look_anyup_lh_zo(vec3 eye, vec3 dir, mat4 dest);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_view_lh_zo_h */
6193208fcbe74f8beea9e3cadf8b612d
echo x - cglm/call/clipspace/view_rh_no.h
sed 's/^X//' >cglm/call/clipspace/view_rh_no.h << '690e18628b2d2927b7a7a1804fab9a7a'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_view_rh_no_h
X#define cglmc_view_rh_no_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../../cglm.h"
X
XCGLM_EXPORT
Xvoid
Xglmc_lookat_rh_no(vec3 eye, vec3 center, vec3 up, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_look_rh_no(vec3 eye, vec3 dir, vec3 up, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_look_anyup_rh_no(vec3 eye, vec3 dir, mat4 dest);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_view_rh_no_h */
690e18628b2d2927b7a7a1804fab9a7a
echo x - cglm/call/clipspace/view_rh_zo.h
sed 's/^X//' >cglm/call/clipspace/view_rh_zo.h << '5c4a6d88b11bd2d2ad6a2ba335cb6c62'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_view_rh_zo_h
X#define cglmc_view_rh_zo_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../../cglm.h"
X
XCGLM_EXPORT
Xvoid
Xglmc_lookat_rh_zo(vec3 eye, vec3 center, vec3 up, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_look_rh_zo(vec3 eye, vec3 dir, vec3 up, mat4 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_look_anyup_rh_zo(vec3 eye, vec3 dir, mat4 dest);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_view_rh_zo_h */
5c4a6d88b11bd2d2ad6a2ba335cb6c62
echo x - cglm/call/clipspace/project_no.h
sed 's/^X//' >cglm/call/clipspace/project_no.h << '7f79d1dd02269cdb440bd49cb70c4413'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_project_no_h
X#define cglmc_project_no_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../../cglm.h"
X
XCGLM_EXPORT
Xvoid
Xglmc_unprojecti_no(vec3 pos, mat4 invMat, vec4 vp, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_project_no(vec3 pos, mat4 m, vec4 vp, vec3 dest);
X
XCGLM_EXPORT
Xfloat
Xglmc_project_z_no(vec3 pos, mat4 m);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_project_no_h */
7f79d1dd02269cdb440bd49cb70c4413
echo x - cglm/call/clipspace/project_zo.h
sed 's/^X//' >cglm/call/clipspace/project_zo.h << '6fe7b1028b9f301aee72fbbee51a9678'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglmc_project_zo_h
X#define cglmc_project_zo_h
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#include "../../cglm.h"
X
XCGLM_EXPORT
Xvoid
Xglmc_unprojecti_zo(vec3 pos, mat4 invMat, vec4 vp, vec3 dest);
X
XCGLM_EXPORT
Xvoid
Xglmc_project_zo(vec3 pos, mat4 m, vec4 vp, vec3 dest);
X
XCGLM_EXPORT
Xfloat
Xglmc_project_z_zo(vec3 pos, mat4 m);
X
X#ifdef __cplusplus
X}
X#endif
X#endif /* cglmc_project_zo_h */
6fe7b1028b9f301aee72fbbee51a9678
echo c - cglm/clipspace
mkdir -p cglm/clipspace > /dev/null 2>&1
echo x - cglm/clipspace/persp.h
sed 's/^X//' >cglm/clipspace/persp.h << '6a82807ba847ebfe6d73739af12a3a3c'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Functions:
X   CGLM_INLINE void  glm_persp_decomp_far(mat4 proj, float *farZ)
X   CGLM_INLINE float glm_persp_fovy(mat4 proj)
X   CGLM_INLINE float glm_persp_aspect(mat4 proj)
X   CGLM_INLINE void  glm_persp_sizes(mat4 proj, float fovy, vec4 dest)
X */
X
X#ifndef cglm_persp_h
X#define cglm_persp_h
X
X#include "../common.h"
X#include "../plane.h"
X#include "../mat4.h"
X
X/*!
X * @brief returns field of view angle along the Y-axis (in radians)
X *
X * if you need to degrees, use glm_deg to convert it or use this:
X * fovy_deg = glm_deg(glm_persp_fovy(projMatrix))
X *
X * @param[in] proj perspective projection matrix
X */
XCGLM_INLINE
Xfloat
Xglm_persp_fovy(mat4 proj) {
X  return 2.0f * atanf(1.0f / proj[1][1]);
X}
X
X/*!
X * @brief returns aspect ratio of perspective projection
X *
X * @param[in] proj perspective projection matrix
X */
XCGLM_INLINE
Xfloat
Xglm_persp_aspect(mat4 proj) {
X  return proj[1][1] / proj[0][0];
X}
X
X#endif /* cglm_persp_h */
6a82807ba847ebfe6d73739af12a3a3c
echo x - cglm/clipspace/persp_lh_no.h
sed 's/^X//' >cglm/clipspace/persp_lh_no.h << '4c5326e124987e842084195bfd6db521'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Functions:
X   CGLM_INLINE void glm_frustum_lh_no(float left,    float right,
X                                       float bottom,  float top,
X                                       float nearZ, float farZ,
X                                       mat4  dest)
X   CGLM_INLINE void glm_perspective_lh_no(float fovy,
X                                          float aspect,
X                                          float nearZ,
X                                          float farZ,
X                                          mat4  dest)
X   CGLM_INLINE void glm_perspective_default_lh_no(float aspect, mat4 dest)
X   CGLM_INLINE void glm_perspective_resize_lh_no(float aspect, mat4 proj)
X   CGLM_INLINE void glm_persp_move_far_lh_no(mat4 proj,
X                                             float deltaFar)
X   CGLM_INLINE void glm_persp_decomp_lh_no(mat4 proj,
X                                           float * __restrict nearZ,
X                                           float * __restrict farZ,
X                                           float * __restrict top,
X                                           float * __restrict bottom,
X                                           float * __restrict left,
X                                           float * __restrict right)
X  CGLM_INLINE void glm_persp_decompv_lh_no(mat4 proj,
X                                           float dest[6])
X  CGLM_INLINE void glm_persp_decomp_x_lh_no(mat4 proj,
X                                            float * __restrict left,
X                                            float * __restrict right)
X  CGLM_INLINE void glm_persp_decomp_y_lh_no(mat4 proj,
X                                            float * __restrict top,
X                                            float * __restrict bottom)
X  CGLM_INLINE void glm_persp_decomp_z_lh_no(mat4 proj,
X                                            float * __restrict nearZ,
X                                            float * __restrict farZ)
X  CGLM_INLINE void glm_persp_decomp_far_lh_no(mat4 proj, float * __restrict farZ)
X  CGLM_INLINE void glm_persp_decomp_near_lh_no(mat4 proj, float * __restrict nearZ)
X  CGLM_INLINE void glm_persp_sizes_lh_no(mat4 proj, float fovy, vec4 dest)
X */
X
X#ifndef cglm_persp_lh_no_h
X#define cglm_persp_lh_no_h
X
X#include "../common.h"
X#include "persp.h"
X
X/*!
X * @brief set up perspective peprojection matrix
X *        with a left-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * @param[in]  left    viewport.left
X * @param[in]  right   viewport.right
X * @param[in]  bottom  viewport.bottom
X * @param[in]  top     viewport.top
X * @param[in]  nearZ   near clipping plane
X * @param[in]  farZ    far clipping plane
X * @param[out] dest    result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_frustum_lh_no(float left,    float right,
X                  float bottom,  float top,
X                  float nearZ, float farZ,
X                  mat4  dest) {
X  float rl, tb, fn, nv;
X
X  glm_mat4_zero(dest);
X
X  rl = 1.0f / (right  - left);
X  tb = 1.0f / (top    - bottom);
X  fn =-1.0f / (farZ - nearZ);
X  nv = 2.0f * nearZ;
X
X  dest[0][0] = nv * rl;
X  dest[1][1] = nv * tb;
X  dest[2][0] = (right  + left)    * rl;
X  dest[2][1] = (top    + bottom)  * tb;
X  dest[2][2] =-(farZ + nearZ) * fn;
X  dest[2][3] = 1.0f;
X  dest[3][2] = farZ * nv * fn;
X}
X
X/*!
X * @brief set up perspective projection matrix
X *        with a left-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * @param[in]  fovy    field of view angle
X * @param[in]  aspect  aspect ratio ( width / height )
X * @param[in]  nearZ   near clipping plane
X * @param[in]  farZ    far clipping planes
X * @param[out] dest    result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_perspective_lh_no(float fovy,
X                      float aspect,
X                      float nearZ,
X                      float farZ,
X                      mat4  dest) {
X  float f, fn;
X
X  glm_mat4_zero(dest);
X
X  f  = 1.0f / tanf(fovy * 0.5f);
X  fn = 1.0f / (nearZ - farZ);
X
X  dest[0][0] = f / aspect;
X  dest[1][1] = f;
X  dest[2][2] =-(nearZ + farZ) * fn;
X  dest[2][3] = 1.0f;
X  dest[3][2] = 2.0f * nearZ * farZ * fn;
X
X}
X
X/*!
X * @brief set up perspective projection matrix with default near/far
X *        and angle values with a left-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * @param[in]  aspect aspect ratio ( width / height )
X * @param[out] dest   result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_perspective_default_lh_no(float aspect, mat4 dest) {
X  glm_perspective_lh_no(GLM_PI_4f, aspect, 0.01f, 100.0f, dest);
X}
X
X/*!
X * @brief resize perspective matrix by aspect ratio ( width / height )
X *        this makes very easy to resize proj matrix when window /viewport
X *        resized with a left-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * @param[in]      aspect aspect ratio ( width / height )
X * @param[in, out] proj   perspective projection matrix
X */
XCGLM_INLINE
Xvoid
Xglm_perspective_resize_lh_no(float aspect, mat4 proj) {
X  if (proj[0][0] == 0.0f)
X    return;
X
X  proj[0][0] = proj[1][1] / aspect;
X}
X
X/*!
X * @brief extend perspective projection matrix's far distance
X *        with a left-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * this function does not guarantee far >= near, be aware of that!
X *
X * @param[in, out] proj      projection matrix to extend
X * @param[in]      deltaFar  distance from existing far (negative to shink)
X */
XCGLM_INLINE
Xvoid
Xglm_persp_move_far_lh_no(mat4 proj, float deltaFar) {
X  float fn, farZ, nearZ, p22, p32;
X
X  p22        = -proj[2][2];
X  p32        = proj[3][2];
X
X  nearZ    = p32 / (p22 - 1.0f);
X  farZ     = p32 / (p22 + 1.0f) + deltaFar;
X  fn         = 1.0f / (nearZ - farZ);
X
X  proj[2][2] = -(farZ + nearZ) * fn;
X  proj[3][2] = 2.0f * nearZ * farZ * fn;
X}
X
X/*!
X * @brief decomposes frustum values of perspective projection
X *        with a left-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * @param[in]  proj    perspective projection matrix
X * @param[out] nearZ   near
X * @param[out] farZ    far
X * @param[out] top     top
X * @param[out] bottom  bottom
X * @param[out] left    left
X * @param[out] right   right
X */
XCGLM_INLINE
Xvoid
Xglm_persp_decomp_lh_no(mat4 proj,
X                       float * __restrict nearZ, float * __restrict farZ,
X                       float * __restrict top,   float * __restrict bottom,
X                       float * __restrict left,  float * __restrict right) {
X  float m00, m11, m20, m21, m22, m32, n, f;
X  float n_m11, n_m00;
X
X  m00 = proj[0][0];
X  m11 = proj[1][1];
X  m20 = proj[2][0];
X  m21 = proj[2][1];
X  m22 =-proj[2][2];
X  m32 = proj[3][2];
X
X  n = m32 / (m22 - 1.0f);
X  f = m32 / (m22 + 1.0f);
X
X  n_m11 = n / m11;
X  n_m00 = n / m00;
X
X  *nearZ = n;
X  *farZ  = f;
X  *bottom  = n_m11 * (m21 - 1.0f);
X  *top     = n_m11 * (m21 + 1.0f);
X  *left    = n_m00 * (m20 - 1.0f);
X  *right   = n_m00 * (m20 + 1.0f);
X}
X
X/*!
X * @brief decomposes frustum values of perspective projection
X *        with a left-hand coordinate system and a
X *        clip-space of [-1, 1].
X *        this makes easy to get all values at once
X *
X * @param[in]  proj   perspective projection matrix
X * @param[out] dest   array
X */
XCGLM_INLINE
Xvoid
Xglm_persp_decompv_lh_no(mat4 proj, float dest[6]) {
X  glm_persp_decomp_lh_no(proj, &dest[0], &dest[1], &dest[2],
X                               &dest[3], &dest[4], &dest[5]);
X}
X
X/*!
X * @brief decomposes left and right values of perspective projection
X *        with a left-hand coordinate system and a
X *        clip-space of [-1, 1].
X *        x stands for x axis (left / right axis)
X *
X * @param[in]  proj  perspective projection matrix
X * @param[out] left  left
X * @param[out] right right
X */
XCGLM_INLINE
Xvoid
Xglm_persp_decomp_x_lh_no(mat4 proj,
X                         float * __restrict left,
X                         float * __restrict right) {
X  float nearZ, m20, m00, m22;
X
X  m00 = proj[0][0];
X  m20 = proj[2][0];
X  m22 =-proj[2][2];
X
X  nearZ = proj[3][2] / (m22 - 1.0f);
X  *left   = nearZ * (m20 - 1.0f) / m00;
X  *right  = nearZ * (m20 + 1.0f) / m00;
X}
X
X/*!
X * @brief decomposes top and bottom values of perspective projection
X *        with a left-hand coordinate system and a
X *        clip-space of [-1, 1].
X *        y stands for y axis (top / botom axis)
X *
X * @param[in]  proj   perspective projection matrix
X * @param[out] top    top
X * @param[out] bottom bottom
X */
XCGLM_INLINE
Xvoid
Xglm_persp_decomp_y_lh_no(mat4 proj,
X                         float * __restrict top,
X                         float * __restrict bottom) {
X  float nearZ, m21, m11, m22;
X
X  m21 = proj[2][1];
X  m11 = proj[1][1];
X  m22 =-proj[2][2];
X
X  nearZ = proj[3][2] / (m22 - 1.0f);
X  *bottom = nearZ * (m21 - 1.0f) / m11;
X  *top    = nearZ * (m21 + 1.0f) / m11;
X}
X
X/*!
X * @brief decomposes near and far values of perspective projection
X *        with a left-hand coordinate system and a
X *        clip-space of [-1, 1].
X *        z stands for z axis (near / far axis)
X *
X * @param[in]  proj    perspective projection matrix
X * @param[out] nearZ   near
X * @param[out] farZ    far
X */
XCGLM_INLINE
Xvoid
Xglm_persp_decomp_z_lh_no(mat4 proj,
X                         float * __restrict nearZ,
X                         float * __restrict farZ) {
X  float m32, m22;
X
X  m32 = proj[3][2];
X  m22 =-proj[2][2];
X
X  *nearZ = m32 / (m22 - 1.0f);
X  *farZ  = m32 / (m22 + 1.0f);
X}
X
X/*!
X * @brief decomposes far value of perspective projection
X *        with a left-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * @param[in]  proj   perspective projection matrix
X * @param[out] farZ   far
X */
XCGLM_INLINE
Xvoid
Xglm_persp_decomp_far_lh_no(mat4 proj, float * __restrict farZ) {
X  *farZ = proj[3][2] / (-proj[2][2] + 1.0f);
X}
X
X/*!
X * @brief decomposes near value of perspective projection
X *        with a left-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * @param[in]  proj    perspective projection matrix
X * @param[out] nearZ   near
X */
XCGLM_INLINE
Xvoid
Xglm_persp_decomp_near_lh_no(mat4 proj, float * __restrict nearZ) {
X  *nearZ = proj[3][2] / (-proj[2][2] - 1.0f);
X}
X
X/*!
X * @brief returns sizes of near and far planes of perspective projection
X *        with a left-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * @param[in]  proj perspective projection matrix
X * @param[in]  fovy fovy (see brief)
X * @param[out] dest sizes order: [Wnear, Hnear, Wfar, Hfar]
X */
XCGLM_INLINE
Xvoid
Xglm_persp_sizes_lh_no(mat4 proj, float fovy, vec4 dest) {
X  float t, a, nearZ, farZ;
X
X  t = 2.0f * tanf(fovy * 0.5f);
X  a = glm_persp_aspect(proj);
X
X  glm_persp_decomp_z_lh_no(proj, &nearZ, &farZ);
X
X  dest[1]  = t * nearZ;
X  dest[3]  = t * farZ;
X  dest[0]  = a * dest[1];
X  dest[2]  = a * dest[3];
X}
X
X/*!
X * @brief returns field of view angle along the Y-axis (in radians)
X *        with a left-hand coordinate system and a clip-space of [-1, 1].
X *
X * if you need to degrees, use glm_deg to convert it or use this:
X * fovy_deg = glm_deg(glm_persp_fovy(projMatrix))
X *
X * @param[in] proj perspective projection matrix
X */
XCGLM_INLINE
Xfloat
Xglm_persp_fovy_lh_no(mat4 proj) {
X  return glm_persp_fovy(proj);
X}
X
X/*!
X * @brief returns aspect ratio of perspective projection
X *        with a left-hand coordinate system and a clip-space of [-1, 1].
X *
X * @param[in] proj perspective projection matrix
X */
XCGLM_INLINE
Xfloat
Xglm_persp_aspect_lh_no(mat4 proj) {
X  return glm_persp_aspect(proj);
X}
X
X#endif /*cglm_cam_lh_no_h*/
4c5326e124987e842084195bfd6db521
echo x - cglm/clipspace/persp_lh_zo.h
sed 's/^X//' >cglm/clipspace/persp_lh_zo.h << '0cd16a24d919ea7b78e36b49080cf496'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Functions:
X   CGLM_INLINE void glm_frustum_lh_zo(float left,    float right,
X                                      float bottom,  float top,
X                                      float nearZ, float farZ,
X                                      mat4  dest)
X   CGLM_INLINE void glm_perspective_lh_zo(float fovy,
X                                          float aspect,
X                                          float nearZ,
X                                          float farZ,
X                                          mat4  dest)
X   CGLM_INLINE void glm_perspective_default_lh_zo(float aspect, mat4 dest)
X   CGLM_INLINE void glm_perspective_resize_lh_zo(float aspect, mat4 proj)
X   CGLM_INLINE void glm_persp_move_far_lh_zo(mat4 proj,
X                                             float deltaFar)
X   CGLM_INLINE void glm_persp_decomp_lh_zo(mat4 proj,
X                                           float * __restrict nearZ,
X                                           float * __restrict farZ,
X                                           float * __restrict top,
X                                           float * __restrict bottom,
X                                           float * __restrict left,
X                                           float * __restrict right)
X  CGLM_INLINE void glm_persp_decompv_lh_zo(mat4 proj,
X                                           float dest[6])
X  CGLM_INLINE void glm_persp_decomp_x_lh_zo(mat4 proj,
X                                            float * __restrict left,
X                                            float * __restrict right)
X  CGLM_INLINE void glm_persp_decomp_y_lh_zo(mat4 proj,
X                                            float * __restrict top,
X                                            float * __restrict bottom)
X  CGLM_INLINE void glm_persp_decomp_z_lh_zo(mat4 proj,
X                                            float * __restrict nearZ,
X                                            float * __restrict farZ)
X  CGLM_INLINE void glm_persp_decomp_far_lh_zo(mat4 proj, float * __restrict farZ)
X  CGLM_INLINE void glm_persp_decomp_near_lh_zo(mat4 proj, float * __restrict nearZ)
X  CGLM_INLINE void glm_persp_sizes_lh_zo(mat4 proj, float fovy, vec4 dest)
X */
X
X#ifndef cglm_persp_lh_zo_h
X#define cglm_persp_lh_zo_h
X
X#include "../common.h"
X#include "persp.h"
X
X/*!
X * @brief set up perspective peprojection matrix with a left-hand coordinate
X *        system and a clip-space of [0, 1].
X *
X * @param[in]  left    viewport.left
X * @param[in]  right   viewport.right
X * @param[in]  bottom  viewport.bottom
X * @param[in]  top     viewport.top
X * @param[in]  nearZ   near clipping plane
X * @param[in]  farZ    far clipping plane
X * @param[out] dest    result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_frustum_lh_zo(float left,    float right,
X                  float bottom,  float top,
X                  float nearZ, float farZ,
X                  mat4  dest) {
X  float rl, tb, fn, nv;
X
X  glm_mat4_zero(dest);
X
X  rl = 1.0f / (right  - left);
X  tb = 1.0f / (top    - bottom);
X  fn =-1.0f / (farZ - nearZ);
X  nv = 2.0f * nearZ;
X
X  dest[0][0] = nv * rl;
X  dest[1][1] = nv * tb;
X  dest[2][0] = (right  + left)    * rl;
X  dest[2][1] = (top    + bottom)  * tb;
X  dest[2][2] =-farZ * fn;
X  dest[2][3] = 1.0f;
X  dest[3][2] = farZ * nearZ * fn;
X}
X
X/*!
X * @brief set up perspective projection matrix with a left-hand coordinate
X * system and a clip-space of [0, 1].
X *
X * @param[in]  fovy    field of view angle
X * @param[in]  aspect  aspect ratio ( width / height )
X * @param[in]  nearZ   near clipping plane
X * @param[in]  farZ    far clipping planes
X * @param[out] dest    result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_perspective_lh_zo(float fovy,
X                      float aspect,
X                      float nearZ,
X                      float farZ,
X                      mat4  dest) {
X  float f, fn;
X
X  glm_mat4_zero(dest);
X
X  f  = 1.0f / tanf(fovy * 0.5f);
X  fn = 1.0f / (nearZ - farZ);
X
X  dest[0][0] = f / aspect;
X  dest[1][1] = f;
X  dest[2][2] =-farZ * fn;
X  dest[2][3] = 1.0f;
X  dest[3][2] = nearZ * farZ * fn;
X}
X
X/*!
X * @brief extend perspective projection matrix's far distance with a
X *        left-hand coordinate system and a clip-space with depth values
X *        from zero to one.
X *
X * this function does not guarantee far >= near, be aware of that!
X *
X * @param[in, out] proj      projection matrix to extend
X * @param[in]      deltaFar  distance from existing far (negative to shink)
X */
XCGLM_INLINE
Xvoid
Xglm_persp_move_far_lh_zo(mat4 proj, float deltaFar) {
X  float fn, farZ, nearZ, p22, p32;
X
X  p22        = -proj[2][2];
X  p32        = proj[3][2];
X
X  nearZ    = p32 / p22;
X  farZ     = p32 / (p22 + 1.0f) + deltaFar;
X  fn         = 1.0f / (nearZ - farZ);
X
X  proj[2][2] = -farZ * fn;
X  proj[3][2] = nearZ * farZ * fn;
X}
X
X/*!
X * @brief set up perspective projection matrix with default near/far
X *        and angle values with a left-hand coordinate system and a 
X *        clip-space of [0, 1].
X *
X * @param[in]  aspect aspect ratio ( width / height )
X * @param[out] dest   result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_perspective_default_lh_zo(float aspect, mat4 dest) {
X  glm_perspective_lh_zo(GLM_PI_4f, aspect, 0.01f, 100.0f, dest);
X}
X
X/*!
X * @brief resize perspective matrix by aspect ratio ( width / height )
X *        this makes very easy to resize proj matrix when window /viewport
X *        reized
X *
X * @param[in]      aspect aspect ratio ( width / height )
X * @param[in, out] proj   perspective projection matrix
X */
XCGLM_INLINE
Xvoid
Xglm_perspective_resize_lh_zo(float aspect, mat4 proj) {
X  if (proj[0][0] == 0.0f)
X    return;
X
X  proj[0][0] = proj[1][1] / aspect;
X}
X
X/*!
X * @brief decomposes frustum values of perspective projection
X *        with angle values with a left-hand coordinate system and a 
X *        clip-space of [0, 1].
X *
X * @param[in]  proj    perspective projection matrix
X * @param[out] nearZ   near
X * @param[out] farZ    far
X * @param[out] top     top
X * @param[out] bottom  bottom
X * @param[out] left    left
X * @param[out] right   right
X */
XCGLM_INLINE
Xvoid
Xglm_persp_decomp_lh_zo(mat4 proj,
X                    float * __restrict nearZ, float * __restrict farZ,
X                    float * __restrict top,     float * __restrict bottom,
X                    float * __restrict left,    float * __restrict right) {
X  float m00, m11, m20, m21, m22, m32, n, f;
X  float n_m11, n_m00;
X
X  m00 = proj[0][0];
X  m11 = proj[1][1];
X  m20 = proj[2][0];
X  m21 = proj[2][1];
X  m22 =-proj[2][2];
X  m32 = proj[3][2];
X
X  n = m32 / m22;
X  f = m32 / (m22 + 1.0f);
X
X  n_m11 = n / m11;
X  n_m00 = n / m00;
X
X  *nearZ = n;
X  *farZ  = f;
X  *bottom  = n_m11 * (m21 - 1.0f);
X  *top     = n_m11 * (m21 + 1.0f);
X  *left    = n_m00 * (m20 - 1.0f);
X  *right   = n_m00 * (m20 + 1.0f);
X}
X
X/*!
X * @brief decomposes frustum values of perspective projection
X *        with angle values with a left-hand coordinate system and a 
X *        clip-space of [0, 1].
X *        this makes easy to get all values at once
X *
X * @param[in]  proj   perspective projection matrix
X * @param[out] dest   array
X */
XCGLM_INLINE
Xvoid
Xglm_persp_decompv_lh_zo(mat4 proj, float dest[6]) {
X  glm_persp_decomp_lh_zo(proj, &dest[0], &dest[1], &dest[2],
X                               &dest[3], &dest[4], &dest[5]);
X}
X
X/*!
X * @brief decomposes left and right values of perspective projection (ZO).
X *        x stands for x axis (left / right axis)
X *
X * @param[in]  proj  perspective projection matrix
X * @param[out] left  left
X * @param[out] right right
X */
XCGLM_INLINE
Xvoid
Xglm_persp_decomp_x_lh_zo(mat4 proj,
X                         float * __restrict left,
X                         float * __restrict right) {
X  float nearZ, m20, m00;
X
X  m00 = proj[0][0];
X  m20 = proj[2][0];
X
X  nearZ = proj[3][2] / (proj[3][3]);
X  *left   = nearZ * (m20 - 1.0f) / m00;
X  *right  = nearZ * (m20 + 1.0f) / m00;
X}
X
X/*!
X * @brief decomposes top and bottom values of perspective projection
X *        with angle values with a left-hand coordinate system and a 
X *        clip-space of [0, 1].
X *        y stands for y axis (top / bottom axis)
X *
X * @param[in]  proj   perspective projection matrix
X * @param[out] top    top
X * @param[out] bottom bottom
X */
XCGLM_INLINE
Xvoid
Xglm_persp_decomp_y_lh_zo(mat4 proj,
X                         float * __restrict top,
X                         float * __restrict bottom) {
X  float nearZ, m21, m11;
X
X  m21 = proj[2][1];
X  m11 = proj[1][1];
X
X  nearZ = proj[3][2] / (proj[3][3]);
X  *bottom = nearZ * (m21 - 1) / m11;
X  *top    = nearZ * (m21 + 1) / m11;
X}
X
X/*!
X * @brief decomposes near and far values of perspective projection
X *        with angle values with a left-hand coordinate system and a 
X *        clip-space of [0, 1].
X *        z stands for z axis (near / far axis)
X *
X * @param[in]  proj    perspective projection matrix
X * @param[out] nearZ   near
X * @param[out] farZ    far
X */
XCGLM_INLINE
Xvoid
Xglm_persp_decomp_z_lh_zo(mat4 proj,
X                         float * __restrict nearZ,
X                         float * __restrict farZ) {
X  float m32, m22;
X
X  m32 = proj[3][2];
X  m22 = -proj[2][2];
X
X  *nearZ = m32 / m22;
X  *farZ  = m32 / (m22 + 1.0f);
X}
X
X/*!
X * @brief decomposes far value of perspective projection
X *        with angle values with a left-hand coordinate system and a 
X *        clip-space of [0, 1].
X *
X * @param[in]  proj   perspective projection matrix
X * @param[out] farZ   far
X */
XCGLM_INLINE
Xvoid
Xglm_persp_decomp_far_lh_zo(mat4 proj, float * __restrict farZ) {
X  *farZ = proj[3][2] / (-proj[2][2] + 1.0f);
X}
X
X/*!
X * @brief decomposes near value of perspective projection
X *        with angle values with a left-hand coordinate system and a 
X *        clip-space of [0, 1].
X *
X * @param[in]  proj    perspective projection matrix
X * @param[out] nearZ   near
X */
XCGLM_INLINE
Xvoid
Xglm_persp_decomp_near_lh_zo(mat4 proj, float * __restrict nearZ) {
X  *nearZ = proj[3][2] / -proj[2][2];
X}
X
X/*!
X * @brief returns sizes of near and far planes of perspective projection
X *        with a left-hand coordinate system and a
X *        clip-space of [0, 1].
X *
X * @param[in]  proj perspective projection matrix
X * @param[in]  fovy fovy (see brief)
X * @param[out] dest sizes order: [Wnear, Hnear, Wfar, Hfar]
X */
XCGLM_INLINE
Xvoid
Xglm_persp_sizes_lh_zo(mat4 proj, float fovy, vec4 dest) {
X  float t, a, nearZ, farZ;
X
X  t = 2.0f * tanf(fovy * 0.5f);
X  a = glm_persp_aspect(proj);
X
X  glm_persp_decomp_z_lh_zo(proj, &nearZ, &farZ);
X
X  dest[1]  = t * nearZ;
X  dest[3]  = t * farZ;
X  dest[0]  = a * dest[1];
X  dest[2]  = a * dest[3];
X}
X
X/*!
X * @brief returns field of view angle along the Y-axis (in radians)
X *        with a left-hand coordinate system and a clip-space of [0, 1].
X *
X * if you need to degrees, use glm_deg to convert it or use this:
X * fovy_deg = glm_deg(glm_persp_fovy(projMatrix))
X *
X * @param[in] proj perspective projection matrix
X */
XCGLM_INLINE
Xfloat
Xglm_persp_fovy_lh_zo(mat4 proj) {
X  return glm_persp_fovy(proj);
X}
X
X/*!
X * @brief returns aspect ratio of perspective projection
X *        with a left-hand coordinate system and a clip-space of [0, 1].
X *
X * @param[in] proj perspective projection matrix
X */
XCGLM_INLINE
Xfloat
Xglm_persp_aspect_lh_zo(mat4 proj) {
X  return glm_persp_aspect(proj);
X}
X
X#endif /*cglm_persp_lh_zo_h*/
0cd16a24d919ea7b78e36b49080cf496
echo x - cglm/clipspace/persp_rh_no.h
sed 's/^X//' >cglm/clipspace/persp_rh_no.h << 'bca3affb9f127b50d9cfbe2550e40acb'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Functions:
X   CGLM_INLINE void glm_frustum_rh_no(float left,    float right,
X                                      float bottom,  float top,
X                                      float nearZ, float farZ,
X                                      mat4  dest)
X   CGLM_INLINE void glm_perspective_rh_no(float fovy,
X                                          float aspect,
X                                          float nearZ,
X                                          float farZ,
X                                          mat4  dest)
X   CGLM_INLINE void glm_perspective_default_rh_no(float aspect, mat4 dest)
X   CGLM_INLINE void glm_perspective_resize_rh_no(float aspect, mat4 proj)
X   CGLM_INLINE void glm_persp_move_far_rh_no(mat4 proj,
X                                             float deltaFar)
X   CGLM_INLINE void glm_persp_decomp_rh_no(mat4 proj,
X                                           float * __restrict nearZ,
X                                           float * __restrict farZ,
X                                           float * __restrict top,
X                                           float * __restrict bottom,
X                                           float * __restrict left,
X                                           float * __restrict right)
X  CGLM_INLINE void glm_persp_decompv_rh_no(mat4 proj,
X                                           float dest[6])
X  CGLM_INLINE void glm_persp_decomp_x_rh_no(mat4 proj,
X                                            float * __restrict left,
X                                            float * __restrict right)
X  CGLM_INLINE void glm_persp_decomp_y_rh_no(mat4 proj,
X                                            float * __restrict top,
X                                            float * __restrict bottom)
X  CGLM_INLINE void glm_persp_decomp_z_rh_no(mat4 proj,
X                                            float * __restrict nearZ,
X                                            float * __restrict farZ)
X  CGLM_INLINE void glm_persp_decomp_far_rh_no(mat4 proj, float * __restrict farZ)
X  CGLM_INLINE void glm_persp_decomp_near_rh_no(mat4 proj, float * __restrict nearZ)
X  CGLM_INLINE void glm_persp_sizes_rh_no(mat4 proj, float fovy, vec4 dest)
X */
X
X#ifndef cglm_persp_rh_no_h
X#define cglm_persp_rh_no_h
X
X#include "../common.h"
X#include "persp.h"
X
X/*!
X * @brief set up perspective peprojection matrix
X *        with a right-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * @param[in]  left    viewport.left
X * @param[in]  right   viewport.right
X * @param[in]  bottom  viewport.bottom
X * @param[in]  top     viewport.top
X * @param[in]  nearZ   near clipping plane
X * @param[in]  farZ    far clipping plane
X * @param[out] dest    result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_frustum_rh_no(float left,    float right,
X                  float bottom,  float top,
X                  float nearZ, float farZ,
X                  mat4  dest) {
X  float rl, tb, fn, nv;
X
X  glm_mat4_zero(dest);
X
X  rl = 1.0f / (right  - left);
X  tb = 1.0f / (top    - bottom);
X  fn =-1.0f / (farZ - nearZ);
X  nv = 2.0f * nearZ;
X
X  dest[0][0] = nv * rl;
X  dest[1][1] = nv * tb;
X  dest[2][0] = (right  + left)    * rl;
X  dest[2][1] = (top    + bottom)  * tb;
X  dest[2][2] = (farZ + nearZ) * fn;
X  dest[2][3] =-1.0f;
X  dest[3][2] = farZ * nv * fn;
X}
X
X/*!
X * @brief set up perspective projection matrix
X *        with a right-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * @param[in]  fovy    field of view angle
X * @param[in]  aspect  aspect ratio ( width / height )
X * @param[in]  nearZ   near clipping plane
X * @param[in]  farZ    far clipping planes
X * @param[out] dest    result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_perspective_rh_no(float fovy,
X                      float aspect,
X                      float nearZ,
X                      float farZ,
X                      mat4  dest) {
X  float f, fn;
X
X  glm_mat4_zero(dest);
X
X  f  = 1.0f / tanf(fovy * 0.5f);
X  fn = 1.0f / (nearZ - farZ);
X
X  dest[0][0] = f / aspect;
X  dest[1][1] = f;
X  dest[2][2] = (nearZ + farZ) * fn;
X  dest[2][3] =-1.0f;
X  dest[3][2] = 2.0f * nearZ * farZ * fn;
X
X}
X
X/*!
X * @brief set up perspective projection matrix with default near/far
X *        and angle values with a right-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * @param[in]  aspect aspect ratio ( width / height )
X * @param[out] dest   result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_perspective_default_rh_no(float aspect, mat4 dest) {
X  glm_perspective_rh_no(GLM_PI_4f, aspect, 0.01f, 100.0f, dest);
X}
X
X/*!
X * @brief resize perspective matrix by aspect ratio ( width / height )
X *        this makes very easy to resize proj matrix when window /viewport
X *        resized with a right-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * @param[in]      aspect aspect ratio ( width / height )
X * @param[in, out] proj   perspective projection matrix
X */
XCGLM_INLINE
Xvoid
Xglm_perspective_resize_rh_no(float aspect, mat4 proj) {
X  if (proj[0][0] == 0.0f)
X    return;
X
X  proj[0][0] = proj[1][1] / aspect;
X}
X
X/*!
X * @brief extend perspective projection matrix's far distance
X *        with a right-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * this function does not guarantee far >= near, be aware of that!
X *
X * @param[in, out] proj      projection matrix to extend
X * @param[in]      deltaFar  distance from existing far (negative to shink)
X */
XCGLM_INLINE
Xvoid
Xglm_persp_move_far_rh_no(mat4 proj, float deltaFar) {
X  float fn, farZ, nearZ, p22, p32;
X
X  p22        = proj[2][2];
X  p32        = proj[3][2];
X
X  nearZ    = p32 / (p22 - 1.0f);
X  farZ     = p32 / (p22 + 1.0f) + deltaFar;
X  fn         = 1.0f / (nearZ - farZ);
X
X  proj[2][2] = (farZ + nearZ) * fn;
X  proj[3][2] = 2.0f * nearZ * farZ * fn;
X}
X
X/*!
X * @brief decomposes frustum values of perspective projection
X *        with a right-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * @param[in]  proj    perspective projection matrix
X * @param[out] nearZ   near
X * @param[out] farZ    far
X * @param[out] top     top
X * @param[out] bottom  bottom
X * @param[out] left    left
X * @param[out] right   right
X */
XCGLM_INLINE
Xvoid
Xglm_persp_decomp_rh_no(mat4 proj,
X                       float * __restrict nearZ, float * __restrict farZ,
X                       float * __restrict top,     float * __restrict bottom,
X                       float * __restrict left,    float * __restrict right) {
X  float m00, m11, m20, m21, m22, m32, n, f;
X  float n_m11, n_m00;
X
X  m00 = proj[0][0];
X  m11 = proj[1][1];
X  m20 = proj[2][0];
X  m21 = proj[2][1];
X  m22 = proj[2][2];
X  m32 = proj[3][2];
X
X  n = m32 / (m22 - 1.0f);
X  f = m32 / (m22 + 1.0f);
X
X  n_m11 = n / m11;
X  n_m00 = n / m00;
X
X  *nearZ = n;
X  *farZ  = f;
X  *bottom  = n_m11 * (m21 - 1.0f);
X  *top     = n_m11 * (m21 + 1.0f);
X  *left    = n_m00 * (m20 - 1.0f);
X  *right   = n_m00 * (m20 + 1.0f);
X}
X
X/*!
X * @brief decomposes frustum values of perspective projection
X *        with a right-hand coordinate system and a
X *        clip-space of [-1, 1].
X *        this makes easy to get all values at once
X *
X * @param[in]  proj   perspective projection matrix
X * @param[out] dest   array
X */
XCGLM_INLINE
Xvoid
Xglm_persp_decompv_rh_no(mat4 proj, float dest[6]) {
X  glm_persp_decomp_rh_no(proj, &dest[0], &dest[1], &dest[2],
X                               &dest[3], &dest[4], &dest[5]);
X}
X
X/*!
X * @brief decomposes left and right values of perspective projection
X *        with a right-hand coordinate system and a
X *        clip-space of [-1, 1].
X *        x stands for x axis (left / right axis)
X *
X * @param[in]  proj  perspective projection matrix
X * @param[out] left  left
X * @param[out] right right
X */
XCGLM_INLINE
Xvoid
Xglm_persp_decomp_x_rh_no(mat4 proj,
X                         float * __restrict left,
X                         float * __restrict right) {
X  float nearZ, m20, m00, m22;
X
X  m00 = proj[0][0];
X  m20 = proj[2][0];
X  m22 = proj[2][2];
X
X  nearZ = proj[3][2] / (m22 - 1.0f);
X  *left   = nearZ * (m20 - 1.0f) / m00;
X  *right  = nearZ * (m20 + 1.0f) / m00;
X}
X
X/*!
X * @brief decomposes top and bottom values of perspective projection
X *        with a right-hand coordinate system and a
X *        clip-space of [-1, 1].
X *        y stands for y axis (top / botom axis)
X *
X * @param[in]  proj   perspective projection matrix
X * @param[out] top    top
X * @param[out] bottom bottom
X */
XCGLM_INLINE
Xvoid
Xglm_persp_decomp_y_rh_no(mat4 proj,
X                         float * __restrict top,
X                         float * __restrict bottom) {
X  float nearZ, m21, m11, m22;
X
X  m21 = proj[2][1];
X  m11 = proj[1][1];
X  m22 = proj[2][2];
X
X  nearZ = proj[3][2] / (m22 - 1.0f);
X  *bottom = nearZ * (m21 - 1.0f) / m11;
X  *top    = nearZ * (m21 + 1.0f) / m11;
X}
X
X/*!
X * @brief decomposes near and far values of perspective projection
X *        with a right-hand coordinate system and a
X *        clip-space of [-1, 1].
X *        z stands for z axis (near / far axis)
X *
X * @param[in]  proj    perspective projection matrix
X * @param[out] nearZ   near
X * @param[out] farZ    far
X */
XCGLM_INLINE
Xvoid
Xglm_persp_decomp_z_rh_no(mat4 proj,
X                      float * __restrict nearZ,
X                      float * __restrict farZ) {
X  float m32, m22;
X
X  m32 = proj[3][2];
X  m22 = proj[2][2];
X
X  *nearZ = m32 / (m22 - 1.0f);
X  *farZ  = m32 / (m22 + 1.0f);
X}
X
X/*!
X * @brief decomposes far value of perspective projection
X *        with a right-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * @param[in]  proj   perspective projection matrix
X * @param[out] farZ   far
X */
XCGLM_INLINE
Xvoid
Xglm_persp_decomp_far_rh_no(mat4 proj, float * __restrict farZ) {
X  *farZ = proj[3][2] / (proj[2][2] + 1.0f);
X}
X
X/*!
X * @brief decomposes near value of perspective projection
X *        with a right-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * @param[in]  proj    perspective projection matrix
X * @param[out] nearZ near
X */
XCGLM_INLINE
Xvoid
Xglm_persp_decomp_near_rh_no(mat4 proj, float * __restrict nearZ) {
X  *nearZ = proj[3][2] / (proj[2][2] - 1.0f);
X}
X
X/*!
X * @brief returns sizes of near and far planes of perspective projection
X *        with a right-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * @param[in]  proj perspective projection matrix
X * @param[in]  fovy fovy (see brief)
X * @param[out] dest sizes order: [Wnear, Hnear, Wfar, Hfar]
X */
XCGLM_INLINE
Xvoid
Xglm_persp_sizes_rh_no(mat4 proj, float fovy, vec4 dest) {
X  float t, a, nearZ, farZ;
X
X  t = 2.0f * tanf(fovy * 0.5f);
X  a = glm_persp_aspect(proj);
X
X  glm_persp_decomp_z_rh_no(proj, &nearZ, &farZ);
X
X  dest[1]  = t * nearZ;
X  dest[3]  = t * farZ;
X  dest[0]  = a * dest[1];
X  dest[2]  = a * dest[3];
X}
X
X/*!
X * @brief returns field of view angle along the Y-axis (in radians)
X *        with a right-hand coordinate system and a clip-space of [-1, 1].
X *
X * if you need to degrees, use glm_deg to convert it or use this:
X * fovy_deg = glm_deg(glm_persp_fovy(projMatrix))
X *
X * @param[in] proj perspective projection matrix
X */
XCGLM_INLINE
Xfloat
Xglm_persp_fovy_rh_no(mat4 proj) {
X  return glm_persp_fovy(proj);
X}
X
X/*!
X * @brief returns aspect ratio of perspective projection
X *        with a right-hand coordinate system and a clip-space of [-1, 1].
X *
X * @param[in] proj perspective projection matrix
X */
XCGLM_INLINE
Xfloat
Xglm_persp_aspect_rh_no(mat4 proj) {
X  return glm_persp_aspect(proj);
X}
X
X#endif /*cglm_cam_rh_no_h*/
bca3affb9f127b50d9cfbe2550e40acb
echo x - cglm/clipspace/persp_rh_zo.h
sed 's/^X//' >cglm/clipspace/persp_rh_zo.h << 'e7319944cc87c321f51dd652915a7903'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Functions:
X   CGLM_INLINE void glm_frustum_rh_zo(float left,    float right,
X                                      float bottom,  float top,
X                                      float nearZ, float farZ,
X                                      mat4  dest)
X   CGLM_INLINE void glm_perspective_rh_zo(float fovy,
X                                          float aspect,
X                                          float nearZ,
X                                          float farZ,
X                                          mat4  dest)
X   CGLM_INLINE void glm_perspective_default_rh_zo(float aspect, mat4 dest)
X   CGLM_INLINE void glm_perspective_resize_rh_zo(float aspect, mat4 proj)
X   CGLM_INLINE void glm_persp_move_far_rh_zo(mat4 proj,
X                                             float deltaFar)
X   CGLM_INLINE void glm_persp_decomp_rh_zo(mat4 proj,
X                                           float * __restrict nearZ,
X                                           float * __restrict farZ,
X                                           float * __restrict top,
X                                           float * __restrict bottom,
X                                           float * __restrict left,
X                                           float * __restrict right)
X  CGLM_INLINE void glm_persp_decompv_rh_zo(mat4 proj,
X                                           float dest[6])
X  CGLM_INLINE void glm_persp_decomp_x_rh_zo(mat4 proj,
X                                            float * __restrict left,
X                                            float * __restrict right)
X  CGLM_INLINE void glm_persp_decomp_y_rh_zo(mat4 proj,
X                                            float * __restrict top,
X                                            float * __restrict bottom)
X  CGLM_INLINE void glm_persp_decomp_z_rh_zo(mat4 proj,
X                                            float * __restrict nearZ,
X                                            float * __restrict farZ)
X  CGLM_INLINE void glm_persp_decomp_far_rh_zo(mat4 proj, float * __restrict farZ)
X  CGLM_INLINE void glm_persp_decomp_near_rh_zo(mat4 proj, float * __restrict nearZ)
X  CGLM_INLINE void glm_persp_sizes_rh_zo(mat4 proj, float fovy, vec4 dest)
X */
X
X#ifndef cglm_persp_rh_zo_h
X#define cglm_persp_rh_zo_h
X
X#include "../common.h"
X#include "persp.h"
X
X/*!
X * @brief set up perspective peprojection matrix with a right-hand coordinate
X *        system and a clip-space of [0, 1].
X *
X * @param[in]  left    viewport.left
X * @param[in]  right   viewport.right
X * @param[in]  bottom  viewport.bottom
X * @param[in]  top     viewport.top
X * @param[in]  nearZ   near clipping plane
X * @param[in]  farZ    far clipping plane
X * @param[out] dest    result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_frustum_rh_zo(float left,    float right,
X                  float bottom,  float top,
X                  float nearZ, float farZ,
X                  mat4  dest) {
X  float rl, tb, fn, nv;
X
X  glm_mat4_zero(dest);
X
X  rl = 1.0f / (right  - left);
X  tb = 1.0f / (top    - bottom);
X  fn =-1.0f / (farZ - nearZ);
X  nv = 2.0f * nearZ;
X
X  dest[0][0] = nv * rl;
X  dest[1][1] = nv * tb;
X  dest[2][0] = (right  + left)    * rl;
X  dest[2][1] = (top    + bottom)  * tb;
X  dest[2][2] = farZ * fn;
X  dest[2][3] =-1.0f;
X  dest[3][2] = farZ * nearZ * fn;
X}
X
X/*!
X * @brief set up perspective projection matrix with a right-hand coordinate
X *        system and a clip-space of [0, 1].
X *
X * @param[in]  fovy    field of view angle
X * @param[in]  aspect  aspect ratio ( width / height )
X * @param[in]  nearZ near clipping plane
X * @param[in]  farZ  far clipping planes
X * @param[out] dest    result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_perspective_rh_zo(float fovy,
X                      float aspect,
X                      float nearZ,
X                      float farZ,
X                      mat4  dest) {
X  float f, fn;
X
X  glm_mat4_zero(dest);
X
X  f  = 1.0f / tanf(fovy * 0.5f);
X  fn = 1.0f / (nearZ - farZ);
X
X  dest[0][0] = f / aspect;
X  dest[1][1] = f;
X  dest[2][2] = farZ * fn;
X  dest[2][3] =-1.0f;
X  dest[3][2] = nearZ * farZ * fn;
X}
X
X/*!
X * @brief set up perspective projection matrix with default near/far
X *        and angle values with a right-hand coordinate system and a
X *        clip-space of [0, 1].
X *
X * @param[in]  aspect aspect ratio ( width / height )
X * @param[out] dest   result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_perspective_default_rh_zo(float aspect, mat4 dest) {
X  glm_perspective_rh_zo(GLM_PI_4f, aspect, 0.01f, 100.0f, dest);
X}
X
X/*!
X * @brief resize perspective matrix by aspect ratio ( width / height )
X *        this makes very easy to resize proj matrix when window /viewport
X *        resized with a right-hand coordinate system and a clip-space of
X *        [0, 1].
X *
X * @param[in]      aspect aspect ratio ( width / height )
X * @param[in, out] proj   perspective projection matrix
X */
XCGLM_INLINE
Xvoid
Xglm_perspective_resize_rh_zo(float aspect, mat4 proj) {
X  if (proj[0][0] == 0.0f)
X    return;
X
X  proj[0][0] = proj[1][1] / aspect;
X}
X
X/*!
X * @brief extend perspective projection matrix's far distance with a
X *        right-hand coordinate system and a clip-space of [0, 1].
X *
X * this function does not guarantee far >= near, be aware of that!
X *
X * @param[in, out] proj      projection matrix to extend
X * @param[in]      deltaFar  distance from existing far (negative to shink)
X */
XCGLM_INLINE
Xvoid
Xglm_persp_move_far_rh_zo(mat4 proj, float deltaFar) {
X  float fn, farZ, nearZ, p22, p32;
X
X  p22        = proj[2][2];
X  p32        = proj[3][2];
X
X  nearZ    = p32 / p22;
X  farZ     = p32 / (p22 + 1.0f) + deltaFar;
X  fn         = 1.0f / (nearZ - farZ);
X
X  proj[2][2] = farZ * fn;
X  proj[3][2] = nearZ * farZ * fn;
X}
X
X/*!
X * @brief decomposes frustum values of perspective projection
X *        with angle values with a right-hand coordinate system and a 
X *        clip-space of [0, 1].
X *
X * @param[in]  proj    perspective projection matrix
X * @param[out] nearZ   near
X * @param[out] farZ    far
X * @param[out] top     top
X * @param[out] bottom  bottom
X * @param[out] left    left
X * @param[out] right   right
X */
XCGLM_INLINE
Xvoid
Xglm_persp_decomp_rh_zo(mat4 proj,
X                    float * __restrict nearZ, float * __restrict farZ,
X                    float * __restrict top,     float * __restrict bottom,
X                    float * __restrict left,    float * __restrict right) {
X  float m00, m11, m20, m21, m22, m32, n, f;
X  float n_m11, n_m00;
X
X  m00 = proj[0][0];
X  m11 = proj[1][1];
X  m20 = proj[2][0];
X  m21 = proj[2][1];
X  m22 = proj[2][2];
X  m32 = proj[3][2];
X
X  n = m32 / m22;
X  f = m32 / (m22 + 1.0f);
X
X  n_m11 = n / m11;
X  n_m00 = n / m00;
X
X  *nearZ = n;
X  *farZ  = f;
X  *bottom  = n_m11 * (m21 - 1.0f);
X  *top     = n_m11 * (m21 + 1.0f);
X  *left    = n_m00 * (m20 - 1.0f);
X  *right   = n_m00 * (m20 + 1.0f);
X}
X
X/*!
X * @brief decomposes frustum values of perspective projection
X *        with angle values with a right-hand coordinate system and a 
X *        clip-space of [0, 1].
X *        this makes easy to get all values at once
X *
X * @param[in]  proj   perspective projection matrix
X * @param[out] dest   array
X */
XCGLM_INLINE
Xvoid
Xglm_persp_decompv_rh_zo(mat4 proj, float dest[6]) {
X  glm_persp_decomp_rh_zo(proj, &dest[0], &dest[1], &dest[2],
X                               &dest[3], &dest[4], &dest[5]);
X}
X
X/*!
X * @brief decomposes left and right values of perspective projection (ZO).
X *        x stands for x axis (left / right axis)
X *
X * @param[in]  proj  perspective projection matrix
X * @param[out] left  left
X * @param[out] right right
X */
XCGLM_INLINE
Xvoid
Xglm_persp_decomp_x_rh_zo(mat4 proj,
X                         float * __restrict left,
X                         float * __restrict right) {
X  float nearZ, m20, m00, m22;
X
X  m00 = proj[0][0];
X  m20 = proj[2][0];
X  m22 = proj[2][2];
X
X  nearZ = proj[3][2] / m22;
X  *left   = nearZ * (m20 - 1.0f) / m00;
X  *right  = nearZ * (m20 + 1.0f) / m00;
X}
X
X/*!
X * @brief decomposes top and bottom values of perspective projection
X *        with angle values with a right-hand coordinate system and a 
X *        clip-space of [0, 1].
X *        y stands for y axis (top / bottom axis)
X *
X * @param[in]  proj   perspective projection matrix
X * @param[out] top    top
X * @param[out] bottom bottom
X */
XCGLM_INLINE
Xvoid
Xglm_persp_decomp_y_rh_zo(mat4 proj,
X                         float * __restrict top,
X                         float * __restrict bottom) {
X  float nearZ, m21, m11, m22;
X
X  m21 = proj[2][1];
X  m11 = proj[1][1];
X  m22 = proj[2][2];
X
X  nearZ = proj[3][2] / m22;
X  *bottom = nearZ * (m21 - 1) / m11;
X  *top    = nearZ * (m21 + 1) / m11;
X}
X
X/*!
X * @brief decomposes near and far values of perspective projection
X *        with angle values with a right-hand coordinate system and a 
X *        clip-space of [0, 1].
X *        z stands for z axis (near / far axis)
X *
X * @param[in]  proj    perspective projection matrix
X * @param[out] nearZ   near
X * @param[out] farZ    far
X */
XCGLM_INLINE
Xvoid
Xglm_persp_decomp_z_rh_zo(mat4 proj,
X                         float * __restrict nearZ,
X                         float * __restrict farZ) {
X  float m32, m22;
X
X  m32 = proj[3][2];
X  m22 = proj[2][2];
X
X  *nearZ = m32 / m22;
X  *farZ  = m32 / (m22 + 1.0f);
X}
X
X/*!
X * @brief decomposes far value of perspective projection
X *        with angle values with a right-hand coordinate system and a 
X *        clip-space of [0, 1].
X *
X * @param[in]  proj   perspective projection matrix
X * @param[out] farZ   far
X */
XCGLM_INLINE
Xvoid
Xglm_persp_decomp_far_rh_zo(mat4 proj, float * __restrict farZ) {
X  *farZ = proj[3][2] / (proj[2][2] + 1.0f);
X}
X
X/*!
X * @brief decomposes near value of perspective projection
X *        with angle values with a right-hand coordinate system and a 
X *        clip-space of [0, 1].
X *
X * @param[in]  proj    perspective projection matrix
X * @param[out] nearZ   near
X */
XCGLM_INLINE
Xvoid
Xglm_persp_decomp_near_rh_zo(mat4 proj, float * __restrict nearZ) {
X  *nearZ = proj[3][2] / proj[2][2];
X}
X
X/*!
X * @brief returns sizes of near and far planes of perspective projection
X *        with a right-hand coordinate system and a
X *        clip-space of [0, 1].
X *
X * @param[in]  proj perspective projection matrix
X * @param[in]  fovy fovy (see brief)
X * @param[out] dest sizes order: [Wnear, Hnear, Wfar, Hfar]
X */
XCGLM_INLINE
Xvoid
Xglm_persp_sizes_rh_zo(mat4 proj, float fovy, vec4 dest) {
X  float t, a, nearZ, farZ;
X
X  t = 2.0f * tanf(fovy * 0.5f);
X  a = glm_persp_aspect(proj);
X
X  glm_persp_decomp_z_rh_zo(proj, &nearZ, &farZ);
X
X  dest[1]  = t * nearZ;
X  dest[3]  = t * farZ;
X  dest[0]  = a * dest[1];
X  dest[2]  = a * dest[3];
X}
X
X/*!
X * @brief returns field of view angle along the Y-axis (in radians)
X *        with a right-hand coordinate system and a clip-space of [0, 1].
X *
X * if you need to degrees, use glm_deg to convert it or use this:
X * fovy_deg = glm_deg(glm_persp_fovy(projMatrix))
X *
X * @param[in] proj perspective projection matrix
X */
XCGLM_INLINE
Xfloat
Xglm_persp_fovy_rh_zo(mat4 proj) {
X  return glm_persp_fovy(proj);
X}
X
X/*!
X * @brief returns aspect ratio of perspective projection
X *        with a right-hand coordinate system and a clip-space of [0, 1].
X *
X * @param[in] proj perspective projection matrix
X */
XCGLM_INLINE
Xfloat
Xglm_persp_aspect_rh_zo(mat4 proj) {
X  return glm_persp_aspect(proj);
X}
X
X#endif /*cglm_persp_rh_zo_h*/
e7319944cc87c321f51dd652915a7903
echo x - cglm/clipspace/ortho_lh_no.h
sed 's/^X//' >cglm/clipspace/ortho_lh_no.h << '7cdaa829546778f955e76ff58df23e25'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Functions:
X   CGLM_INLINE void glm_ortho_lh_no(float left,    float right,
X                                    float bottom,  float top,
X                                    float nearZ, float farZ,
X                                    mat4  dest)
X   CGLM_INLINE void glm_ortho_aabb_lh_no(vec3 box[2], mat4 dest)
X   CGLM_INLINE void glm_ortho_aabb_p_lh_no(vec3 box[2],
X                                           float padding,
X                                           mat4 dest)
X   CGLM_INLINE void glm_ortho_aabb_pz_lh_no(vec3 box[2],
X                                            float padding,
X                                            mat4 dest)
X   CGLM_INLINE void glm_ortho_default_lh_no(float aspect,
X                                            mat4 dest)
X   CGLM_INLINE void glm_ortho_default_s_lh_no(float aspect,
X                                              float size,
X                                              mat4 dest)
X */
X
X#ifndef cglm_ortho_lh_no_h
X#define cglm_ortho_lh_no_h
X
X#include "../common.h"
X#include "../plane.h"
X#include "../mat4.h"
X
X/*!
X * @brief set up orthographic projection matrix
X *        with a left-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * @param[in]  left    viewport.left
X * @param[in]  right   viewport.right
X * @param[in]  bottom  viewport.bottom
X * @param[in]  top     viewport.top
X * @param[in]  nearZ   near clipping plane
X * @param[in]  farZ    far clipping plane
X * @param[out] dest    result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_ortho_lh_no(float left,    float right,
X                float bottom,  float top,
X                float nearZ, float farZ,
X                mat4  dest) {
X  float rl, tb, fn;
X
X  glm_mat4_zero(dest);
X
X  rl = 1.0f / (right  - left);
X  tb = 1.0f / (top    - bottom);
X  fn =-1.0f / (farZ - nearZ);
X
X  dest[0][0] = 2.0f * rl;
X  dest[1][1] = 2.0f * tb;
X  dest[2][2] =-2.0f * fn;
X  dest[3][0] =-(right  + left)    * rl;
X  dest[3][1] =-(top    + bottom)  * tb;
X  dest[3][2] = (farZ + nearZ) * fn;
X  dest[3][3] = 1.0f;
X}
X
X/*!
X * @brief set up orthographic projection matrix using bounding box
X *        with a left-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * bounding box (AABB) must be in view space
X *
X * @param[in]  box   AABB
X * @param[out] dest  result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_ortho_aabb_lh_no(vec3 box[2], mat4 dest) {
X  glm_ortho_lh_no(box[0][0],  box[1][0],
X                  box[0][1],  box[1][1],
X                 -box[1][2], -box[0][2],
X                  dest);
X}
X
X/*!
X * @brief set up orthographic projection matrix using bounding box
X *        with a left-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * bounding box (AABB) must be in view space
X *
X * @param[in]  box     AABB
X * @param[in]  padding padding
X * @param[out] dest    result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_ortho_aabb_p_lh_no(vec3 box[2], float padding, mat4 dest) {
X  glm_ortho_lh_no(box[0][0] - padding,    box[1][0] + padding,
X                  box[0][1] - padding,    box[1][1] + padding,
X                -(box[1][2] + padding), -(box[0][2] - padding),
X                  dest);
X}
X
X/*!
X * @brief set up orthographic projection matrix using bounding box
X *        with a left-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * bounding box (AABB) must be in view space
X *
X * @param[in]  box     AABB
X * @param[in]  padding padding for near and far
X * @param[out] dest    result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_ortho_aabb_pz_lh_no(vec3 box[2], float padding, mat4 dest) {
X  glm_ortho_lh_no(box[0][0],              box[1][0],
X                  box[0][1],              box[1][1],
X                -(box[1][2] + padding), -(box[0][2] - padding),
X                  dest);
X}
X
X/*!
X * @brief set up unit orthographic projection matrix
X *        with a left-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * @param[in]  aspect aspect ration ( width / height )
X * @param[out] dest   result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_ortho_default_lh_no(float aspect, mat4 dest) {
X  if (aspect >= 1.0f) {
X    glm_ortho_lh_no(-aspect, aspect, -1.0f, 1.0f, -100.0f, 100.0f, dest);
X    return;
X  }
X
X  aspect = 1.0f / aspect;
X
X  glm_ortho_lh_no(-1.0f, 1.0f, -aspect, aspect, -100.0f, 100.0f, dest);
X}
X
X/*!
X * @brief set up orthographic projection matrix with given CUBE size
X *        with a left-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * @param[in]  aspect aspect ratio ( width / height )
X * @param[in]  size   cube size
X * @param[out] dest   result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_ortho_default_s_lh_no(float aspect, float size, mat4 dest) {
X  if (aspect >= 1.0f) {
X    glm_ortho_lh_no(-size * aspect,
X                     size * aspect,
X                    -size,
X                     size,
X                    -size - 100.0f,
X                     size + 100.0f,
X                     dest);
X    return;
X  }
X
X  glm_ortho_lh_no(-size,
X                   size,
X                  -size / aspect,
X                   size / aspect,
X                  -size - 100.0f,
X                   size + 100.0f,
X                   dest);
X}
X
X#endif /*cglm_ortho_lh_no_h*/
7cdaa829546778f955e76ff58df23e25
echo x - cglm/clipspace/ortho_lh_zo.h
sed 's/^X//' >cglm/clipspace/ortho_lh_zo.h << '3263de6047fd8e699dfd7fa59085f23b'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Functions:
X   CGLM_INLINE void glm_ortho_lh_zo(float left,    float right,
X                                    float bottom,  float top,
X                                    float nearZ, float farZ,
X                                    mat4  dest)
X   CGLM_INLINE void glm_ortho_aabb_lh_zo(vec3 box[2], mat4 dest)
X   CGLM_INLINE void glm_ortho_aabb_p_lh_zo(vec3 box[2],
X                                           float padding,
X                                           mat4 dest)
X   CGLM_INLINE void glm_ortho_aabb_pz_lh_zo(vec3 box[2],
X                                            float padding,
X                                            mat4 dest)
X   CGLM_INLINE void glm_ortho_default_lh_zo(float aspect,
X                                            mat4 dest)
X   CGLM_INLINE void glm_ortho_default_s_lh_zo(float aspect,
X                                              float size,
X                                              mat4 dest)
X */
X
X#ifndef cglm_ortho_lh_zo_h
X#define cglm_ortho_lh_zo_h
X
X#include "../common.h"
X#include "../plane.h"
X#include "../mat4.h"
X
X/*!
X * @brief set up orthographic projection matrix with a left-hand coordinate
X *        system and a clip-space of [0, 1].
X *
X * @param[in]  left    viewport.left
X * @param[in]  right   viewport.right
X * @param[in]  bottom  viewport.bottom
X * @param[in]  top     viewport.top
X * @param[in]  nearZ   near clipping plane
X * @param[in]  farZ    far clipping plane
X * @param[out] dest    result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_ortho_lh_zo(float left,    float right,
X                float bottom,  float top,
X                float nearZ, float farZ,
X                mat4  dest) {
X  float rl, tb, fn;
X
X  glm_mat4_zero(dest);
X
X  rl = 1.0f / (right  - left);
X  tb = 1.0f / (top    - bottom);
X  fn =-1.0f / (farZ - nearZ);
X
X  dest[0][0] = 2.0f * rl;
X  dest[1][1] = 2.0f * tb;
X  dest[2][2] =-fn;
X  dest[3][0] =-(right  + left)    * rl;
X  dest[3][1] =-(top    + bottom)  * tb;
X  dest[3][2] = nearZ * fn;
X  dest[3][3] = 1.0f;
X}
X
X/*!
X * @brief set up orthographic projection matrix using bounding box
X *        with a left-hand coordinate system and a clip-space of [0, 1].
X *
X * bounding box (AABB) must be in view space
X *
X * @param[in]  box   AABB
X * @param[out] dest  result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_ortho_aabb_lh_zo(vec3 box[2], mat4 dest) {
X  glm_ortho_lh_zo(box[0][0],  box[1][0],
X                  box[0][1],  box[1][1],
X                 -box[1][2], -box[0][2],
X                  dest);
X}
X
X/*!
X * @brief set up orthographic projection matrix using bounding box
X *        with a left-hand coordinate system and a clip-space of [0, 1].
X *
X * bounding box (AABB) must be in view space
X *
X * @param[in]  box     AABB
X * @param[in]  padding padding
X * @param[out] dest    result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_ortho_aabb_p_lh_zo(vec3 box[2], float padding, mat4 dest) {
X  glm_ortho_lh_zo(box[0][0] - padding,    box[1][0] + padding,
X                  box[0][1] - padding,    box[1][1] + padding,
X                -(box[1][2] + padding), -(box[0][2] - padding),
X                  dest);
X}
X
X/*!
X * @brief set up orthographic projection matrix using bounding box
X *        with a left-hand coordinate system and a clip-space of [0, 1].
X *
X * bounding box (AABB) must be in view space
X *
X * @param[in]  box     AABB
X * @param[in]  padding padding for near and far
X * @param[out] dest    result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_ortho_aabb_pz_lh_zo(vec3 box[2], float padding, mat4 dest) {
X  glm_ortho_lh_zo(box[0][0],              box[1][0],
X                  box[0][1],              box[1][1],
X                -(box[1][2] + padding), -(box[0][2] - padding),
X                  dest);
X}
X
X/*!
X * @brief set up unit orthographic projection matrix
X *        with a left-hand coordinate system and a clip-space of [0, 1].
X *
X * @param[in]  aspect aspect ration ( width / height )
X * @param[out] dest   result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_ortho_default_lh_zo(float aspect, mat4 dest) {
X  if (aspect >= 1.0f) {
X    glm_ortho_lh_zo(-aspect, aspect, -1.0f, 1.0f, -100.0f, 100.0f, dest);
X    return;
X  }
X
X  aspect = 1.0f / aspect;
X
X  glm_ortho_lh_zo(-1.0f, 1.0f, -aspect, aspect, -100.0f, 100.0f, dest);
X}
X
X/*!
X * @brief set up orthographic projection matrix with given CUBE size
X *        with a left-hand coordinate system and a clip-space of [0, 1].
X *
X * @param[in]  aspect aspect ratio ( width / height )
X * @param[in]  size   cube size
X * @param[out] dest   result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_ortho_default_s_lh_zo(float aspect, float size, mat4 dest) {
X  if (aspect >= 1.0f) {
X    glm_ortho_lh_zo(-size * aspect,
X                     size * aspect,
X                    -size,
X                     size,
X                    -size - 100.0f,
X                     size + 100.0f,
X                     dest);
X    return;
X  }
X
X  glm_ortho_lh_zo(-size,
X                   size,
X                  -size / aspect,
X                   size / aspect,
X                  -size - 100.0f,
X                   size + 100.0f,
X                   dest);
X}
X
X#endif /*cglm_ortho_lh_zo_h*/
3263de6047fd8e699dfd7fa59085f23b
echo x - cglm/clipspace/ortho_rh_no.h
sed 's/^X//' >cglm/clipspace/ortho_rh_no.h << '111bfd0738cec9529cc1371c85b285f7'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Functions:
X   CGLM_INLINE void glm_ortho_rh_no(float left,    float right,
X                                    float bottom,  float top,
X                                    float nearZ, float farZ,
X                                    mat4  dest)
X   CGLM_INLINE void glm_ortho_aabb_rh_no(vec3 box[2], mat4 dest)
X   CGLM_INLINE void glm_ortho_aabb_p_rh_no(vec3 box[2],
X                                           float padding,
X                                           mat4 dest)
X   CGLM_INLINE void glm_ortho_aabb_pz_rh_no(vec3 box[2],
X                                            float padding,
X                                            mat4 dest)
X   CGLM_INLINE void glm_ortho_default_rh_no(float aspect,
X                                            mat4 dest)
X   CGLM_INLINE void glm_ortho_default_s_rh_no(float aspect,
X                                              float size,
X                                              mat4 dest)
X */
X
X#ifndef cglm_ortho_rh_no_h
X#define cglm_ortho_rh_no_h
X
X#include "../common.h"
X#include "../plane.h"
X#include "../mat4.h"
X
X/*!
X * @brief set up orthographic projection matrix
X *        with a right-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * @param[in]  left    viewport.left
X * @param[in]  right   viewport.right
X * @param[in]  bottom  viewport.bottom
X * @param[in]  top     viewport.top
X * @param[in]  nearZ   near clipping plane
X * @param[in]  farZ    far clipping plane
X * @param[out] dest    result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_ortho_rh_no(float left,    float right,
X                float bottom,  float top,
X                float nearZ, float farZ,
X                mat4  dest) {
X  float rl, tb, fn;
X
X  glm_mat4_zero(dest);
X
X  rl = 1.0f / (right  - left);
X  tb = 1.0f / (top    - bottom);
X  fn =-1.0f / (farZ - nearZ);
X
X  dest[0][0] = 2.0f * rl;
X  dest[1][1] = 2.0f * tb;
X  dest[2][2] = 2.0f * fn;
X  dest[3][0] =-(right  + left)    * rl;
X  dest[3][1] =-(top    + bottom)  * tb;
X  dest[3][2] = (farZ + nearZ) * fn;
X  dest[3][3] = 1.0f;
X}
X
X/*!
X * @brief set up orthographic projection matrix using bounding box
X *        with a right-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * bounding box (AABB) must be in view space
X *
X * @param[in]  box   AABB
X * @param[out] dest  result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_ortho_aabb_rh_no(vec3 box[2], mat4 dest) {
X  glm_ortho_rh_no(box[0][0],  box[1][0],
X                  box[0][1],  box[1][1],
X                 -box[1][2], -box[0][2],
X                  dest);
X}
X
X/*!
X * @brief set up orthographic projection matrix using bounding box
X *        with a right-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * bounding box (AABB) must be in view space
X *
X * @param[in]  box     AABB
X * @param[in]  padding padding
X * @param[out] dest    result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_ortho_aabb_p_rh_no(vec3 box[2], float padding, mat4 dest) {
X  glm_ortho_rh_no(box[0][0] - padding,    box[1][0] + padding,
X                  box[0][1] - padding,    box[1][1] + padding,
X                -(box[1][2] + padding), -(box[0][2] - padding),
X                  dest);
X}
X
X/*!
X * @brief set up orthographic projection matrix using bounding box
X *        with a right-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * bounding box (AABB) must be in view space
X *
X * @param[in]  box     AABB
X * @param[in]  padding padding for near and far
X * @param[out] dest    result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_ortho_aabb_pz_rh_no(vec3 box[2], float padding, mat4 dest) {
X  glm_ortho_rh_no(box[0][0],              box[1][0],
X                  box[0][1],              box[1][1],
X                -(box[1][2] + padding), -(box[0][2] - padding),
X                  dest);
X}
X
X/*!
X * @brief set up unit orthographic projection matrix
X *        with a right-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * @param[in]  aspect aspect ration ( width / height )
X * @param[out] dest   result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_ortho_default_rh_no(float aspect, mat4 dest) {
X  if (aspect >= 1.0f) {
X    glm_ortho_rh_no(-aspect, aspect, -1.0f, 1.0f, -100.0f, 100.0f, dest);
X    return;
X  }
X
X  aspect = 1.0f / aspect;
X
X  glm_ortho_rh_no(-1.0f, 1.0f, -aspect, aspect, -100.0f, 100.0f, dest);
X}
X
X/*!
X * @brief set up orthographic projection matrix with given CUBE size
X *        with a right-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * @param[in]  aspect aspect ratio ( width / height )
X * @param[in]  size   cube size
X * @param[out] dest   result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_ortho_default_s_rh_no(float aspect, float size, mat4 dest) {
X  if (aspect >= 1.0f) {
X    glm_ortho_rh_no(-size * aspect,
X                     size * aspect,
X                    -size,
X                     size,
X                    -size - 100.0f,
X                     size + 100.0f,
X                     dest);
X    return;
X  }
X
X  glm_ortho_rh_no(-size,
X                   size,
X                  -size / aspect,
X                   size / aspect,
X                  -size - 100.0f,
X                   size + 100.0f,
X                   dest);
X}
X
X#endif /*cglm_ortho_rh_no_h*/
111bfd0738cec9529cc1371c85b285f7
echo x - cglm/clipspace/ortho_rh_zo.h
sed 's/^X//' >cglm/clipspace/ortho_rh_zo.h << '09bf3a373057ffcac4fdaf09e2756751'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Functions:
X   CGLM_INLINE void glm_ortho_rh_zo(float left,    float right,
X                                    float bottom,  float top,
X                                    float nearZ, float farZ,
X                                    mat4  dest)
X   CGLM_INLINE void glm_ortho_aabb_rh_zo(vec3 box[2], mat4 dest)
X   CGLM_INLINE void glm_ortho_aabb_p_rh_zo(vec3 box[2],
X                                           float padding,
X                                           mat4 dest)
X   CGLM_INLINE void glm_ortho_aabb_pz_rh_zo(vec3 box[2],
X                                            float padding,
X                                            mat4 dest)
X   CGLM_INLINE void glm_ortho_default_rh_zo(float aspect,
X                                            mat4 dest)
X   CGLM_INLINE void glm_ortho_default_s_rh_zo(float aspect,
X                                              float size,
X                                              mat4 dest)
X */
X
X#ifndef cglm_ortho_rh_zo_h
X#define cglm_ortho_rh_zo_h
X
X#include "../common.h"
X#include "../plane.h"
X#include "../mat4.h"
X
X/*!
X * @brief set up orthographic projection matrix with a right-hand coordinate
X *        system and a clip-space of [0, 1].
X *
X * @param[in]  left    viewport.left
X * @param[in]  right   viewport.right
X * @param[in]  bottom  viewport.bottom
X * @param[in]  top     viewport.top
X * @param[in]  nearZ   near clipping plane
X * @param[in]  farZ    far clipping plane
X * @param[out] dest    result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_ortho_rh_zo(float left,    float right,
X                float bottom,  float top,
X                float nearZ, float farZ,
X                mat4  dest) {
X  float rl, tb, fn;
X
X  glm_mat4_zero(dest);
X
X  rl = 1.0f / (right  - left);
X  tb = 1.0f / (top    - bottom);
X  fn =-1.0f / (farZ - nearZ);
X
X  dest[0][0] = 2.0f * rl;
X  dest[1][1] = 2.0f * tb;
X  dest[2][2] = fn;
X  dest[3][0] =-(right  + left)    * rl;
X  dest[3][1] =-(top    + bottom)  * tb;
X  dest[3][2] = nearZ * fn;
X  dest[3][3] = 1.0f;
X}
X
X/*!
X * @brief set up orthographic projection matrix using bounding box
X *        with a right-hand coordinate system and a clip-space with depth
X *        values from zero to one.
X *
X * bounding box (AABB) must be in view space
X *
X * @param[in]  box   AABB
X * @param[out] dest  result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_ortho_aabb_rh_zo(vec3 box[2], mat4 dest) {
X  glm_ortho_rh_zo(box[0][0],  box[1][0],
X                  box[0][1],  box[1][1],
X                 -box[1][2], -box[0][2],
X                  dest);
X}
X
X/*!
X * @brief set up orthographic projection matrix using bounding box
X *        with a right-hand coordinate system and a clip-space with depth
X *        values from zero to one.
X *
X * bounding box (AABB) must be in view space
X *
X * @param[in]  box     AABB
X * @param[in]  padding padding
X * @param[out] dest    result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_ortho_aabb_p_rh_zo(vec3 box[2], float padding, mat4 dest) {
X  glm_ortho_rh_zo(box[0][0] - padding,    box[1][0] + padding,
X                  box[0][1] - padding,    box[1][1] + padding,
X                -(box[1][2] + padding), -(box[0][2] - padding),
X                  dest);
X}
X
X/*!
X * @brief set up orthographic projection matrix using bounding box
X *        with a right-hand coordinate system and a clip-space with depth
X *        values from zero to one.
X *
X * bounding box (AABB) must be in view space
X *
X * @param[in]  box     AABB
X * @param[in]  padding padding for near and far
X * @param[out] dest    result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_ortho_aabb_pz_rh_zo(vec3 box[2], float padding, mat4 dest) {
X  glm_ortho_rh_zo(box[0][0],              box[1][0],
X                  box[0][1],              box[1][1],
X                -(box[1][2] + padding), -(box[0][2] - padding),
X                  dest);
X}
X
X/*!
X * @brief set up unit orthographic projection matrix with a right-hand
X *        coordinate system and a clip-space of [0, 1].
X *
X * @param[in]  aspect aspect ration ( width / height )
X * @param[out] dest   result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_ortho_default_rh_zo(float aspect, mat4 dest) {
X  if (aspect >= 1.0f) {
X    glm_ortho_rh_zo(-aspect, aspect, -1.0f, 1.0f, -100.0f, 100.0f, dest);
X    return;
X  }
X
X  aspect = 1.0f / aspect;
X
X  glm_ortho_rh_zo(-1.0f, 1.0f, -aspect, aspect, -100.0f, 100.0f, dest);
X}
X
X/*!
X * @brief set up orthographic projection matrix with given CUBE size
X *        with a right-hand coordinate system and a clip-space with depth
X *        values from zero to one.
X *
X * @param[in]  aspect aspect ratio ( width / height )
X * @param[in]  size   cube size
X * @param[out] dest   result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_ortho_default_s_rh_zo(float aspect, float size, mat4 dest) {
X  if (aspect >= 1.0f) {
X    glm_ortho_rh_zo(-size * aspect,
X                     size * aspect,
X                    -size,
X                     size,
X                    -size - 100.0f,
X                     size + 100.0f,
X                     dest);
X    return;
X  }
X
X  glm_ortho_rh_zo(-size,
X                   size,
X                  -size / aspect,
X                   size / aspect,
X                  -size - 100.0f,
X                   size + 100.0f,
X                   dest);
X}
X
X#endif /*cglm_ortho_rh_zo_h*/
09bf3a373057ffcac4fdaf09e2756751
echo x - cglm/clipspace/view_lh.h
sed 's/^X//' >cglm/clipspace/view_lh.h << '72865ff4e4acf1765c1a0b8e03a61524'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Functions:
X   CGLM_INLINE void glm_lookat_lh(vec3 eye, vec3 center, vec3 up, mat4 dest)
X   CGLM_INLINE void glm_look_lh(vec3 eye, vec3 dir, vec3 up, mat4 dest)
X   CGLM_INLINE void glm_look_anyup_lh(vec3 eye, vec3 dir, mat4 dest)
X */
X
X#ifndef cglm_view_lh_h
X#define cglm_view_lh_h
X
X#include "../common.h"
X#include "../plane.h"
X
X/*!
X * @brief set up view matrix (LH)
X *
X * NOTE: The UP vector must not be parallel to the line of sight from
X *       the eye point to the reference point
X *
X * @param[in]  eye    eye vector
X * @param[in]  center center vector
X * @param[in]  up     up vector
X * @param[out] dest   result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_lookat_lh(vec3 eye, vec3 center, vec3 up, mat4 dest) {
X  CGLM_ALIGN(8) vec3 f, u, s;
X
X  glm_vec3_sub(center, eye, f);
X  glm_vec3_normalize(f);
X
X  glm_vec3_crossn(up, f, s);
X  glm_vec3_cross(f, s, u);
X
X  dest[0][0] = s[0];
X  dest[0][1] = u[0];
X  dest[0][2] = f[0];
X  dest[1][0] = s[1];
X  dest[1][1] = u[1];
X  dest[1][2] = f[1];
X  dest[2][0] = s[2];
X  dest[2][1] = u[2];
X  dest[2][2] = f[2];
X  dest[3][0] =-glm_vec3_dot(s, eye);
X  dest[3][1] =-glm_vec3_dot(u, eye);
X  dest[3][2] =-glm_vec3_dot(f, eye);
X  dest[0][3] = dest[1][3] = dest[2][3] = 0.0f;
X  dest[3][3] = 1.0f;
X}
X
X/*!
X * @brief set up view matrix with left handed coordinate system
X *
X * convenient wrapper for lookat: if you only have direction not target self
X * then this might be useful. Because you need to get target from direction.
X *
X * NOTE: The UP vector must not be parallel to the line of sight from
X *       the eye point to the reference point
X *
X * @param[in]  eye    eye vector
X * @param[in]  dir    direction vector
X * @param[in]  up     up vector
X * @param[out] dest   result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_look_lh(vec3 eye, vec3 dir, vec3 up, mat4 dest) {
X  CGLM_ALIGN(8) vec3 target;
X  glm_vec3_add(eye, dir, target);
X  glm_lookat_lh(eye, target, up, dest);
X}
X
X/*!
X * @brief set up view matrix with left handed coordinate system
X *
X * convenient wrapper for look: if you only have direction and if you don't
X * care what UP vector is then this might be useful to create view matrix
X *
X * @param[in]  eye    eye vector
X * @param[in]  dir    direction vector
X * @param[out] dest   result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_look_anyup_lh(vec3 eye, vec3 dir, mat4 dest) {
X  CGLM_ALIGN(8) vec3 up;
X  glm_vec3_ortho(dir, up);
X  glm_look_lh(eye, dir, up, dest);
X}
X
X#endif /*cglm_view_lh_h*/
72865ff4e4acf1765c1a0b8e03a61524
echo x - cglm/clipspace/view_rh.h
sed 's/^X//' >cglm/clipspace/view_rh.h << '830ec6d0699c00cc95383f7d9859d842'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Functions:
X   CGLM_INLINE void glm_lookat_rh(vec3 eye, vec3 center, vec3 up, mat4 dest)
X   CGLM_INLINE void glm_look_rh(vec3 eye, vec3 dir, vec3 up, mat4 dest)
X   CGLM_INLINE void glm_look_anyup_rh(vec3 eye, vec3 dir, mat4 dest)
X */
X
X#ifndef cglm_view_rh_h
X#define cglm_view_rh_h
X
X#include "../common.h"
X#include "../plane.h"
X
X/*!
X * @brief set up view matrix with right handed coordinate system.
X *
X * NOTE: The UP vector must not be parallel to the line of sight from
X *       the eye point to the reference point
X *
X * @param[in]  eye    eye vector
X * @param[in]  center center vector
X * @param[in]  up     up vector
X * @param[out] dest   result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_lookat_rh(vec3 eye, vec3 center, vec3 up, mat4 dest) {
X  CGLM_ALIGN(8) vec3 f, u, s;
X
X  glm_vec3_sub(center, eye, f);
X  glm_vec3_normalize(f);
X
X  glm_vec3_crossn(f, up, s);
X  glm_vec3_cross(s, f, u);
X
X  dest[0][0] = s[0];
X  dest[0][1] = u[0];
X  dest[0][2] =-f[0];
X  dest[1][0] = s[1];
X  dest[1][1] = u[1];
X  dest[1][2] =-f[1];
X  dest[2][0] = s[2];
X  dest[2][1] = u[2];
X  dest[2][2] =-f[2];
X  dest[3][0] =-glm_vec3_dot(s, eye);
X  dest[3][1] =-glm_vec3_dot(u, eye);
X  dest[3][2] = glm_vec3_dot(f, eye);
X  dest[0][3] = dest[1][3] = dest[2][3] = 0.0f;
X  dest[3][3] = 1.0f;
X}
X
X/*!
X * @brief set up view matrix with right handed coordinate system.
X *
X * convenient wrapper for lookat: if you only have direction not target self
X * then this might be useful. Because you need to get target from direction.
X *
X * NOTE: The UP vector must not be parallel to the line of sight from
X *       the eye point to the reference point
X *
X * @param[in]  eye    eye vector
X * @param[in]  dir    direction vector
X * @param[in]  up     up vector
X * @param[out] dest   result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_look_rh(vec3 eye, vec3 dir, vec3 up, mat4 dest) {
X  CGLM_ALIGN(8) vec3 target;
X  glm_vec3_add(eye, dir, target);
X  glm_lookat_rh(eye, target, up, dest);
X}
X
X/*!
X * @brief set up view matrix with right handed coordinate system.
X *
X * convenient wrapper for look: if you only have direction and if you don't
X * care what UP vector is then this might be useful to create view matrix
X *
X * @param[in]  eye    eye vector
X * @param[in]  dir    direction vector
X * @param[out] dest   result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_look_anyup_rh(vec3 eye, vec3 dir, mat4 dest) {
X  CGLM_ALIGN(8) vec3 up;
X  glm_vec3_ortho(dir, up);
X  glm_look_rh(eye, dir, up, dest);
X}
X
X#endif /*cglm_view_rh_h*/
830ec6d0699c00cc95383f7d9859d842
echo x - cglm/clipspace/view_lh_no.h
sed 's/^X//' >cglm/clipspace/view_lh_no.h << '58f1bfae3f3e9c0fac52dba767d95311'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Functions:
X   CGLM_INLINE void glm_lookat_lh_no(vec3 eye, vec3 center, vec3 up, mat4 dest)
X   CGLM_INLINE void glm_look_lh_no(vec3 eye, vec3 dir, vec3 up, mat4 dest)
X   CGLM_INLINE void glm_look_anyup_lh_no(vec3 eye, vec3 dir, mat4 dest)
X */
X
X#ifndef cglm_view_lh_no_h
X#define cglm_view_lh_no_h
X
X#include "../common.h"
X#include "view_lh.h"
X
X/*!
X * @brief set up view matrix with left handed coordinate system.
X *
X * NOTE: The UP vector must not be parallel to the line of sight from
X *       the eye point to the reference point
X *
X * @param[in]  eye    eye vector
X * @param[in]  center center vector
X * @param[in]  up     up vector
X * @param[out] dest   result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_lookat_lh_no(vec3 eye, vec3 center, vec3 up, mat4 dest) {
X  glm_lookat_lh(eye, center, up, dest);
X}
X
X/*!
X * @brief set up view matrix with left handed coordinate system.
X *
X * convenient wrapper for lookat: if you only have direction not target self
X * then this might be useful. Because you need to get target from direction.
X *
X * NOTE: The UP vector must not be parallel to the line of sight from
X *       the eye point to the reference point
X *
X * @param[in]  eye    eye vector
X * @param[in]  dir    direction vector
X * @param[in]  up     up vector
X * @param[out] dest   result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_look_lh_no(vec3 eye, vec3 dir, vec3 up, mat4 dest) {
X  glm_look_lh(eye, dir, up, dest);
X}
X
X/*!
X * @brief set up view matrix with left handed coordinate system.
X *
X * convenient wrapper for look: if you only have direction and if you don't
X * care what UP vector is then this might be useful to create view matrix
X *
X * @param[in]  eye    eye vector
X * @param[in]  dir    direction vector
X * @param[out] dest   result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_look_anyup_lh_no(vec3 eye, vec3 dir, mat4 dest) {
X  glm_look_anyup_lh(eye, dir, dest);
X}
X
X#endif /*cglm_view_lh_no_h*/
58f1bfae3f3e9c0fac52dba767d95311
echo x - cglm/clipspace/view_lh_zo.h
sed 's/^X//' >cglm/clipspace/view_lh_zo.h << 'aa75b15a6a4b4114743cbbd89ee3cb7a'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Functions:
X   CGLM_INLINE void glm_lookat_lh_zo(vec3 eye, vec3 center, vec3 up, mat4 dest)
X   CGLM_INLINE void glm_look_lh_zo(vec3 eye, vec3 dir, vec3 up, mat4 dest)
X   CGLM_INLINE void glm_look_anyup_lh_zo(vec3 eye, vec3 dir, mat4 dest)
X */
X
X#ifndef cglm_view_lh_zo_h
X#define cglm_view_lh_zo_h
X
X#include "../common.h"
X#include "view_lh.h"
X
X/*!
X * @brief set up view matrix with left handed coordinate system.
X *
X * NOTE: The UP vector must not be parallel to the line of sight from
X *       the eye point to the reference point
X *
X * @param[in]  eye    eye vector
X * @param[in]  center center vector
X * @param[in]  up     up vector
X * @param[out] dest   result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_lookat_lh_zo(vec3 eye, vec3 center, vec3 up, mat4 dest) {
X  glm_lookat_lh(eye, center, up, dest);
X}
X
X/*!
X * @brief set up view matrix with left handed coordinate system.
X *
X * convenient wrapper for lookat: if you only have direction not target self
X * then this might be useful. Because you need to get target from direction.
X *
X * NOTE: The UP vector must not be parallel to the line of sight from
X *       the eye point to the reference point
X *
X * @param[in]  eye    eye vector
X * @param[in]  dir    direction vector
X * @param[in]  up     up vector
X * @param[out] dest   result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_look_lh_zo(vec3 eye, vec3 dir, vec3 up, mat4 dest) {
X  glm_look_lh(eye, dir, up, dest);
X}
X
X/*!
X * @brief set up view matrix with left handed coordinate system.
X *
X * convenient wrapper for look: if you only have direction and if you don't
X * care what UP vector is then this might be useful to create view matrix
X *
X * @param[in]  eye    eye vector
X * @param[in]  dir    direction vector
X * @param[out] dest   result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_look_anyup_lh_zo(vec3 eye, vec3 dir, mat4 dest) {
X  glm_look_anyup_lh(eye, dir, dest);
X}
X
X#endif /*cglm_view_lh_zo_h*/
aa75b15a6a4b4114743cbbd89ee3cb7a
echo x - cglm/clipspace/view_rh_no.h
sed 's/^X//' >cglm/clipspace/view_rh_no.h << 'efedbf0cf3201d5f23d8b2459ed6319c'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Functions:
X   CGLM_INLINE void glm_lookat_rh_no(vec3 eye, vec3 center, vec3 up, mat4 dest)
X   CGLM_INLINE void glm_look_rh_no(vec3 eye, vec3 dir, vec3 up, mat4 dest)
X   CGLM_INLINE void glm_look_anyup_rh_no(vec3 eye, vec3 dir, mat4 dest)
X */
X
X#ifndef cglm_view_rh_no_h
X#define cglm_view_rh_no_h
X
X#include "../common.h"
X#include "view_rh.h"
X
X/*!
X * @brief set up view matrix with right handed coordinate system.
X *
X * NOTE: The UP vector must not be parallel to the line of sight from
X *       the eye point to the reference point
X *
X * @param[in]  eye    eye vector
X * @param[in]  center center vector
X * @param[in]  up     up vector
X * @param[out] dest   result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_lookat_rh_no(vec3 eye, vec3 center, vec3 up, mat4 dest) {
X  glm_lookat_rh(eye, center, up, dest);
X}
X
X/*!
X * @brief set up view matrix with right handed coordinate system.
X *
X * convenient wrapper for lookat: if you only have direction not target self
X * then this might be useful. Because you need to get target from direction.
X *
X * NOTE: The UP vector must not be parallel to the line of sight from
X *       the eye point to the reference point
X *
X * @param[in]  eye    eye vector
X * @param[in]  dir    direction vector
X * @param[in]  up     up vector
X * @param[out] dest   result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_look_rh_no(vec3 eye, vec3 dir, vec3 up, mat4 dest) {
X  glm_look_rh(eye, dir, up, dest);
X}
X
X/*!
X * @brief set up view matrix with right handed coordinate system.
X *
X * convenient wrapper for look: if you only have direction and if you don't
X * care what UP vector is then this might be useful to create view matrix
X *
X * @param[in]  eye    eye vector
X * @param[in]  dir    direction vector
X * @param[out] dest   result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_look_anyup_rh_no(vec3 eye, vec3 dir, mat4 dest) {
X  glm_look_anyup_rh(eye, dir, dest);
X}
X
X#endif /*cglm_view_rh_no_h*/
efedbf0cf3201d5f23d8b2459ed6319c
echo x - cglm/clipspace/view_rh_zo.h
sed 's/^X//' >cglm/clipspace/view_rh_zo.h << '7f9bed9f1307f05845d6bddcffc4c36c'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Functions:
X   CGLM_INLINE void glm_lookat_rh_zo(vec3 eye, vec3 center, vec3 up, mat4 dest)
X   CGLM_INLINE void glm_look_rh_zo(vec3 eye, vec3 dir, vec3 up, mat4 dest)
X   CGLM_INLINE void glm_look_anyup_rh_zo(vec3 eye, vec3 dir, mat4 dest)
X */
X
X#ifndef cglm_view_rh_zo_h
X#define cglm_view_rh_zo_h
X
X#include "../common.h"
X#include "view_rh.h"
X
X/*!
X * @brief set up view matrix with right handed coordinate system.
X *
X * NOTE: The UP vector must not be parallel to the line of sight from
X *       the eye point to the reference point
X *
X * @param[in]  eye    eye vector
X * @param[in]  center center vector
X * @param[in]  up     up vector
X * @param[out] dest   result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_lookat_rh_zo(vec3 eye, vec3 center, vec3 up, mat4 dest) {
X  glm_lookat_rh(eye, center, up, dest);
X}
X
X/*!
X * @brief set up view matrix with right handed coordinate system.
X *
X * convenient wrapper for lookat: if you only have direction not target self
X * then this might be useful. Because you need to get target from direction.
X *
X * NOTE: The UP vector must not be parallel to the line of sight from
X *       the eye point to the reference point
X *
X * @param[in]  eye    eye vector
X * @param[in]  dir    direction vector
X * @param[in]  up     up vector
X * @param[out] dest   result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_look_rh_zo(vec3 eye, vec3 dir, vec3 up, mat4 dest) {
X  glm_look_rh(eye, dir, up, dest);
X}
X
X/*!
X * @brief set up view matrix with right handed coordinate system.
X *
X * convenient wrapper for look: if you only have direction and if you don't
X * care what UP vector is then this might be useful to create view matrix
X *
X * @param[in]  eye    eye vector
X * @param[in]  dir    direction vector
X * @param[out] dest   result matrix
X */
XCGLM_INLINE
Xvoid
Xglm_look_anyup_rh_zo(vec3 eye, vec3 dir, mat4 dest) {
X  glm_look_anyup_rh(eye, dir, dest);
X}
X
X#endif /*cglm_view_rh_zo_h*/
7f9bed9f1307f05845d6bddcffc4c36c
echo x - cglm/clipspace/project_no.h
sed 's/^X//' >cglm/clipspace/project_no.h << 'c38589a6c76741e9c7a78914278a5719'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_project_no_h
X#define cglm_project_no_h
X
X#include "../common.h"
X#include "../vec3.h"
X#include "../vec4.h"
X#include "../mat4.h"
X
X/*!
X * @brief maps the specified viewport coordinates into specified space [1]
X *        the matrix should contain projection matrix.
X *
X * if you don't have ( and don't want to have ) an inverse matrix then use
X * glm_unproject version. You may use existing inverse of matrix in somewhere
X * else, this is why glm_unprojecti exists to save save inversion cost
X *
X * [1] space:
X *  1- if m = invProj:     View Space
X *  2- if m = invViewProj: World Space
X *  3- if m = invMVP:      Object Space
X *
X * You probably want to map the coordinates into object space
X * so use invMVP as m
X *
X * Computing viewProj:
X *   glm_mat4_mul(proj, view, viewProj);
X *   glm_mat4_mul(viewProj, model, MVP);
X *   glm_mat4_inv(viewProj, invMVP);
X *
X * @param[in]  pos      point/position in viewport coordinates
X * @param[in]  invMat   matrix (see brief)
X * @param[in]  vp       viewport as [x, y, width, height]
X * @param[out] dest     unprojected coordinates
X */
XCGLM_INLINE
Xvoid
Xglm_unprojecti_no(vec3 pos, mat4 invMat, vec4 vp, vec3 dest) {
X  vec4 v;
X
X  v[0] = 2.0f * (pos[0] - vp[0]) / vp[2] - 1.0f;
X  v[1] = 2.0f * (pos[1] - vp[1]) / vp[3] - 1.0f;
X  v[2] = 2.0f *  pos[2]                  - 1.0f;
X  v[3] = 1.0f;
X
X  glm_mat4_mulv(invMat, v, v);
X  glm_vec4_scale(v, 1.0f / v[3], v);
X  glm_vec3(v, dest);
X}
X
X/*!
X * @brief map object coordinates to window coordinates
X *
X * Computing MVP:
X *   glm_mat4_mul(proj, view, viewProj);
X *   glm_mat4_mul(viewProj, model, MVP);
X *
X * @param[in]  pos      object coordinates
X * @param[in]  m        MVP matrix
X * @param[in]  vp       viewport as [x, y, width, height]
X * @param[out] dest     projected coordinates
X */
XCGLM_INLINE
Xvoid
Xglm_project_no(vec3 pos, mat4 m, vec4 vp, vec3 dest) {
X  CGLM_ALIGN(16) vec4 pos4;
X
X  glm_vec4(pos, 1.0f, pos4);
X
X  glm_mat4_mulv(m, pos4, pos4);
X  glm_vec4_scale(pos4, 1.0f / pos4[3], pos4); /* pos = pos / pos.w */
X  glm_vec4_scale(pos4, 0.5f, pos4);
X  glm_vec4_adds(pos4,  0.5f, pos4);
X
X  dest[0] = pos4[0] * vp[2] + vp[0];
X  dest[1] = pos4[1] * vp[3] + vp[1];
X  dest[2] = pos4[2];
X}
X
X/*!
X * @brief map object's z coordinate to window coordinates
X *
X * Computing MVP:
X *   glm_mat4_mul(proj, view, viewProj);
X *   glm_mat4_mul(viewProj, model, MVP);
X *
X * @param[in]  v  object coordinates
X * @param[in]  m  MVP matrix
X *
X * @returns projected z coordinate
X */
XCGLM_INLINE
Xfloat
Xglm_project_z_no(vec3 v, mat4 m) {
X  float z, w;
X
X  z = m[0][2] * v[0] + m[1][2] * v[1] + m[2][2] * v[2] + m[3][2];
X  w = m[0][3] * v[0] + m[1][3] * v[1] + m[2][3] * v[2] + m[3][3];
X
X  return 0.5f * (z / w) + 0.5f;
X}
X
X#endif /* cglm_project_no_h */
c38589a6c76741e9c7a78914278a5719
echo x - cglm/clipspace/project_zo.h
sed 's/^X//' >cglm/clipspace/project_zo.h << '5d2e5d7108a185af956e69c4de61d910'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_project_zo_h
X#define cglm_project_zo_h
X
X#include "../common.h"
X#include "../vec3.h"
X#include "../vec4.h"
X#include "../mat4.h"
X
X/*!
X * @brief maps the specified viewport coordinates into specified space [1]
X *        the matrix should contain projection matrix.
X *
X * if you don't have ( and don't want to have ) an inverse matrix then use
X * glm_unproject version. You may use existing inverse of matrix in somewhere
X * else, this is why glm_unprojecti exists to save save inversion cost
X *
X * [1] space:
X *  1- if m = invProj:     View Space
X *  2- if m = invViewProj: World Space
X *  3- if m = invMVP:      Object Space
X *
X * You probably want to map the coordinates into object space
X * so use invMVP as m
X *
X * Computing viewProj:
X *   glm_mat4_mul(proj, view, viewProj);
X *   glm_mat4_mul(viewProj, model, MVP);
X *   glm_mat4_inv(viewProj, invMVP);
X *
X * @param[in]  pos      point/position in viewport coordinates
X * @param[in]  invMat   matrix (see brief)
X * @param[in]  vp       viewport as [x, y, width, height]
X * @param[out] dest     unprojected coordinates
X */
XCGLM_INLINE
Xvoid
Xglm_unprojecti_zo(vec3 pos, mat4 invMat, vec4 vp, vec3 dest) {
X  vec4 v;
X
X  v[0] = 2.0f * (pos[0] - vp[0]) / vp[2] - 1.0f;
X  v[1] = 2.0f * (pos[1] - vp[1]) / vp[3] - 1.0f;
X  v[2] = pos[2];
X  v[3] = 1.0f;
X
X  glm_mat4_mulv(invMat, v, v);
X  glm_vec4_scale(v, 1.0f / v[3], v);
X  glm_vec3(v, dest);
X}
X
X/*!
X * @brief map object coordinates to window coordinates
X *
X * Computing MVP:
X *   glm_mat4_mul(proj, view, viewProj);
X *   glm_mat4_mul(viewProj, model, MVP);
X *
X * @param[in]  pos      object coordinates
X * @param[in]  m        MVP matrix
X * @param[in]  vp       viewport as [x, y, width, height]
X * @param[out] dest     projected coordinates
X */
XCGLM_INLINE
Xvoid
Xglm_project_zo(vec3 pos, mat4 m, vec4 vp, vec3 dest) {
X  CGLM_ALIGN(16) vec4 pos4;
X
X  glm_vec4(pos, 1.0f, pos4);
X
X  glm_mat4_mulv(m, pos4, pos4);
X  glm_vec4_scale(pos4, 1.0f / pos4[3], pos4); /* pos = pos / pos.w */
X
X  dest[2] = pos4[2];
X  
X  glm_vec4_scale(pos4, 0.5f, pos4);
X  glm_vec4_adds(pos4,  0.5f, pos4);
X
X  dest[0] = pos4[0] * vp[2] + vp[0];
X  dest[1] = pos4[1] * vp[3] + vp[1];
X}
X
X/*!
X * @brief map object's z coordinate to window coordinates
X *
X * Computing MVP:
X *   glm_mat4_mul(proj, view, viewProj);
X *   glm_mat4_mul(viewProj, model, MVP);
X *
X * @param[in]  v  object coordinates
X * @param[in]  m  MVP matrix
X *
X * @returns projected z coordinate
X */
XCGLM_INLINE
Xfloat
Xglm_project_z_zo(vec3 v, mat4 m) {
X  float z, w;
X
X  z = m[0][2] * v[0] + m[1][2] * v[1] + m[2][2] * v[2] + m[3][2];
X  w = m[0][3] * v[0] + m[1][3] * v[1] + m[2][3] * v[2] + m[3][3];
X
X  return z / w;
X}
X
X#endif /* cglm_project_zo_h */
5d2e5d7108a185af956e69c4de61d910
echo c - cglm/simd
mkdir -p cglm/simd > /dev/null 2>&1
echo x - cglm/simd/intrin.h
sed 's/^X//' >cglm/simd/intrin.h << '40fd14d33e21c45b7c87a6e1657f80d8'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_intrin_h
X#define cglm_intrin_h
X
X#if defined( _MSC_VER )
X#  if (defined(_M_AMD64) || defined(_M_X64)) || _M_IX86_FP == 2
X#    ifndef __SSE2__
X#      define __SSE2__
X#    endif
X#  elif _M_IX86_FP == 1
X#    ifndef __SSE__
X#      define __SSE__
X#    endif
X#endif
X/* do not use alignment for older visual studio versions */
X#  if _MSC_VER < 1913     /* Visual Studio 2017 version 15.6 */
X#    define CGLM_ALL_UNALIGNED
X#  endif
X#endif
X
X#if defined( __SSE__ ) || defined( __SSE2__ )
X#  include <xmmintrin.h>
X#  include <emmintrin.h>
X#  define CGLM_SSE_FP 1
X#  ifndef CGLM_SIMD_x86
X#    define CGLM_SIMD_x86
X#  endif
X#endif
X
X#if defined(__SSE3__)
X#  include <pmmintrin.h>
X#  ifndef CGLM_SIMD_x86
X#    define CGLM_SIMD_x86
X#  endif
X#endif
X
X#if defined(__SSE4_1__)
X#  include <smmintrin.h>
X#  ifndef CGLM_SIMD_x86
X#    define CGLM_SIMD_x86
X#  endif
X#endif
X
X#if defined(__SSE4_2__)
X#  include <nmmintrin.h>
X#  ifndef CGLM_SIMD_x86
X#    define CGLM_SIMD_x86
X#  endif
X#endif
X
X#ifdef __AVX__
X#  include <immintrin.h>
X#  define CGLM_AVX_FP 1
X#  ifndef CGLM_SIMD_x86
X#    define CGLM_SIMD_x86
X#  endif
X#endif
X
X/* ARM Neon */
X#if defined(_WIN32)
X/* TODO: non-ARM stuff already inported, will this be better option */
X/* #  include <intrin.h> */
X
X#  if defined(_M_ARM64) || defined(_M_HYBRID_X86_ARM64) || defined(_M_ARM64EC)
X#    include <arm64intr.h>
X#    include <arm64_neon.h>
X#    ifndef CGLM_NEON_FP
X#      define CGLM_NEON_FP  1
X#    endif
X#    ifndef CGLM_SIMD_ARM
X#      define CGLM_SIMD_ARM
X#    endif
X#  elif defined(_M_ARM)
X#    include <armintr.h>
X#    include <arm_neon.h>
X#    ifndef CGLM_NEON_FP
X#      define CGLM_NEON_FP 1
X#    endif
X#    ifndef CGLM_SIMD_ARM
X#      define CGLM_SIMD_ARM
X#    endif
X#  endif
X
X#else /* non-windows */
X#  if defined(__ARM_NEON) || defined(__ARM_NEON__)
X#    include <arm_neon.h>
X#    if defined(__ARM_NEON_FP)
X#      define CGLM_NEON_FP 1
X#    endif
X#    ifndef CGLM_SIMD_ARM
X#      define CGLM_SIMD_ARM
X#    endif
X#  endif
X#endif
X
X/* WebAssembly */
X#if defined(__wasm__) && defined(__wasm_simd128__)
X#  ifndef CGLM_SIMD_WASM
X#    define CGLM_SIMD_WASM
X#  endif
X#endif
X
X#if defined(CGLM_SIMD_x86) || defined(CGLM_SIMD_ARM) || defined(CGLM_SIMD_WASM)
X#  ifndef CGLM_SIMD
X#    define CGLM_SIMD
X#  endif
X#endif
X
X#if defined(CGLM_SIMD_x86) && !defined(CGLM_SIMD_WASM)
X#  include "x86.h"
X#endif
X
X#if defined(CGLM_SIMD_ARM)
X#  include "arm.h"
X#endif
X
X#if defined(CGLM_SIMD_WASM)
X#  include "wasm.h"
X#endif
X
X#endif /* cglm_intrin_h */
40fd14d33e21c45b7c87a6e1657f80d8
echo x - cglm/simd/x86.h
sed 's/^X//' >cglm/simd/x86.h << '0731aa310eb55bddd4bf94d69b9b8a4c'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_simd_x86_h
X#define cglm_simd_x86_h
X#include "intrin.h"
X#ifdef CGLM_SIMD_x86
X
X#ifdef CGLM_ALL_UNALIGNED
X#  define glmm_load(p)      _mm_loadu_ps(p)
X#  define glmm_store(p, a)  _mm_storeu_ps(p, a)
X#else
X#  define glmm_load(p)      _mm_load_ps(p)
X#  define glmm_store(p, a)  _mm_store_ps(p, a)
X#endif
X
X#define glmm_set1(x) _mm_set1_ps(x)
X#define glmm_128     __m128
X
X#ifdef CGLM_USE_INT_DOMAIN
X#  define glmm_shuff1(xmm, z, y, x, w)                                        \
X     _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(xmm),                \
X                                        _MM_SHUFFLE(z, y, x, w)))
X#else
X#  define glmm_shuff1(xmm, z, y, x, w)                                        \
X       _mm_shuffle_ps(xmm, xmm, _MM_SHUFFLE(z, y, x, w))
X#endif
X
X#define glmm_splat(x, lane) glmm_shuff1(x, lane, lane, lane, lane)
X
X#define glmm_splat_x(x) glmm_splat(x, 0)
X#define glmm_splat_y(x) glmm_splat(x, 1)
X#define glmm_splat_z(x) glmm_splat(x, 2)
X#define glmm_splat_w(x) glmm_splat(x, 3)
X
X/* glmm_shuff1x() is DEPRECATED!, use glmm_splat() */
X#define glmm_shuff1x(xmm, x) glmm_shuff1(xmm, x, x, x, x)
X
X#define glmm_shuff2(a, b, z0, y0, x0, w0, z1, y1, x1, w1)                     \
X     glmm_shuff1(_mm_shuffle_ps(a, b, _MM_SHUFFLE(z0, y0, x0, w0)),           \
X                 z1, y1, x1, w1)
X
X#ifdef __AVX__
X#  ifdef CGLM_ALL_UNALIGNED
X#    define glmm_load256(p)      _mm256_loadu_ps(p)
X#    define glmm_store256(p, a)  _mm256_storeu_ps(p, a)
X#  else
X#    define glmm_load256(p)      _mm256_load_ps(p)
X#    define glmm_store256(p, a)  _mm256_store_ps(p, a)
X#  endif
X#endif
X
X/* Note that `0x80000000` corresponds to `INT_MIN` for a 32-bit int. */
X#define GLMM_NEGZEROf ((int)0x80000000) /*  0x80000000 ---> -0.0f  */
X
X#define GLMM__SIGNMASKf(X, Y, Z, W)                                           \
X   _mm_castsi128_ps(_mm_set_epi32(X, Y, Z, W))
X  /* _mm_set_ps(X, Y, Z, W); */
X
X#define glmm_float32x4_SIGNMASK_PNPN GLMM__SIGNMASKf(0, GLMM_NEGZEROf, 0, GLMM_NEGZEROf)
X#define glmm_float32x4_SIGNMASK_NPNP GLMM__SIGNMASKf(GLMM_NEGZEROf, 0, GLMM_NEGZEROf, 0)
X#define glmm_float32x4_SIGNMASK_NPPN GLMM__SIGNMASKf(GLMM_NEGZEROf, 0, 0, GLMM_NEGZEROf)
X
X#define glmm_float32x4_SIGNMASK_NEG _mm_castsi128_ps(_mm_set1_epi32(GLMM_NEGZEROf)) /* _mm_set1_ps(-0.0f) */
X#define glmm_float32x8_SIGNMASK_NEG _mm256_castsi256_ps(_mm256_set1_epi32(GLMM_NEGZEROf))
X
Xstatic inline
X__m128
Xglmm_abs(__m128 x) {
X  return _mm_andnot_ps(glmm_float32x4_SIGNMASK_NEG, x);
X}
X
Xstatic inline
X__m128
Xglmm_vhadd(__m128 v) {
X  __m128 x0;
X  x0 = _mm_add_ps(v,  glmm_shuff1(v, 0, 1, 2, 3));
X  x0 = _mm_add_ps(x0, glmm_shuff1(x0, 1, 0, 0, 1));
X  return x0;
X}
X
Xstatic inline
X__m128
Xglmm_vhadds(__m128 v) {
X#if defined(__SSE3__)
X  __m128 shuf, sums;
X  shuf = _mm_movehdup_ps(v);
X  sums = _mm_add_ps(v, shuf);
X  shuf = _mm_movehl_ps(shuf, sums);
X  sums = _mm_add_ss(sums, shuf);
X  return sums;
X#else
X  __m128 shuf, sums;
X  shuf = glmm_shuff1(v, 2, 3, 0, 1);
X  sums = _mm_add_ps(v, shuf);
X  shuf = _mm_movehl_ps(shuf, sums);
X  sums = _mm_add_ss(sums, shuf);
X  return sums;
X#endif
X}
X
Xstatic inline
Xfloat
Xglmm_hadd(__m128 v) {
X  return _mm_cvtss_f32(glmm_vhadds(v));
X}
X
Xstatic inline
X__m128
Xglmm_vhmin(__m128 v) {
X  __m128 x0, x1, x2;
X  x0 = _mm_movehl_ps(v, v);     /* [2, 3, 2, 3] */
X  x1 = _mm_min_ps(x0, v);       /* [0|2, 1|3, 2|2, 3|3] */
X  x2 = glmm_splat(x1, 1);       /* [1|3, 1|3, 1|3, 1|3] */
X  return _mm_min_ss(x1, x2);
X}
X
Xstatic inline
Xfloat
Xglmm_hmin(__m128 v) {
X  return _mm_cvtss_f32(glmm_vhmin(v));
X}
X
Xstatic inline
X__m128
Xglmm_vhmax(__m128 v) {
X  __m128 x0, x1, x2;
X  x0 = _mm_movehl_ps(v, v);     /* [2, 3, 2, 3] */
X  x1 = _mm_max_ps(x0, v);       /* [0|2, 1|3, 2|2, 3|3] */
X  x2 = glmm_splat(x1, 1);       /* [1|3, 1|3, 1|3, 1|3] */
X  return _mm_max_ss(x1, x2);
X}
X
Xstatic inline
Xfloat
Xglmm_hmax(__m128 v) {
X  return _mm_cvtss_f32(glmm_vhmax(v));
X}
X
Xstatic inline
X__m128
Xglmm_vdots(__m128 a, __m128 b) {
X#if (defined(__SSE4_1__) || defined(__SSE4_2__)) && defined(CGLM_SSE4_DOT)
X  return _mm_dp_ps(a, b, 0xFF);
X#elif defined(__SSE3__) && defined(CGLM_SSE3_DOT)
X  __m128 x0, x1;
X  x0 = _mm_mul_ps(a, b);
X  x1 = _mm_hadd_ps(x0, x0);
X  return _mm_hadd_ps(x1, x1);
X#else
X  return glmm_vhadds(_mm_mul_ps(a, b));
X#endif
X}
X
Xstatic inline
X__m128
Xglmm_vdot(__m128 a, __m128 b) {
X#if (defined(__SSE4_1__) || defined(__SSE4_2__)) && defined(CGLM_SSE4_DOT)
X  return _mm_dp_ps(a, b, 0xFF);
X#elif defined(__SSE3__) && defined(CGLM_SSE3_DOT)
X  __m128 x0, x1;
X  x0 = _mm_mul_ps(a, b);
X  x1 = _mm_hadd_ps(x0, x0);
X  return _mm_hadd_ps(x1, x1);
X#else
X  __m128 x0;
X  x0 = _mm_mul_ps(a, b);
X  x0 = _mm_add_ps(x0, glmm_shuff1(x0, 1, 0, 3, 2));
X  return _mm_add_ps(x0, glmm_shuff1(x0, 0, 1, 0, 1));
X#endif
X}
X
Xstatic inline
Xfloat
Xglmm_dot(__m128 a, __m128 b) {
X  return _mm_cvtss_f32(glmm_vdots(a, b));
X}
X
Xstatic inline
Xfloat
Xglmm_norm(__m128 a) {
X  return _mm_cvtss_f32(_mm_sqrt_ss(glmm_vhadds(_mm_mul_ps(a, a))));
X}
X
Xstatic inline
Xfloat
Xglmm_norm2(__m128 a) {
X  return _mm_cvtss_f32(glmm_vhadds(_mm_mul_ps(a, a)));
X}
X
Xstatic inline
Xfloat
Xglmm_norm_one(__m128 a) {
X  return _mm_cvtss_f32(glmm_vhadds(glmm_abs(a)));
X}
X
Xstatic inline
Xfloat
Xglmm_norm_inf(__m128 a) {
X  return _mm_cvtss_f32(glmm_vhmax(glmm_abs(a)));
X}
X
Xstatic inline
X__m128
Xglmm_load3(float v[3]) {
X  __m128i xy;
X  __m128  z;
X
X  xy = _mm_loadl_epi64(CGLM_CASTPTR_ASSUME_ALIGNED(v, const __m128i));
X  z  = _mm_load_ss(&v[2]);
X
X  return _mm_movelh_ps(_mm_castsi128_ps(xy), z);
X}
X
Xstatic inline
Xvoid
Xglmm_store3(float v[3], __m128 vx) {
X  _mm_storel_pi(CGLM_CASTPTR_ASSUME_ALIGNED(v, __m64), vx);
X  _mm_store_ss(&v[2], glmm_shuff1(vx, 2, 2, 2, 2));
X}
X
Xstatic inline
X__m128
Xglmm_div(__m128 a, __m128 b) {
X  return _mm_div_ps(a, b);
X}
X
X/* enable FMA macro for MSVC? */
X#if defined(_MSC_VER) && !defined(__FMA__) && defined(__AVX2__)
X#  define __FMA__ 1
X#endif
X
Xstatic inline
X__m128
Xglmm_fmadd(__m128 a, __m128 b, __m128 c) {
X#ifdef __FMA__
X  return _mm_fmadd_ps(a, b, c);
X#else
X  return _mm_add_ps(c, _mm_mul_ps(a, b));
X#endif
X}
X
Xstatic inline
X__m128
Xglmm_fnmadd(__m128 a, __m128 b, __m128 c) {
X#ifdef __FMA__
X  return _mm_fnmadd_ps(a, b, c);
X#else
X  return _mm_sub_ps(c, _mm_mul_ps(a, b));
X#endif
X}
X
Xstatic inline
X__m128
Xglmm_fmsub(__m128 a, __m128 b, __m128 c) {
X#ifdef __FMA__
X  return _mm_fmsub_ps(a, b, c);
X#else
X  return _mm_sub_ps(_mm_mul_ps(a, b), c);
X#endif
X}
X
Xstatic inline
X__m128
Xglmm_fnmsub(__m128 a, __m128 b, __m128 c) {
X#ifdef __FMA__
X  return _mm_fnmsub_ps(a, b, c);
X#else
X  return _mm_xor_ps(_mm_add_ps(_mm_mul_ps(a, b), c),
X                    glmm_float32x4_SIGNMASK_NEG);
X#endif
X}
X
X#if defined(__AVX__)
Xstatic inline
X__m256
Xglmm256_fmadd(__m256 a, __m256 b, __m256 c) {
X#ifdef __FMA__
X  return _mm256_fmadd_ps(a, b, c);
X#else
X  return _mm256_add_ps(c, _mm256_mul_ps(a, b));
X#endif
X}
X
Xstatic inline
X__m256
Xglmm256_fnmadd(__m256 a, __m256 b, __m256 c) {
X#ifdef __FMA__
X  return _mm256_fnmadd_ps(a, b, c);
X#else
X  return _mm256_sub_ps(c, _mm256_mul_ps(a, b));
X#endif
X}
X
Xstatic inline
X__m256
Xglmm256_fmsub(__m256 a, __m256 b, __m256 c) {
X#ifdef __FMA__
X  return _mm256_fmsub_ps(a, b, c);
X#else
X  return _mm256_sub_ps(_mm256_mul_ps(a, b), c);
X#endif
X}
X
Xstatic inline
X__m256
Xglmm256_fnmsub(__m256 a, __m256 b, __m256 c) {
X#ifdef __FMA__
X  return _mm256_fmsub_ps(a, b, c);
X#else
X  return _mm256_xor_ps(_mm256_sub_ps(_mm256_mul_ps(a, b), c),
X                       glmm_float32x8_SIGNMASK_NEG);
X#endif
X}
X#endif
X
X#endif
X#endif /* cglm_simd_x86_h */
0731aa310eb55bddd4bf94d69b9b8a4c
echo x - cglm/simd/arm.h
sed 's/^X//' >cglm/simd/arm.h << '998e1f14edb7e60145b29668a1b95898'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_simd_arm_h
X#define cglm_simd_arm_h
X#include "intrin.h"
X#ifdef CGLM_SIMD_ARM
X
X#if defined(_M_ARM64) || defined(_M_HYBRID_X86_ARM64) || defined(_M_ARM64EC) || defined(__aarch64__)
X# define CGLM_ARM64 1
X#else
X# define CGLM_ARM64 0
X#endif
X
X#define glmm_load(p)      vld1q_f32(p)
X#define glmm_store(p, a)  vst1q_f32(p, a)
X
X#define glmm_set1(x) vdupq_n_f32(x)
X#define glmm_128     float32x4_t
X
X#define glmm_splat_x(x) vdupq_lane_f32(vget_low_f32(x),  0)
X#define glmm_splat_y(x) vdupq_lane_f32(vget_low_f32(x),  1)
X#define glmm_splat_z(x) vdupq_lane_f32(vget_high_f32(x), 0)
X#define glmm_splat_w(x) vdupq_lane_f32(vget_high_f32(x), 1)
X
X#define glmm_xor(a, b)                                                        \
X  vreinterpretq_f32_s32(veorq_s32(vreinterpretq_s32_f32(a),                   \
X                                  vreinterpretq_s32_f32(b)))
X
X#define glmm_swplane(v) vextq_f32(v, v, 2)
X#define glmm_low(x)     vget_low_f32(x)
X#define glmm_high(x)    vget_high_f32(x)
X
X#define glmm_combine_ll(x, y) vcombine_f32(vget_low_f32(x),  vget_low_f32(y))
X#define glmm_combine_hl(x, y) vcombine_f32(vget_high_f32(x), vget_low_f32(y))
X#define glmm_combine_lh(x, y) vcombine_f32(vget_low_f32(x),  vget_high_f32(y))
X#define glmm_combine_hh(x, y) vcombine_f32(vget_high_f32(x), vget_high_f32(y))
X
X#if defined(_WIN32) && defined(_MSC_VER)
X/* #  define glmm_float32x4_init(x, y, z, w) { .n128_f32 = { x, y, z, w } } */
XCGLM_INLINE
Xfloat32x4_t
Xglmm_float32x4_init(float x, float y, float z, float w) {
X  CGLM_ALIGN(16) float v[4] = {x, y, z, w};
X  return vld1q_f32(v);
X}
X#else
X#  define glmm_float32x4_init(x, y, z, w) { x, y, z, w }
X#endif
X
X#define glmm_float32x4_SIGNMASK_PNPN glmm_float32x4_init( 0.f, -0.f,  0.f, -0.f)
X#define glmm_float32x4_SIGNMASK_NPNP glmm_float32x4_init(-0.f,  0.f, -0.f,  0.f)
X#define glmm_float32x4_SIGNMASK_NPPN glmm_float32x4_init(-0.f,  0.f,  0.f, -0.f)
X
Xstatic inline
Xfloat32x4_t
Xglmm_abs(float32x4_t v) {
X  return vabsq_f32(v);
X}
X
Xstatic inline
Xfloat32x4_t
Xglmm_vhadd(float32x4_t v) {
X  return vaddq_f32(vaddq_f32(glmm_splat_x(v), glmm_splat_y(v)),
X                   vaddq_f32(glmm_splat_z(v), glmm_splat_w(v)));
X  /*
X   this seems slower:
X   v = vaddq_f32(v, vrev64q_f32(v));
X   return vaddq_f32(v, vcombine_f32(vget_high_f32(v), vget_low_f32(v)));
X   */
X}
X
Xstatic inline
Xfloat
Xglmm_hadd(float32x4_t v) {
X#if CGLM_ARM64
X  return vaddvq_f32(v);
X#else
X  v = vaddq_f32(v, vrev64q_f32(v));
X  v = vaddq_f32(v, vcombine_f32(vget_high_f32(v), vget_low_f32(v)));
X  return vgetq_lane_f32(v, 0);
X#endif
X}
X
Xstatic inline
Xfloat
Xglmm_hmin(float32x4_t v) {
X  float32x2_t t;
X  t = vpmin_f32(vget_low_f32(v), vget_high_f32(v));
X  t = vpmin_f32(t, t);
X  return vget_lane_f32(t, 0);
X}
X
Xstatic inline
Xfloat
Xglmm_hmax(float32x4_t v) {
X  float32x2_t t;
X  t = vpmax_f32(vget_low_f32(v), vget_high_f32(v));
X  t = vpmax_f32(t, t);
X  return vget_lane_f32(t, 0);
X}
X
Xstatic inline
Xfloat
Xglmm_dot(float32x4_t a, float32x4_t b) {
X  return glmm_hadd(vmulq_f32(a, b));
X}
X
Xstatic inline
Xfloat
Xglmm_norm(float32x4_t a) {
X  return sqrtf(glmm_dot(a, a));
X}
X
Xstatic inline
Xfloat
Xglmm_norm2(float32x4_t a) {
X  return glmm_dot(a, a);
X}
X
Xstatic inline
Xfloat
Xglmm_norm_one(float32x4_t a) {
X  return glmm_hadd(glmm_abs(a));
X}
X
Xstatic inline
Xfloat
Xglmm_norm_inf(float32x4_t a) {
X  return glmm_hmax(glmm_abs(a));
X}
X
Xstatic inline
Xfloat32x4_t
Xglmm_div(float32x4_t a, float32x4_t b) {
X#if CGLM_ARM64
X  return vdivq_f32(a, b);
X#else
X  /* 2 iterations of Newton-Raphson refinement of reciprocal */
X  float32x4_t r0, r1;
X  r0 = vrecpeq_f32(b);
X  r1 = vrecpsq_f32(r0, b);
X  r0 = vmulq_f32(r1, r0);
X  r1 = vrecpsq_f32(r0, b);
X  r0 = vmulq_f32(r1, r0);
X  return vmulq_f32(a, r0);
X#endif
X}
X
Xstatic inline
Xfloat32x4_t
Xglmm_fmadd(float32x4_t a, float32x4_t b, float32x4_t c) {
X#if CGLM_ARM64
X  return vfmaq_f32(c, a, b); /* why vfmaq_f32 is slower than vmlaq_f32 ??? */
X#else
X  return vmlaq_f32(c, a, b);
X#endif
X}
X
Xstatic inline
Xfloat32x4_t
Xglmm_fnmadd(float32x4_t a, float32x4_t b, float32x4_t c) {
X#if CGLM_ARM64
X  return vfmsq_f32(c, a, b);
X#else
X  return vmlsq_f32(c, a, b);
X#endif
X}
X
Xstatic inline
Xfloat32x4_t
Xglmm_fmsub(float32x4_t a, float32x4_t b, float32x4_t c) {
X  return glmm_fmadd(a, b, vnegq_f32(c));
X}
X
Xstatic inline
Xfloat32x4_t
Xglmm_fnmsub(float32x4_t a, float32x4_t b, float32x4_t c) {
X  return vsubq_f32(vdupq_n_f32(0.0f), glmm_fmadd(a, b, c));
X}
X
X#endif
X#endif /* cglm_simd_arm_h */
998e1f14edb7e60145b29668a1b95898
echo c - cglm/simd/avx
mkdir -p cglm/simd/avx > /dev/null 2>&1
echo x - cglm/simd/avx/mat4.h
sed 's/^X//' >cglm/simd/avx/mat4.h << '38a2bfbfcad1a6f209d7d53eb10fc093'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_mat_simd_avx_h
X#define cglm_mat_simd_avx_h
X#ifdef __AVX__
X
X#include "../../common.h"
X#include "../intrin.h"
X
X#include <immintrin.h>
X
XCGLM_INLINE
Xvoid
Xglm_mat4_scale_avx(mat4 m, float s) {
X  __m256 y0;
X  y0 = _mm256_set1_ps(s);
X  
X  glmm_store256(m[0], _mm256_mul_ps(y0, glmm_load256(m[0])));
X  glmm_store256(m[2], _mm256_mul_ps(y0, glmm_load256(m[2])));
X}
X
XCGLM_INLINE
Xvoid
Xglm_mat4_mul_avx(mat4 m1, mat4 m2, mat4 dest) {
X  /* D = R * L (Column-Major) */
X
X  __m256 y0, y1, y2, y3, y4, y5, y6, y7, y8, y9;
X
X  y0 = glmm_load256(m2[0]); /* h g f e d c b a */
X  y1 = glmm_load256(m2[2]); /* p o n m l k j i */
X
X  y2 = glmm_load256(m1[0]); /* h g f e d c b a */
X  y3 = glmm_load256(m1[2]); /* p o n m l k j i */
X
X  /* 0x03: 0b00000011 */
X  y4 = _mm256_permute2f128_ps(y2, y2, 0x03); /* d c b a h g f e */
X  y5 = _mm256_permute2f128_ps(y3, y3, 0x03); /* l k j i p o n m */
X
X  /* f f f f a a a a */
X  /* h h h h c c c c */
X  /* e e e e b b b b */
X  /* g g g g d d d d */
X  y6 = _mm256_permutevar_ps(y0, _mm256_set_epi32(1, 1, 1, 1, 0, 0, 0, 0));
X  y7 = _mm256_permutevar_ps(y0, _mm256_set_epi32(3, 3, 3, 3, 2, 2, 2, 2));
X  y8 = _mm256_permutevar_ps(y0, _mm256_set_epi32(0, 0, 0, 0, 1, 1, 1, 1));
X  y9 = _mm256_permutevar_ps(y0, _mm256_set_epi32(2, 2, 2, 2, 3, 3, 3, 3));
X
X  glmm_store256(dest[0],
X                _mm256_add_ps(_mm256_add_ps(_mm256_mul_ps(y2, y6),
X                                            _mm256_mul_ps(y3, y7)),
X                              _mm256_add_ps(_mm256_mul_ps(y4, y8),
X                                            _mm256_mul_ps(y5, y9))));
X
X  /* n n n n i i i i */
X  /* p p p p k k k k */
X  /* m m m m j j j j */
X  /* o o o o l l l l */
X  y6 = _mm256_permutevar_ps(y1, _mm256_set_epi32(1, 1, 1, 1, 0, 0, 0, 0));
X  y7 = _mm256_permutevar_ps(y1, _mm256_set_epi32(3, 3, 3, 3, 2, 2, 2, 2));
X  y8 = _mm256_permutevar_ps(y1, _mm256_set_epi32(0, 0, 0, 0, 1, 1, 1, 1));
X  y9 = _mm256_permutevar_ps(y1, _mm256_set_epi32(2, 2, 2, 2, 3, 3, 3, 3));
X
X  glmm_store256(dest[2],
X                _mm256_add_ps(_mm256_add_ps(_mm256_mul_ps(y2, y6),
X                                            _mm256_mul_ps(y3, y7)),
X                              _mm256_add_ps(_mm256_mul_ps(y4, y8),
X                                            _mm256_mul_ps(y5, y9))));
X}
X
X#endif
X#endif /* cglm_mat_simd_avx_h */
38a2bfbfcad1a6f209d7d53eb10fc093
echo x - cglm/simd/avx/affine.h
sed 's/^X//' >cglm/simd/avx/affine.h << '7da77218b193a8015b6d2103962d5cd0'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_affine_mat_avx_h
X#define cglm_affine_mat_avx_h
X#ifdef __AVX__
X
X#include "../../common.h"
X#include "../intrin.h"
X
X#include <immintrin.h>
X
XCGLM_INLINE
Xvoid
Xglm_mul_avx(mat4 m1, mat4 m2, mat4 dest) {
X  /* D = R * L (Column-Major) */
X
X  __m256 y0, y1, y2, y3, y4, y5, y6, y7, y8, y9;
X
X  y0 = glmm_load256(m2[0]); /* h g f e d c b a */
X  y1 = glmm_load256(m2[2]); /* p o n m l k j i */
X
X  y2 = glmm_load256(m1[0]); /* h g f e d c b a */
X  y3 = glmm_load256(m1[2]); /* p o n m l k j i */
X
X  /* 0x03: 0b00000011 */
X  y4 = _mm256_permute2f128_ps(y2, y2, 0x03); /* d c b a h g f e */
X  y5 = _mm256_permute2f128_ps(y3, y3, 0x03); /* l k j i p o n m */
X
X  /* f f f f a a a a */
X  /* h h h h c c c c */
X  /* e e e e b b b b */
X  /* g g g g d d d d */
X  y6 = _mm256_permutevar_ps(y0, _mm256_set_epi32(1, 1, 1, 1, 0, 0, 0, 0));
X  y7 = _mm256_permutevar_ps(y0, _mm256_set_epi32(3, 3, 3, 3, 2, 2, 2, 2));
X  y8 = _mm256_permutevar_ps(y0, _mm256_set_epi32(0, 0, 0, 0, 1, 1, 1, 1));
X  y9 = _mm256_permutevar_ps(y0, _mm256_set_epi32(2, 2, 2, 2, 3, 3, 3, 3));
X
X  glmm_store256(dest[0],
X                _mm256_add_ps(_mm256_add_ps(_mm256_mul_ps(y2, y6),
X                                            _mm256_mul_ps(y3, y7)),
X                              _mm256_add_ps(_mm256_mul_ps(y4, y8),
X                                            _mm256_mul_ps(y5, y9))));
X
X  /* n n n n i i i i */
X  /* p p p p k k k k */
X  /* m m m m j j j j */
X  /* o o o o l l l l */
X  y6 = _mm256_permutevar_ps(y1, _mm256_set_epi32(1, 1, 1, 1, 0, 0, 0, 0));
X  y7 = _mm256_permutevar_ps(y1, _mm256_set_epi32(3, 3, 3, 3, 2, 2, 2, 2));
X  y8 = _mm256_permutevar_ps(y1, _mm256_set_epi32(0, 0, 0, 0, 1, 1, 1, 1));
X  y9 = _mm256_permutevar_ps(y1, _mm256_set_epi32(2, 2, 2, 2, 3, 3, 3, 3));
X
X  glmm_store256(dest[2],
X                _mm256_add_ps(_mm256_add_ps(_mm256_mul_ps(y2, y6),
X                                            _mm256_mul_ps(y3, y7)),
X                              _mm256_add_ps(_mm256_mul_ps(y4, y8),
X                                            _mm256_mul_ps(y5, y9))));
X}
X
X#endif
X#endif /* cglm_affine_mat_avx_h */
7da77218b193a8015b6d2103962d5cd0
echo c - cglm/simd/neon
mkdir -p cglm/simd/neon > /dev/null 2>&1
echo x - cglm/simd/neon/affine.h
sed 's/^X//' >cglm/simd/neon/affine.h << '48afec82dede880999a0c391459dc228'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_affine_neon_h
X#define cglm_affine_neon_h
X#if defined(CGLM_NEON_FP)
X
X#include "../../common.h"
X#include "../intrin.h"
X
XCGLM_INLINE
Xvoid
Xglm_mul_neon(mat4 m1, mat4 m2, mat4 dest) {
X  /* D = R * L (Column-Major) */
X
X  glmm_128 l, r0, r1, r2, r3, v0, v1, v2, v3;
X
X  l  = glmm_load(m1[0]);
X  r0 = glmm_load(m2[0]);
X  r1 = glmm_load(m2[1]);
X  r2 = glmm_load(m2[2]);
X  r3 = glmm_load(m2[3]);
X
X  v0 = vmulq_f32(glmm_splat_x(r0), l);
X  v1 = vmulq_f32(glmm_splat_x(r1), l);
X  v2 = vmulq_f32(glmm_splat_x(r2), l);
X  v3 = vmulq_f32(glmm_splat_x(r3), l);
X
X  l  = glmm_load(m1[1]);
X  v0 = glmm_fmadd(glmm_splat_y(r0), l, v0);
X  v1 = glmm_fmadd(glmm_splat_y(r1), l, v1);
X  v2 = glmm_fmadd(glmm_splat_y(r2), l, v2);
X  v3 = glmm_fmadd(glmm_splat_y(r3), l, v3);
X
X  l  = glmm_load(m1[2]);
X  v0 = glmm_fmadd(glmm_splat_z(r0), l, v0);
X  v1 = glmm_fmadd(glmm_splat_z(r1), l, v1);
X  v2 = glmm_fmadd(glmm_splat_z(r2), l, v2);
X  v3 = glmm_fmadd(glmm_splat_z(r3), l, v3);
X
X  v3 = glmm_fmadd(glmm_splat_w(r3), glmm_load(m1[3]), v3);
X
X  glmm_store(dest[0], v0);
X  glmm_store(dest[1], v1);
X  glmm_store(dest[2], v2);
X  glmm_store(dest[3], v3);
X}
X
XCGLM_INLINE
Xvoid
Xglm_mul_rot_neon(mat4 m1, mat4 m2, mat4 dest) {
X  /* D = R * L (Column-Major) */
X
X  glmm_128 l, r0, r1, r2, v0, v1, v2;
X
X  l  = glmm_load(m1[0]);
X  r0 = glmm_load(m2[0]);
X  r1 = glmm_load(m2[1]);
X  r2 = glmm_load(m2[2]);
X
X  v0 = vmulq_f32(glmm_splat_x(r0), l);
X  v1 = vmulq_f32(glmm_splat_x(r1), l);
X  v2 = vmulq_f32(glmm_splat_x(r2), l);
X
X  l  = glmm_load(m1[1]);
X  v0 = glmm_fmadd(glmm_splat_y(r0), l, v0);
X  v1 = glmm_fmadd(glmm_splat_y(r1), l, v1);
X  v2 = glmm_fmadd(glmm_splat_y(r2), l, v2);
X  
X  l  = glmm_load(m1[2]);
X  v0 = glmm_fmadd(glmm_splat_z(r0), l, v0);
X  v1 = glmm_fmadd(glmm_splat_z(r1), l, v1);
X  v2 = glmm_fmadd(glmm_splat_z(r2), l, v2);
X
X  glmm_store(dest[0], v0);
X  glmm_store(dest[1], v1);
X  glmm_store(dest[2], v2);
X  glmm_store(dest[3], glmm_load(m1[3]));
X}
X
XCGLM_INLINE
Xvoid
Xglm_inv_tr_neon(mat4 mat) {
X  float32x4x4_t vmat;
X  glmm_128      r0, r1, r2, x0;
X
X  vmat = vld4q_f32(mat[0]);
X  r0   = vmat.val[0];
X  r1   = vmat.val[1];
X  r2   = vmat.val[2];
X
X  x0 = glmm_fmadd(r0, glmm_splat_w(r0),
X                  glmm_fmadd(r1, glmm_splat_w(r1),
X                             vmulq_f32(r2, glmm_splat_w(r2))));
X  x0 = vnegq_f32(x0);
X
X  glmm_store(mat[0], r0);
X  glmm_store(mat[1], r1);
X  glmm_store(mat[2], r2);
X  glmm_store(mat[3], x0);
X  
X  mat[0][3] = 0.0f;
X  mat[1][3] = 0.0f;
X  mat[2][3] = 0.0f;
X  mat[3][3] = 1.0f;
X
X  /* TODO: ?
X  zo   = vget_high_f32(r3);
X  vst1_lane_f32(&mat[0][3], zo, 0);
X  vst1_lane_f32(&mat[1][3], zo, 0);
X  vst1_lane_f32(&mat[2][3], zo, 0);
X  vst1_lane_f32(&mat[3][3], zo, 1);
X  */
X}
X
X#endif
X#endif /* cglm_affine_neon_h */
48afec82dede880999a0c391459dc228
echo x - cglm/simd/neon/mat2.h
sed 's/^X//' >cglm/simd/neon/mat2.h << '98a50bd19b8bbaa36df55d52d1adf8d3'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_mat2_neon_h
X#define cglm_mat2_neon_h
X#if defined(CGLM_NEON_FP)
X
X#include "../../common.h"
X#include "../intrin.h"
X
XCGLM_INLINE
Xvoid
Xglm_mat2_mul_neon(mat2 m1, mat2 m2, mat2 dest) {
X  float32x4x2_t a1;
X  glmm_128 x0,  x1, x2;
X  float32x2_t   dc, ba;
X
X  x1 = glmm_load(m1[0]); /* d c b a */
X  x2 = glmm_load(m2[0]); /* h g f e */
X  
X  dc = vget_high_f32(x1);
X  ba = vget_low_f32(x1);
X
X  /* g g e e, h h f f */
X  a1 = vtrnq_f32(x2, x2);
X  
X  /*
X   dest[0][0] = a * e + c * f;
X   dest[0][1] = b * e + d * f;
X   dest[1][0] = a * g + c * h;
X   dest[1][1] = b * g + d * h;
X   */
X  x0 = glmm_fmadd(vcombine_f32(ba, ba), a1.val[0],
X                  vmulq_f32(vcombine_f32(dc, dc), a1.val[1]));
X
X  glmm_store(dest[0], x0);
X}
X
X#endif
X#endif /* cglm_mat2_neon_h */
98a50bd19b8bbaa36df55d52d1adf8d3
echo x - cglm/simd/neon/mat4.h
sed 's/^X//' >cglm/simd/neon/mat4.h << '381ead76b0d2f10d8931ac7bfce21352'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_mat4_neon_h
X#define cglm_mat4_neon_h
X#if defined(CGLM_NEON_FP)
X
X#include "../../common.h"
X#include "../intrin.h"
X
XCGLM_INLINE
Xvoid
Xglm_mat4_scale_neon(mat4 m, float s) {
X  float32x4_t v0;
X  
X  v0 = vdupq_n_f32(s);
X
X  vst1q_f32(m[0], vmulq_f32(vld1q_f32(m[0]), v0));
X  vst1q_f32(m[1], vmulq_f32(vld1q_f32(m[1]), v0));
X  vst1q_f32(m[2], vmulq_f32(vld1q_f32(m[2]), v0));
X  vst1q_f32(m[3], vmulq_f32(vld1q_f32(m[3]), v0));
X}
X
XCGLM_INLINE
Xvoid
Xglm_mat4_transp_neon(mat4 m, mat4 dest) {
X  float32x4x4_t vmat;
X  
X  vmat = vld4q_f32(m[0]);
X
X  vst1q_f32(dest[0], vmat.val[0]);
X  vst1q_f32(dest[1], vmat.val[1]);
X  vst1q_f32(dest[2], vmat.val[2]);
X  vst1q_f32(dest[3], vmat.val[3]);
X}
X
XCGLM_INLINE
Xvoid
Xglm_mat4_mul_neon(mat4 m1, mat4 m2, mat4 dest) {
X  /* D = R * L (Column-Major) */
X
X  glmm_128 l, r0, r1, r2, r3, v0, v1, v2, v3;
X
X  l  = glmm_load(m1[0]);
X  r0 = glmm_load(m2[0]);
X  r1 = glmm_load(m2[1]);
X  r2 = glmm_load(m2[2]);
X  r3 = glmm_load(m2[3]);
X
X  v0 = vmulq_f32(glmm_splat_x(r0), l);
X  v1 = vmulq_f32(glmm_splat_x(r1), l);
X  v2 = vmulq_f32(glmm_splat_x(r2), l);
X  v3 = vmulq_f32(glmm_splat_x(r3), l);
X
X  l  = glmm_load(m1[1]);
X  v0 = glmm_fmadd(glmm_splat_y(r0), l, v0);
X  v1 = glmm_fmadd(glmm_splat_y(r1), l, v1);
X  v2 = glmm_fmadd(glmm_splat_y(r2), l, v2);
X  v3 = glmm_fmadd(glmm_splat_y(r3), l, v3);
X
X  l  = glmm_load(m1[2]);
X  v0 = glmm_fmadd(glmm_splat_z(r0), l, v0);
X  v1 = glmm_fmadd(glmm_splat_z(r1), l, v1);
X  v2 = glmm_fmadd(glmm_splat_z(r2), l, v2);
X  v3 = glmm_fmadd(glmm_splat_z(r3), l, v3);
X
X  l  = glmm_load(m1[3]);
X  v0 = glmm_fmadd(glmm_splat_w(r0), l, v0);
X  v1 = glmm_fmadd(glmm_splat_w(r1), l, v1);
X  v2 = glmm_fmadd(glmm_splat_w(r2), l, v2);
X  v3 = glmm_fmadd(glmm_splat_w(r3), l, v3);
X
X  glmm_store(dest[0], v0);
X  glmm_store(dest[1], v1);
X  glmm_store(dest[2], v2);
X  glmm_store(dest[3], v3);
X}
X
XCGLM_INLINE
Xvoid
Xglm_mat4_mulv_neon(mat4 m, vec4 v, vec4 dest) {
X  float32x4_t l0, l1, l2, l3;
X  float32x2_t vlo, vhi;
X  
X  l0  = vld1q_f32(m[0]);
X  l1  = vld1q_f32(m[1]);
X  l2  = vld1q_f32(m[2]);
X  l3  = vld1q_f32(m[3]);
X
X  vlo = vld1_f32(&v[0]);
X  vhi = vld1_f32(&v[2]);
X
X  l0  = vmulq_lane_f32(l0, vlo, 0);
X  l0  = vmlaq_lane_f32(l0, l1, vlo, 1);
X  l0  = vmlaq_lane_f32(l0, l2, vhi, 0);
X  l0  = vmlaq_lane_f32(l0, l3, vhi, 1);
X
X  vst1q_f32(dest, l0);
X}
X
XCGLM_INLINE
Xfloat
Xglm_mat4_det_neon(mat4 mat) {
X  float32x4_t   r0, r1, r2, r3, x0, x1, x2;
X  float32x2_t   ij, op, mn, kl, nn, mm, jj, ii, gh, ef, t12, t34;
X  float32x4x2_t a1;
X  float32x4_t   x3 = glmm_float32x4_SIGNMASK_PNPN;
X
X  /* 127 <- 0, [square] det(A) = det(At) */
X  r0 = glmm_load(mat[0]);              /* d c b a */
X  r1 = vrev64q_f32(glmm_load(mat[1])); /* g h e f */
X  r2 = vrev64q_f32(glmm_load(mat[2])); /* l k i j */
X  r3 = vrev64q_f32(glmm_load(mat[3])); /* o p m n */
X
X  gh = vget_high_f32(r1);
X  ef = vget_low_f32(r1);
X  kl = vget_high_f32(r2);
X  ij = vget_low_f32(r2);
X  op = vget_high_f32(r3);
X  mn = vget_low_f32(r3);
X  mm = vdup_lane_f32(mn, 1);
X  nn = vdup_lane_f32(mn, 0);
X  ii = vdup_lane_f32(ij, 1);
X  jj = vdup_lane_f32(ij, 0);
X  
X  /*
X   t[1] = j * p - n * l;
X   t[2] = j * o - n * k;
X   t[3] = i * p - m * l;
X   t[4] = i * o - m * k;
X   */
X  x0 = glmm_fnmadd(vcombine_f32(kl, kl), vcombine_f32(nn, mm),
X                   vmulq_f32(vcombine_f32(op, op), vcombine_f32(jj, ii)));
X
X  t12 = vget_low_f32(x0);
X  t34 = vget_high_f32(x0);
X  
X  /* 1 3 1 3 2 4 2 4 */
X  a1 = vuzpq_f32(x0, x0);
X  
X  /*
X   t[0] = k * p - o * l;
X   t[0] = k * p - o * l;
X   t[5] = i * n - m * j;
X   t[5] = i * n - m * j;
X   */
X  x1 = glmm_fnmadd(vcombine_f32(vdup_lane_f32(kl, 0), jj),
X                   vcombine_f32(vdup_lane_f32(op, 1), mm),
X                   vmulq_f32(vcombine_f32(vdup_lane_f32(op, 0), nn),
X                             vcombine_f32(vdup_lane_f32(kl, 1), ii)));
X
X  /*
X     a * (f * t[0] - g * t[1] + h * t[2])
X   - b * (e * t[0] - g * t[3] + h * t[4])
X   + c * (e * t[1] - f * t[3] + h * t[5])
X   - d * (e * t[2] - f * t[4] + g * t[5])
X   */
X  x2 = glmm_fnmadd(vcombine_f32(vdup_lane_f32(gh, 1), vdup_lane_f32(ef, 0)),
X                   vcombine_f32(vget_low_f32(a1.val[0]), t34),
X                   vmulq_f32(vcombine_f32(ef, vdup_lane_f32(ef, 1)),
X                             vcombine_f32(vget_low_f32(x1), t12)));
X
X  x2 = glmm_fmadd(vcombine_f32(vdup_lane_f32(gh, 0), gh),
X                  vcombine_f32(vget_low_f32(a1.val[1]), vget_high_f32(x1)), x2);
X
X  x2 = glmm_xor(x2, x3);
X
X  return glmm_hadd(vmulq_f32(x2, r0));
X}
X
XCGLM_INLINE
Xvoid
Xglm_mat4_inv_neon(mat4 mat, mat4 dest) {
X  float32x4_t   r0, r1, r2, r3,
X                v0, v1, v2, v3,
X                t0, t1, t2, t3, t4, t5,
X                x0, x1, x2, x3, x4, x5, x6, x7, x8;
X  float32x4x2_t a1;
X  float32x2_t   lp, ko, hg, jn, im, fe, ae, bf, cg, dh;
X  float32x4_t   x9 = glmm_float32x4_SIGNMASK_NPNP;
X
X  x8 = vrev64q_f32(x9);
X
X  /* 127 <- 0 */
X  r0 = glmm_load(mat[0]); /* d c b a */
X  r1 = glmm_load(mat[1]); /* h g f e */
X  r2 = glmm_load(mat[2]); /* l k j i */
X  r3 = glmm_load(mat[3]); /* p o n m */
X  
X  /* l p k o, j n i m */
X  a1  = vzipq_f32(r3, r2);
X  
X  jn  = vget_high_f32(a1.val[0]);
X  im  = vget_low_f32(a1.val[0]);
X  lp  = vget_high_f32(a1.val[1]);
X  ko  = vget_low_f32(a1.val[1]);
X  hg  = vget_high_f32(r1);
X
X  x1  = vcombine_f32(vdup_lane_f32(lp, 0), lp);                   /* l p p p */
X  x2  = vcombine_f32(vdup_lane_f32(ko, 0), ko);                   /* k o o o */
X  x0  = vcombine_f32(vdup_lane_f32(lp, 1), vdup_lane_f32(hg, 1)); /* h h l l */
X  x3  = vcombine_f32(vdup_lane_f32(ko, 1), vdup_lane_f32(hg, 0)); /* g g k k */
X  
X  /* t1[0] = k * p - o * l;
X     t1[0] = k * p - o * l;
X     t2[0] = g * p - o * h;
X     t3[0] = g * l - k * h; */
X  t0 = glmm_fnmadd(x2, x0, vmulq_f32(x3, x1));
X
X  fe = vget_low_f32(r1);
X  x4 = vcombine_f32(vdup_lane_f32(jn, 0), jn);                   /* j n n n */
X  x5 = vcombine_f32(vdup_lane_f32(jn, 1), vdup_lane_f32(fe, 1)); /* f f j j */
X  
X  /* t1[1] = j * p - n * l;
X     t1[1] = j * p - n * l;
X     t2[1] = f * p - n * h;
X     t3[1] = f * l - j * h; */
X   t1 = glmm_fnmadd(x4, x0, vmulq_f32(x5, x1));
X  
X  /* t1[2] = j * o - n * k
X     t1[2] = j * o - n * k;
X     t2[2] = f * o - n * g;
X     t3[2] = f * k - j * g; */
X  t2 = glmm_fnmadd(x4, x3, vmulq_f32(x5, x2));
X  
X  x6 = vcombine_f32(vdup_lane_f32(im, 1), vdup_lane_f32(fe, 0)); /* e e i i */
X  x7 = vcombine_f32(vdup_lane_f32(im, 0), im);                   /* i m m m */
X  
X  /* t1[3] = i * p - m * l;
X     t1[3] = i * p - m * l;
X     t2[3] = e * p - m * h;
X     t3[3] = e * l - i * h; */
X  t3 = glmm_fnmadd(x7, x0, vmulq_f32(x6, x1));
X  
X  /* t1[4] = i * o - m * k;
X     t1[4] = i * o - m * k;
X     t2[4] = e * o - m * g;
X     t3[4] = e * k - i * g; */
X  t4 = glmm_fnmadd(x7, x3, vmulq_f32(x6, x2));
X  
X  /* t1[5] = i * n - m * j;
X     t1[5] = i * n - m * j;
X     t2[5] = e * n - m * f;
X     t3[5] = e * j - i * f; */
X  t5 = glmm_fnmadd(x7, x5, vmulq_f32(x6, x4));
X  
X  /* h d f b, g c e a */
X  a1 = vtrnq_f32(r0, r1);
X  
X  x4 = vrev64q_f32(a1.val[0]); /* c g a e */
X  x5 = vrev64q_f32(a1.val[1]); /* d h b f */
X
X  ae = vget_low_f32(x4);
X  cg = vget_high_f32(x4);
X  bf = vget_low_f32(x5);
X  dh = vget_high_f32(x5);
X  
X  x0 = vcombine_f32(ae, vdup_lane_f32(ae, 1)); /* a a a e */
X  x1 = vcombine_f32(bf, vdup_lane_f32(bf, 1)); /* b b b f */
X  x2 = vcombine_f32(cg, vdup_lane_f32(cg, 1)); /* c c c g */
X  x3 = vcombine_f32(dh, vdup_lane_f32(dh, 1)); /* d d d h */
X  
X  /*
X   dest[0][0] =  f * t1[0] - g * t1[1] + h * t1[2];
X   dest[0][1] =-(b * t1[0] - c * t1[1] + d * t1[2]);
X   dest[0][2] =  b * t2[0] - c * t2[1] + d * t2[2];
X   dest[0][3] =-(b * t3[0] - c * t3[1] + d * t3[2]); */
X  v0 = glmm_xor(glmm_fmadd(x3, t2, glmm_fnmadd(x2, t1, vmulq_f32(x1, t0))), x8);
X  
X  /*
X   dest[2][0] =  e * t1[1] - f * t1[3] + h * t1[5];
X   dest[2][1] =-(a * t1[1] - b * t1[3] + d * t1[5]);
X   dest[2][2] =  a * t2[1] - b * t2[3] + d * t2[5];
X   dest[2][3] =-(a * t3[1] - b * t3[3] + d * t3[5]);*/
X  v2 = glmm_xor(glmm_fmadd(x3, t5, glmm_fnmadd(x1, t3, vmulq_f32(x0, t1))), x8);
X
X  /*
X   dest[1][0] =-(e * t1[0] - g * t1[3] + h * t1[4]);
X   dest[1][1] =  a * t1[0] - c * t1[3] + d * t1[4];
X   dest[1][2] =-(a * t2[0] - c * t2[3] + d * t2[4]);
X   dest[1][3] =  a * t3[0] - c * t3[3] + d * t3[4]; */
X  v1 = glmm_xor(glmm_fmadd(x3, t4, glmm_fnmadd(x2, t3, vmulq_f32(x0, t0))), x9);
X  
X  /*
X   dest[3][0] =-(e * t1[2] - f * t1[4] + g * t1[5]);
X   dest[3][1] =  a * t1[2] - b * t1[4] + c * t1[5];
X   dest[3][2] =-(a * t2[2] - b * t2[4] + c * t2[5]);
X   dest[3][3] =  a * t3[2] - b * t3[4] + c * t3[5]; */
X  v3 = glmm_xor(glmm_fmadd(x2, t5, glmm_fnmadd(x1, t4, vmulq_f32(x0, t2))), x9);
X
X  /* determinant */
X  x0 = vcombine_f32(vget_low_f32(vzipq_f32(v0, v1).val[0]),
X                    vget_low_f32(vzipq_f32(v2, v3).val[0]));
X
X  /*
X  x0 = glmm_div(glmm_set1(1.0f), glmm_vhadd(vmulq_f32(x0, r0)));
X
X  glmm_store(dest[0], vmulq_f32(v0, x0));
X  glmm_store(dest[1], vmulq_f32(v1, x0));
X  glmm_store(dest[2], vmulq_f32(v2, x0));
X  glmm_store(dest[3], vmulq_f32(v3, x0));
X  */
X
X  x0 = glmm_vhadd(vmulq_f32(x0, r0));
X
X  glmm_store(dest[0], glmm_div(v0, x0));
X  glmm_store(dest[1], glmm_div(v1, x0));
X  glmm_store(dest[2], glmm_div(v2, x0));
X  glmm_store(dest[3], glmm_div(v3, x0));
X}
X
X#endif
X#endif /* cglm_mat4_neon_h */
381ead76b0d2f10d8931ac7bfce21352
echo x - cglm/simd/neon/quat.h
sed 's/^X//' >cglm/simd/neon/quat.h << 'eae05297bd3417012daa106a770ba7b9'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_quat_neon_h
X#define cglm_quat_neon_h
X#if defined(CGLM_NEON_FP)
X
X#include "../../common.h"
X#include "../intrin.h"
X
XCGLM_INLINE
Xvoid
Xglm_quat_mul_neon(versor p, versor q, versor dest) {
X  /*
X   + (a1 b2 + b1 a2 + c1 d2  d1 c2)i
X   + (a1 c2  b1 d2 + c1 a2 + d1 b2)j
X   + (a1 d2 + b1 c2  c1 b2 + d1 a2)k
X     a1 a2  b1 b2  c1 c2  d1 d2
X   */
X
X  glmm_128 xp, xq, xqr, r, x, y, z, s2, s3;
X  glmm_128 s1 = glmm_float32x4_SIGNMASK_NPPN;
X
X  float32x2_t   qh, ql;
X  
X  xp  = glmm_load(p); /* 3 2 1 0 */
X  xq  = glmm_load(q);
X
X  r   = vmulq_f32(glmm_splat_w(xp), xq);
X  x   = glmm_splat_x(xp);
X  y   = glmm_splat_y(xp);
X  z   = glmm_splat_z(xp);
X
X  ql  = vget_high_f32(s1);
X  s3  = vcombine_f32(ql, ql);
X  s2  = vzipq_f32(s3, s3).val[0];
X
X  xqr = vrev64q_f32(xq);
X  qh  = vget_high_f32(xqr);
X  ql  = vget_low_f32(xqr);
X
X  r = glmm_fmadd(glmm_xor(x, s3), vcombine_f32(qh, ql), r);
X  
X  r = glmm_fmadd(glmm_xor(y, s2), vcombine_f32(vget_high_f32(xq),
X                                               vget_low_f32(xq)), r);
X  
X  r = glmm_fmadd(glmm_xor(z, s1), vcombine_f32(ql, qh), r);
X
X  glmm_store(dest, r);
X}
X
X#endif
X#endif /* cglm_quat_neon_h */
eae05297bd3417012daa106a770ba7b9
echo c - cglm/simd/sse2
mkdir -p cglm/simd/sse2 > /dev/null 2>&1
echo x - cglm/simd/sse2/affine.h
sed 's/^X//' >cglm/simd/sse2/affine.h << '246a5fd039f1c4dd46c2d8586b8d56dc'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_affine_mat_sse2_h
X#define cglm_affine_mat_sse2_h
X#if defined( __SSE__ ) || defined( __SSE2__ )
X
X#include "../../common.h"
X#include "../intrin.h"
X
XCGLM_INLINE
Xvoid
Xglm_mul_sse2(mat4 m1, mat4 m2, mat4 dest) {
X  /* D = R * L (Column-Major) */
X  glmm_128 l, r0, r1, r2, r3, v0, v1, v2, v3;
X
X  l  = glmm_load(m1[0]);
X  r0 = glmm_load(m2[0]);
X  r1 = glmm_load(m2[1]);
X  r2 = glmm_load(m2[2]);
X  r3 = glmm_load(m2[3]);
X
X  v0 = _mm_mul_ps(glmm_splat_x(r0), l);
X  v1 = _mm_mul_ps(glmm_splat_x(r1), l);
X  v2 = _mm_mul_ps(glmm_splat_x(r2), l);
X  v3 = _mm_mul_ps(glmm_splat_x(r3), l);
X
X  l  = glmm_load(m1[1]);
X  v0 = glmm_fmadd(glmm_splat_y(r0), l, v0);
X  v1 = glmm_fmadd(glmm_splat_y(r1), l, v1);
X  v2 = glmm_fmadd(glmm_splat_y(r2), l, v2);
X  v3 = glmm_fmadd(glmm_splat_y(r3), l, v3);
X
X  l  = glmm_load(m1[2]);
X  v0 = glmm_fmadd(glmm_splat_z(r0), l, v0);
X  v1 = glmm_fmadd(glmm_splat_z(r1), l, v1);
X  v2 = glmm_fmadd(glmm_splat_z(r2), l, v2);
X  v3 = glmm_fmadd(glmm_splat_z(r3), l, v3);
X
X  l  = glmm_load(m1[3]);
X  v3 = glmm_fmadd(glmm_splat_w(r3), l, v3);
X
X  glmm_store(dest[0], v0);
X  glmm_store(dest[1], v1);
X  glmm_store(dest[2], v2);
X  glmm_store(dest[3], v3);
X}
X
XCGLM_INLINE
Xvoid
Xglm_mul_rot_sse2(mat4 m1, mat4 m2, mat4 dest) {
X  /* D = R * L (Column-Major) */
X
X  glmm_128 l, r0, r1, r2, v0, v1, v2;
X
X  l  = glmm_load(m1[0]);
X  r0 = glmm_load(m2[0]);
X  r1 = glmm_load(m2[1]);
X  r2 = glmm_load(m2[2]);
X
X  v0 = _mm_mul_ps(glmm_splat_x(r0), l);
X  v1 = _mm_mul_ps(glmm_splat_x(r1), l);
X  v2 = _mm_mul_ps(glmm_splat_x(r2), l);
X
X  l  = glmm_load(m1[1]);
X  v0 = glmm_fmadd(glmm_splat_y(r0), l, v0);
X  v1 = glmm_fmadd(glmm_splat_y(r1), l, v1);
X  v2 = glmm_fmadd(glmm_splat_y(r2), l, v2);
X
X  l  = glmm_load(m1[2]);
X  v0 = glmm_fmadd(glmm_splat_z(r0), l, v0);
X  v1 = glmm_fmadd(glmm_splat_z(r1), l, v1);
X  v2 = glmm_fmadd(glmm_splat_z(r2), l, v2);
X
X  glmm_store(dest[0], v0);
X  glmm_store(dest[1], v1);
X  glmm_store(dest[2], v2);
X  glmm_store(dest[3], glmm_load(m1[3]));
X}
X
XCGLM_INLINE
Xvoid
Xglm_inv_tr_sse2(mat4 mat) {
X  __m128 r0, r1, r2, r3, x0, x1, x2, x3, x4, x5;
X
X  r0 = glmm_load(mat[0]);
X  r1 = glmm_load(mat[1]);
X  r2 = glmm_load(mat[2]);
X  r3 = glmm_load(mat[3]);
X  x1 = _mm_set_ps(1.0f, 0.0f, 0.0f, 0.0f);
X
X  _MM_TRANSPOSE4_PS(r0, r1, r2, x1);
X
X  x2 = glmm_shuff1(r3, 0, 0, 0, 0);
X  x3 = glmm_shuff1(r3, 1, 1, 1, 1);
X  x4 = glmm_shuff1(r3, 2, 2, 2, 2);
X  x5 = glmm_float32x4_SIGNMASK_NEG;
X
X  x0 = glmm_fmadd(r0, x2, glmm_fmadd(r1, x3, _mm_mul_ps(r2, x4)));
X  x0 = _mm_xor_ps(x0, x5);
X
X  x0 = _mm_add_ps(x0, x1);
X
X  glmm_store(mat[0], r0);
X  glmm_store(mat[1], r1);
X  glmm_store(mat[2], r2);
X  glmm_store(mat[3], x0);
X}
X
X#endif
X#endif /* cglm_affine_mat_sse2_h */
246a5fd039f1c4dd46c2d8586b8d56dc
echo x - cglm/simd/sse2/mat4.h
sed 's/^X//' >cglm/simd/sse2/mat4.h << '07f8b8c5e0aaa590b3f1a37415518ffb'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_mat_sse_h
X#define cglm_mat_sse_h
X#if defined( __SSE__ ) || defined( __SSE2__ )
X
X#include "../../common.h"
X#include "../intrin.h"
X
X#define glm_mat4_inv_precise_sse2(mat, dest) glm_mat4_inv_sse2(mat, dest)
X
XCGLM_INLINE
Xvoid
Xglm_mat4_scale_sse2(mat4 m, float s) {
X  __m128 x0;
X  x0 = _mm_set1_ps(s);
X
X  glmm_store(m[0], _mm_mul_ps(glmm_load(m[0]), x0));
X  glmm_store(m[1], _mm_mul_ps(glmm_load(m[1]), x0));
X  glmm_store(m[2], _mm_mul_ps(glmm_load(m[2]), x0));
X  glmm_store(m[3], _mm_mul_ps(glmm_load(m[3]), x0));
X}
X
XCGLM_INLINE
Xvoid
Xglm_mat4_transp_sse2(mat4 m, mat4 dest) {
X  __m128 r0, r1, r2, r3;
X
X  r0 = glmm_load(m[0]);
X  r1 = glmm_load(m[1]);
X  r2 = glmm_load(m[2]);
X  r3 = glmm_load(m[3]);
X
X  _MM_TRANSPOSE4_PS(r0, r1, r2, r3);
X
X  glmm_store(dest[0], r0);
X  glmm_store(dest[1], r1);
X  glmm_store(dest[2], r2);
X  glmm_store(dest[3], r3);
X}
X
XCGLM_INLINE
Xvoid
Xglm_mat4_mul_sse2(mat4 m1, mat4 m2, mat4 dest) {
X  /* D = R * L (Column-Major) */
X
X  glmm_128 l, r0, r1, r2, r3, v0, v1, v2, v3;
X
X  l  = glmm_load(m1[0]);
X  r0 = glmm_load(m2[0]);
X  r1 = glmm_load(m2[1]);
X  r2 = glmm_load(m2[2]);
X  r3 = glmm_load(m2[3]);
X
X  v0 = _mm_mul_ps(glmm_splat_x(r0), l);
X  v1 = _mm_mul_ps(glmm_splat_x(r1), l);
X  v2 = _mm_mul_ps(glmm_splat_x(r2), l);
X  v3 = _mm_mul_ps(glmm_splat_x(r3), l);
X
X  l  = glmm_load(m1[1]);
X  v0 = glmm_fmadd(glmm_splat_y(r0), l, v0);
X  v1 = glmm_fmadd(glmm_splat_y(r1), l, v1);
X  v2 = glmm_fmadd(glmm_splat_y(r2), l, v2);
X  v3 = glmm_fmadd(glmm_splat_y(r3), l, v3);
X
X  l  = glmm_load(m1[2]);
X  v0 = glmm_fmadd(glmm_splat_z(r0), l, v0);
X  v1 = glmm_fmadd(glmm_splat_z(r1), l, v1);
X  v2 = glmm_fmadd(glmm_splat_z(r2), l, v2);
X  v3 = glmm_fmadd(glmm_splat_z(r3), l, v3);
X
X  l  = glmm_load(m1[3]);
X  v0 = glmm_fmadd(glmm_splat_w(r0), l, v0);
X  v1 = glmm_fmadd(glmm_splat_w(r1), l, v1);
X  v2 = glmm_fmadd(glmm_splat_w(r2), l, v2);
X  v3 = glmm_fmadd(glmm_splat_w(r3), l, v3);
X
X  glmm_store(dest[0], v0);
X  glmm_store(dest[1], v1);
X  glmm_store(dest[2], v2);
X  glmm_store(dest[3], v3);
X}
X
XCGLM_INLINE
Xvoid
Xglm_mat4_mulv_sse2(mat4 m, vec4 v, vec4 dest) {
X  __m128 x0, x1, m0, m1, m2, m3, v0, v1, v2, v3;
X
X  m0 = glmm_load(m[0]);
X  m1 = glmm_load(m[1]);
X  m2 = glmm_load(m[2]);
X  m3 = glmm_load(m[3]);
X
X  x0 = glmm_load(v);
X  v0 = glmm_splat_x(x0);
X  v1 = glmm_splat_y(x0);
X  v2 = glmm_splat_z(x0);
X  v3 = glmm_splat_w(x0);
X
X  x1 = _mm_mul_ps(m3, v3);
X  x1 = glmm_fmadd(m2, v2, x1);
X  x1 = glmm_fmadd(m1, v1, x1);
X  x1 = glmm_fmadd(m0, v0, x1);
X
X  glmm_store(dest, x1);
X}
X
XCGLM_INLINE
Xfloat
Xglm_mat4_det_sse2(mat4 mat) {
X  __m128 r0, r1, r2, r3, x0, x1, x2;
X
X  /* 127 <- 0, [square] det(A) = det(At) */
X  r0 = glmm_load(mat[0]); /* d c b a */
X  r1 = glmm_load(mat[1]); /* h g f e */
X  r2 = glmm_load(mat[2]); /* l k j i */
X  r3 = glmm_load(mat[3]); /* p o n m */
X
X  /*
X   t[1] = j * p - n * l;
X   t[2] = j * o - n * k;
X   t[3] = i * p - m * l;
X   t[4] = i * o - m * k;
X   */
X  x0 = glmm_fnmadd(glmm_shuff1(r3, 0, 0, 1, 1), glmm_shuff1(r2, 2, 3, 2, 3),
X                   _mm_mul_ps(glmm_shuff1(r2, 0, 0, 1, 1),
X                              glmm_shuff1(r3, 2, 3, 2, 3)));
X  /*
X   t[0] = k * p - o * l;
X   t[0] = k * p - o * l;
X   t[5] = i * n - m * j;
X   t[5] = i * n - m * j;
X   */
X  x1 = glmm_fnmadd(glmm_shuff1(r3, 0, 0, 2, 2), glmm_shuff1(r2, 1, 1, 3, 3),
X                   _mm_mul_ps(glmm_shuff1(r2, 0, 0, 2, 2),
X                              glmm_shuff1(r3, 1, 1, 3, 3)));
X
X  /*
X     a * (f * t[0] - g * t[1] + h * t[2])
X   - b * (e * t[0] - g * t[3] + h * t[4])
X   + c * (e * t[1] - f * t[3] + h * t[5])
X   - d * (e * t[2] - f * t[4] + g * t[5])
X   */
X  x2 = glmm_fnmadd(glmm_shuff1(r1, 1, 1, 2, 2), glmm_shuff1(x0, 3, 2, 2, 0),
X                   _mm_mul_ps(glmm_shuff1(r1, 0, 0, 0, 1),
X                              _mm_shuffle_ps(x1, x0, _MM_SHUFFLE(1, 0, 0, 0))));
X  x2 = glmm_fmadd(glmm_shuff1(r1, 2, 3, 3, 3),
X                  _mm_shuffle_ps(x0, x1, _MM_SHUFFLE(2, 2, 3, 1)),
X                  x2);
X  
X  x2 = _mm_xor_ps(x2, glmm_float32x4_SIGNMASK_NPNP);
X  
X  return glmm_hadd(_mm_mul_ps(x2, r0));
X}
X
XCGLM_INLINE
Xvoid
Xglm_mat4_inv_fast_sse2(mat4 mat, mat4 dest) {
X  __m128 r0, r1, r2, r3,
X         v0, v1, v2, v3,
X         t0, t1, t2, t3, t4, t5,
X         x0, x1, x2, x3, x4, x5, x6, x7, x8, x9;
X
X  /* x8 = _mm_set_ps(-0.f, 0.f, -0.f, 0.f); */
X  x8 = glmm_float32x4_SIGNMASK_NPNP;
X  x9 = glmm_shuff1(x8, 2, 1, 2, 1);
X
X  /* 127 <- 0 */
X  r0 = glmm_load(mat[0]); /* d c b a */
X  r1 = glmm_load(mat[1]); /* h g f e */
X  r2 = glmm_load(mat[2]); /* l k j i */
X  r3 = glmm_load(mat[3]); /* p o n m */
X  
X  x0 = _mm_movehl_ps(r3, r2);                            /* p o l k */
X  x3 = _mm_movelh_ps(r2, r3);                            /* n m j i */
X  x1 = glmm_shuff1(x0, 1, 3, 3 ,3);                      /* l p p p */
X  x2 = glmm_shuff1(x0, 0, 2, 2, 2);                      /* k o o o */
X  x4 = glmm_shuff1(x3, 1, 3, 3, 3);                      /* j n n n */
X  x7 = glmm_shuff1(x3, 0, 2, 2, 2);                      /* i m m m */
X
X  x6 = _mm_shuffle_ps(r2, r1, _MM_SHUFFLE(0, 0, 0, 0));  /* e e i i */
X  x5 = _mm_shuffle_ps(r2, r1, _MM_SHUFFLE(1, 1, 1, 1));  /* f f j j */
X  x3 = _mm_shuffle_ps(r2, r1, _MM_SHUFFLE(2, 2, 2, 2));  /* g g k k */
X  x0 = _mm_shuffle_ps(r2, r1, _MM_SHUFFLE(3, 3, 3, 3));  /* h h l l */
X  
X  t0 = _mm_mul_ps(x3, x1);
X  t1 = _mm_mul_ps(x5, x1);
X  t2 = _mm_mul_ps(x5, x2);
X  t3 = _mm_mul_ps(x6, x1);
X  t4 = _mm_mul_ps(x6, x2);
X  t5 = _mm_mul_ps(x6, x4);
X  
X  /* t1[0] = k * p - o * l;
X     t1[0] = k * p - o * l;
X     t2[0] = g * p - o * h;
X     t3[0] = g * l - k * h; */
X  t0 = glmm_fnmadd(x2, x0, t0);
X  
X  /* t1[1] = j * p - n * l;
X     t1[1] = j * p - n * l;
X     t2[1] = f * p - n * h;
X     t3[1] = f * l - j * h; */
X   t1 = glmm_fnmadd(x4, x0, t1);
X  
X  /* t1[2] = j * o - n * k
X     t1[2] = j * o - n * k;
X     t2[2] = f * o - n * g;
X     t3[2] = f * k - j * g; */
X  t2 = glmm_fnmadd(x4, x3, t2);
X  
X  /* t1[3] = i * p - m * l;
X     t1[3] = i * p - m * l;
X     t2[3] = e * p - m * h;
X     t3[3] = e * l - i * h; */
X  t3 = glmm_fnmadd(x7, x0, t3);
X  
X  /* t1[4] = i * o - m * k;
X     t1[4] = i * o - m * k;
X     t2[4] = e * o - m * g;
X     t3[4] = e * k - i * g; */
X  t4 = glmm_fnmadd(x7, x3, t4);
X  
X  /* t1[5] = i * n - m * j;
X     t1[5] = i * n - m * j;
X     t2[5] = e * n - m * f;
X     t3[5] = e * j - i * f; */
X  t5 = glmm_fnmadd(x7, x5, t5);
X  
X  x4 = _mm_movelh_ps(r0, r1);        /* f e b a */
X  x5 = _mm_movehl_ps(r1, r0);        /* h g d c */
X  
X  x0 = glmm_shuff1(x4, 0, 0, 0, 2);  /* a a a e */
X  x1 = glmm_shuff1(x4, 1, 1, 1, 3);  /* b b b f */
X  x2 = glmm_shuff1(x5, 0, 0, 0, 2);  /* c c c g */
X  x3 = glmm_shuff1(x5, 1, 1, 1, 3);  /* d d d h */
X  
X  v2 = _mm_mul_ps(x0, t1);
X  v1 = _mm_mul_ps(x0, t0);
X  v3 = _mm_mul_ps(x0, t2);
X  v0 = _mm_mul_ps(x1, t0);
X  
X  v2 = glmm_fnmadd(x1, t3, v2);
X  v3 = glmm_fnmadd(x1, t4, v3);
X  v0 = glmm_fnmadd(x2, t1, v0);
X  v1 = glmm_fnmadd(x2, t3, v1);
X  
X  v3 = glmm_fmadd(x2, t5, v3);
X  v0 = glmm_fmadd(x3, t2, v0);
X  v2 = glmm_fmadd(x3, t5, v2);
X  v1 = glmm_fmadd(x3, t4, v1);
X
X  /*
X   dest[0][0] =  f * t1[0] - g * t1[1] + h * t1[2];
X   dest[0][1] =-(b * t1[0] - c * t1[1] + d * t1[2]);
X   dest[0][2] =  b * t2[0] - c * t2[1] + d * t2[2];
X   dest[0][3] =-(b * t3[0] - c * t3[1] + d * t3[2]); */
X  v0 = _mm_xor_ps(v0, x8);
X  
X  /*
X   dest[2][0] =  e * t1[1] - f * t1[3] + h * t1[5];
X   dest[2][1] =-(a * t1[1] - b * t1[3] + d * t1[5]);
X   dest[2][2] =  a * t2[1] - b * t2[3] + d * t2[5];
X   dest[2][3] =-(a * t3[1] - b * t3[3] + d * t3[5]);*/
X  v2 = _mm_xor_ps(v2, x8);
X
X  /*
X   dest[1][0] =-(e * t1[0] - g * t1[3] + h * t1[4]);
X   dest[1][1] =  a * t1[0] - c * t1[3] + d * t1[4];
X   dest[1][2] =-(a * t2[0] - c * t2[3] + d * t2[4]);
X   dest[1][3] =  a * t3[0] - c * t3[3] + d * t3[4]; */
X  v1 = _mm_xor_ps(v1, x9);
X
X  /*
X   dest[3][0] =-(e * t1[2] - f * t1[4] + g * t1[5]);
X   dest[3][1] =  a * t1[2] - b * t1[4] + c * t1[5];
X   dest[3][2] =-(a * t2[2] - b * t2[4] + c * t2[5]);
X   dest[3][3] =  a * t3[2] - b * t3[4] + c * t3[5]; */
X  v3 = _mm_xor_ps(v3, x9);
X
X  /* determinant */
X  x0 = _mm_shuffle_ps(v0, v1, _MM_SHUFFLE(0, 0, 0, 0));
X  x1 = _mm_shuffle_ps(v2, v3, _MM_SHUFFLE(0, 0, 0, 0));
X  x0 = _mm_shuffle_ps(x0, x1, _MM_SHUFFLE(2, 0, 2, 0));
X
X  x0 = _mm_rcp_ps(glmm_vhadd(_mm_mul_ps(x0, r0)));
X
X  glmm_store(dest[0], _mm_mul_ps(v0, x0));
X  glmm_store(dest[1], _mm_mul_ps(v1, x0));
X  glmm_store(dest[2], _mm_mul_ps(v2, x0));
X  glmm_store(dest[3], _mm_mul_ps(v3, x0));
X}
X
XCGLM_INLINE
Xvoid
Xglm_mat4_inv_sse2(mat4 mat, mat4 dest) {
X  __m128 r0, r1, r2, r3,
X         v0, v1, v2, v3,
X         t0, t1, t2, t3, t4, t5,
X         x0, x1, x2, x3, x4, x5, x6, x7, x8, x9;
X
X  /* x8 = _mm_set_ps(-0.f, 0.f, -0.f, 0.f); */
X  x8 = glmm_float32x4_SIGNMASK_NPNP;
X  x9 = glmm_shuff1(x8, 2, 1, 2, 1);
X
X  /* 127 <- 0 */
X  r0 = glmm_load(mat[0]); /* d c b a */
X  r1 = glmm_load(mat[1]); /* h g f e */
X  r2 = glmm_load(mat[2]); /* l k j i */
X  r3 = glmm_load(mat[3]); /* p o n m */
X  
X  x0 = _mm_movehl_ps(r3, r2);                            /* p o l k */
X  x3 = _mm_movelh_ps(r2, r3);                            /* n m j i */
X  x1 = glmm_shuff1(x0, 1, 3, 3 ,3);                      /* l p p p */
X  x2 = glmm_shuff1(x0, 0, 2, 2, 2);                      /* k o o o */
X  x4 = glmm_shuff1(x3, 1, 3, 3, 3);                      /* j n n n */
X  x7 = glmm_shuff1(x3, 0, 2, 2, 2);                      /* i m m m */
X
X  x6 = _mm_shuffle_ps(r2, r1, _MM_SHUFFLE(0, 0, 0, 0));  /* e e i i */
X  x5 = _mm_shuffle_ps(r2, r1, _MM_SHUFFLE(1, 1, 1, 1));  /* f f j j */
X  x3 = _mm_shuffle_ps(r2, r1, _MM_SHUFFLE(2, 2, 2, 2));  /* g g k k */
X  x0 = _mm_shuffle_ps(r2, r1, _MM_SHUFFLE(3, 3, 3, 3));  /* h h l l */
X  
X  t0 = _mm_mul_ps(x3, x1);
X  t1 = _mm_mul_ps(x5, x1);
X  t2 = _mm_mul_ps(x5, x2);
X  t3 = _mm_mul_ps(x6, x1);
X  t4 = _mm_mul_ps(x6, x2);
X  t5 = _mm_mul_ps(x6, x4);
X  
X  /* t1[0] = k * p - o * l;
X     t1[0] = k * p - o * l;
X     t2[0] = g * p - o * h;
X     t3[0] = g * l - k * h; */
X  t0 = glmm_fnmadd(x2, x0, t0);
X  
X  /* t1[1] = j * p - n * l;
X     t1[1] = j * p - n * l;
X     t2[1] = f * p - n * h;
X     t3[1] = f * l - j * h; */
X   t1 = glmm_fnmadd(x4, x0, t1);
X  
X  /* t1[2] = j * o - n * k
X     t1[2] = j * o - n * k;
X     t2[2] = f * o - n * g;
X     t3[2] = f * k - j * g; */
X  t2 = glmm_fnmadd(x4, x3, t2);
X  
X  /* t1[3] = i * p - m * l;
X     t1[3] = i * p - m * l;
X     t2[3] = e * p - m * h;
X     t3[3] = e * l - i * h; */
X  t3 = glmm_fnmadd(x7, x0, t3);
X  
X  /* t1[4] = i * o - m * k;
X     t1[4] = i * o - m * k;
X     t2[4] = e * o - m * g;
X     t3[4] = e * k - i * g; */
X  t4 = glmm_fnmadd(x7, x3, t4);
X  
X  /* t1[5] = i * n - m * j;
X     t1[5] = i * n - m * j;
X     t2[5] = e * n - m * f;
X     t3[5] = e * j - i * f; */
X  t5 = glmm_fnmadd(x7, x5, t5);
X  
X  x4 = _mm_movelh_ps(r0, r1);        /* f e b a */
X  x5 = _mm_movehl_ps(r1, r0);        /* h g d c */
X  
X  x0 = glmm_shuff1(x4, 0, 0, 0, 2);  /* a a a e */
X  x1 = glmm_shuff1(x4, 1, 1, 1, 3);  /* b b b f */
X  x2 = glmm_shuff1(x5, 0, 0, 0, 2);  /* c c c g */
X  x3 = glmm_shuff1(x5, 1, 1, 1, 3);  /* d d d h */
X  
X  v2 = _mm_mul_ps(x0, t1);
X  v1 = _mm_mul_ps(x0, t0);
X  v3 = _mm_mul_ps(x0, t2);
X  v0 = _mm_mul_ps(x1, t0);
X  
X  v2 = glmm_fnmadd(x1, t3, v2);
X  v3 = glmm_fnmadd(x1, t4, v3);
X  v0 = glmm_fnmadd(x2, t1, v0);
X  v1 = glmm_fnmadd(x2, t3, v1);
X  
X  v3 = glmm_fmadd(x2, t5, v3);
X  v0 = glmm_fmadd(x3, t2, v0);
X  v2 = glmm_fmadd(x3, t5, v2);
X  v1 = glmm_fmadd(x3, t4, v1);
X
X  /*
X   dest[0][0] =  f * t1[0] - g * t1[1] + h * t1[2];
X   dest[0][1] =-(b * t1[0] - c * t1[1] + d * t1[2]);
X   dest[0][2] =  b * t2[0] - c * t2[1] + d * t2[2];
X   dest[0][3] =-(b * t3[0] - c * t3[1] + d * t3[2]); */
X  v0 = _mm_xor_ps(v0, x8);
X  
X  /*
X   dest[2][0] =  e * t1[1] - f * t1[3] + h * t1[5];
X   dest[2][1] =-(a * t1[1] - b * t1[3] + d * t1[5]);
X   dest[2][2] =  a * t2[1] - b * t2[3] + d * t2[5];
X   dest[2][3] =-(a * t3[1] - b * t3[3] + d * t3[5]);*/
X  v2 = _mm_xor_ps(v2, x8);
X
X  /*
X   dest[1][0] =-(e * t1[0] - g * t1[3] + h * t1[4]);
X   dest[1][1] =  a * t1[0] - c * t1[3] + d * t1[4];
X   dest[1][2] =-(a * t2[0] - c * t2[3] + d * t2[4]);
X   dest[1][3] =  a * t3[0] - c * t3[3] + d * t3[4]; */
X  v1 = _mm_xor_ps(v1, x9);
X
X  /*
X   dest[3][0] =-(e * t1[2] - f * t1[4] + g * t1[5]);
X   dest[3][1] =  a * t1[2] - b * t1[4] + c * t1[5];
X   dest[3][2] =-(a * t2[2] - b * t2[4] + c * t2[5]);
X   dest[3][3] =  a * t3[2] - b * t3[4] + c * t3[5]; */
X  v3 = _mm_xor_ps(v3, x9);
X
X  /* determinant */
X  x0 = _mm_shuffle_ps(v0, v1, _MM_SHUFFLE(0, 0, 0, 0));
X  x1 = _mm_shuffle_ps(v2, v3, _MM_SHUFFLE(0, 0, 0, 0));
X  x0 = _mm_shuffle_ps(x0, x1, _MM_SHUFFLE(2, 0, 2, 0));
X
X  x0 = _mm_div_ps(_mm_set1_ps(1.0f), glmm_vhadd(_mm_mul_ps(x0, r0)));
X
X  glmm_store(dest[0], _mm_mul_ps(v0, x0));
X  glmm_store(dest[1], _mm_mul_ps(v1, x0));
X  glmm_store(dest[2], _mm_mul_ps(v2, x0));
X  glmm_store(dest[3], _mm_mul_ps(v3, x0));
X}
X
X#endif
X#endif /* cglm_mat_sse_h */
07f8b8c5e0aaa590b3f1a37415518ffb
echo x - cglm/simd/sse2/mat3.h
sed 's/^X//' >cglm/simd/sse2/mat3.h << '0f164d334a0cb2dfb8db09d8489abc86'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_mat3_sse_h
X#define cglm_mat3_sse_h
X#if defined( __SSE__ ) || defined( __SSE2__ )
X
X#include "../../common.h"
X#include "../intrin.h"
X
XCGLM_INLINE
Xvoid
Xglm_mat3_mul_sse2(mat3 m1, mat3 m2, mat3 dest) {
X  __m128 l0, l1, l2, r0, r1, r2, x0, x1, x2, x3, x4, x5, x6, x7, x8, x9;
X  
X  l0 = _mm_loadu_ps(m1[0]);
X  l1 = _mm_loadu_ps(&m1[1][1]);
X
X  r0 = _mm_loadu_ps(m2[0]);
X  r1 = _mm_loadu_ps(&m2[1][1]);
X
X  x8 = glmm_shuff1(l0, 0, 2, 1, 0);                     /* a00 a02 a01 a00 */
X  x1 = glmm_shuff1(r0, 3, 0, 0, 0);                     /* b10 b00 b00 b00 */
X  x2 = _mm_shuffle_ps(l0, l1, _MM_SHUFFLE(1, 0, 3, 3)); /* a12 a11 a10 a10 */
X  x3 = _mm_shuffle_ps(r0, r1, _MM_SHUFFLE(2, 0, 3, 1)); /* b20 b11 b10 b01 */
X  x0 = _mm_mul_ps(x8, x1);
X
X  x6 = glmm_shuff1(l0, 1, 0, 2, 1);                     /* a01 a00 a02 a01 */
X  x7 = glmm_shuff1(x3, 3, 3, 1, 1);                     /* b20 b20 b10 b10 */
X  l2 = _mm_load_ss(&m1[2][2]);
X  r2 = _mm_load_ss(&m2[2][2]);
X  x1 = _mm_mul_ps(x6, x7);
X  l2 = glmm_shuff1(l2, 0, 0, 1, 0);                     /* a22 a22 0.f a22 */
X  r2 = glmm_shuff1(r2, 0, 0, 1, 0);                     /* b22 b22 0.f b22 */
X
X  x4 = glmm_shuff1(x2, 0, 3, 2, 0);                     /* a10 a12 a11 a10 */
X  x5 = glmm_shuff1(x2, 2, 0, 3, 2);                     /* a11 a10 a12 a11 */
X  x6 = glmm_shuff1(x3, 2, 0, 0, 0);                     /* b11 b01 b01 b01 */
X  x2 = glmm_shuff1(r1, 3, 3, 0, 0);                     /* b21 b21 b11 b11 */
X
X  x8 = _mm_unpackhi_ps(x8, x4);                         /* a10 a00 a12 a02 */
X  x9 = _mm_unpackhi_ps(x7, x2);                         /* b21 b20 b21 b20 */
X
X  x0 = glmm_fmadd(x4, x6, x0);
X  x1 = glmm_fmadd(x5, x2, x1);
X
X  x2 = _mm_movehl_ps(l2, l1);                           /* a22 a22 a21 a20 */
X  x3 = glmm_shuff1(x2, 0, 2, 1, 0);                     /* a20 a22 a21 a20 */
X  x2 = glmm_shuff1(x2, 1, 0, 2, 1);                     /* a21 a20 a22 a21 */
X  x4 = _mm_shuffle_ps(r0, r1, _MM_SHUFFLE(1, 1, 2, 2)); /* b12 b12 b02 b02 */
X  
X  x5 = glmm_shuff1(x4, 3, 0, 0, 0);                     /* b12 b02 b02 b02 */
X  x4 = _mm_movehl_ps(r2, x4);                           /* b22 b22 b12 b12 */
X  x0 = glmm_fmadd(x3, x5, x0);
X  x1 = glmm_fmadd(x2, x4, x1);
X
X  /*
X   Dot Product : dest[2][2] =  a02 * b20 +
X                               a12 * b21 +
X                               a22 * b22 +
X                               0   * 00                                    */
X  x2 = _mm_movelh_ps(x8, l2);                           /* 0.f a22 a12 a02 */
X  x3 = _mm_movelh_ps(x9, r2);                           /* 0.f b22 b21 b20 */
X  x2 = glmm_vdots(x2, x3);
X
X  _mm_storeu_ps(&dest[0][0], x0);
X  _mm_storeu_ps(&dest[1][1], x1);
X  _mm_store_ss (&dest[2][2], x2);
X}
X
X#endif
X#endif /* cglm_mat3_sse_h */
0f164d334a0cb2dfb8db09d8489abc86
echo x - cglm/simd/sse2/mat2.h
sed 's/^X//' >cglm/simd/sse2/mat2.h << '87b9e0f884b058c0ab097db3af8fc3dc'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_mat2_sse_h
X#define cglm_mat2_sse_h
X#if defined( __SSE__ ) || defined( __SSE2__ )
X
X#include "../../common.h"
X#include "../intrin.h"
X
XCGLM_INLINE
Xvoid
Xglm_mat2_mul_sse2(mat2 m1, mat2 m2, mat2 dest) {
X  __m128 x0, x1, x2, x3, x4;
X
X  x1 = glmm_load(m1[0]); /* d c b a */
X  x2 = glmm_load(m2[0]); /* h g f e */
X
X  x3 = glmm_shuff1(x2, 2, 2, 0, 0);
X  x4 = glmm_shuff1(x2, 3, 3, 1, 1);
X  x0 = _mm_movelh_ps(x1, x1);
X  x2 = _mm_movehl_ps(x1, x1);
X
X  /*
X   dest[0][0] = a * e + c * f;
X   dest[0][1] = b * e + d * f;
X   dest[1][0] = a * g + c * h;
X   dest[1][1] = b * g + d * h;
X   */
X  x0 = glmm_fmadd(x0, x3, _mm_mul_ps(x2, x4));
X
X  glmm_store(dest[0], x0);
X}
X
XCGLM_INLINE
Xvoid
Xglm_mat2_transp_sse2(mat2 m, mat2 dest) {
X  /* d c b a */
X  /* d b c a */
X  glmm_store(dest[0], glmm_shuff1(glmm_load(m[0]), 3, 1, 2, 0));
X}
X
X#endif
X#endif /* cglm_mat2_sse_h */
87b9e0f884b058c0ab097db3af8fc3dc
echo x - cglm/simd/sse2/quat.h
sed 's/^X//' >cglm/simd/sse2/quat.h << '4c27eba24ad06de2a67fc455944323ba'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglm_quat_simd_h
X#define cglm_quat_simd_h
X#if defined( __SSE__ ) || defined( __SSE2__ )
X
X#include "../../common.h"
X#include "../intrin.h"
X
XCGLM_INLINE
Xvoid
Xglm_quat_mul_sse2(versor p, versor q, versor dest) {
X  /*
X   + (a1 b2 + b1 a2 + c1 d2  d1 c2)i
X   + (a1 c2  b1 d2 + c1 a2 + d1 b2)j
X   + (a1 d2 + b1 c2  c1 b2 + d1 a2)k
X     a1 a2  b1 b2  c1 c2  d1 d2
X   */
X
X  __m128 xp, xq, x1, x2, x3, r, x, y, z;
X
X  xp = glmm_load(p); /* 3 2 1 0 */
X  xq = glmm_load(q);
X  x1 = glmm_float32x4_SIGNMASK_NPNP; /* TODO: _mm_set1_ss() + shuff ? */
X  r  = _mm_mul_ps(glmm_splat_w(xp), xq);
X
X  x2 = _mm_unpackhi_ps(x1, x1);
X  x3 = glmm_shuff1(x1, 3, 2, 0, 1);
X  x  = glmm_splat_x(xp);
X  y  = glmm_splat_y(xp);
X  z  = glmm_splat_z(xp);
X
X  x  = _mm_xor_ps(x, x1);
X  y  = _mm_xor_ps(y, x2);
X  z  = _mm_xor_ps(z, x3);
X  
X  x1 = glmm_shuff1(xq, 0, 1, 2, 3);
X  x2 = glmm_shuff1(xq, 1, 0, 3, 2);
X  x3 = glmm_shuff1(xq, 2, 3, 0, 1);
X  
X  r  = glmm_fmadd(x, x1, r);
X  r  = glmm_fmadd(y, x2, r);
X  r  = glmm_fmadd(z, x3, r);
X
X  glmm_store(dest, r);
X}
X
X#endif
X#endif /* cglm_quat_simd_h */
4c27eba24ad06de2a67fc455944323ba
echo c - cglm/struct
mkdir -p cglm/struct > /dev/null 2>&1
echo x - cglm/struct/mat4.h
sed 's/^X//' >cglm/struct/mat4.h << '70d9775a551f5d6f28b21cec23b6874e'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*!
X * Most of functions in this header are optimized manually with SIMD
X * if available. You dont need to call/incude SIMD headers manually
X */
X
X/*
X Macros:
X   GLMS_MAT4_IDENTITY_INIT
X   GLMS_MAT4_ZERO_INIT
X   GLMS_MAT4_IDENTITY
X   GLMS_MAT4_ZERO
X
X Functions:
X   CGLM_INLINE mat4s   glms_mat4_ucopy(mat4s mat);
X   CGLM_INLINE mat4s   glms_mat4_copy(mat4s mat);
X   CGLM_INLINE mat4s   glms_mat4_identity(void);
X   CGLM_INLINE void    glms_mat4_identity_array(mat4s * __restrict mat, size_t count);
X   CGLM_INLINE mat4s   glms_mat4_zero(void);
X   CGLM_INLINE mat3s   glms_mat4_pick3(mat4s mat);
X   CGLM_INLINE mat3s   glms_mat4_pick3t(mat4s mat);
X   CGLM_INLINE mat4s   glms_mat4_ins3(mat3s mat, mat4s dest);
X   CGLM_INLINE mat4s   glms_mat4_mul(mat4s m1, mat4s m2);
X   CGLM_INLINE mat4s   glms_mat4_mulN(mat4s * __restrict matrices[], uint32_t len);
X   CGLM_INLINE vec4s   glms_mat4_mulv(mat4s m, vec4s v);
X   CGLM_INLINE float   glms_mat4_trace(mat4s m);
X   CGLM_INLINE float   glms_mat4_trace3(mat4s m);
X   CGLM_INLINE versors glms_mat4_quat(mat4s m);
X   CGLM_INLINE vec3s   glms_mat4_mulv3(mat4s m, vec3s v, float last);
X   CGLM_INLINE mat4s   glms_mat4_transpose(mat4s m);
X   CGLM_INLINE mat4s   glms_mat4_scale_p(mat4s m, float s);
X   CGLM_INLINE mat4s   glms_mat4_scale(mat4s m, float s);
X   CGLM_INLINE float   glms_mat4_det(mat4s mat);
X   CGLM_INLINE mat4s   glms_mat4_inv(mat4s mat);
X   CGLM_INLINE mat4s   glms_mat4_inv_fast(mat4s mat);
X   CGLM_INLINE mat4s   glms_mat4_swap_col(mat4s mat, int col1, int col2);
X   CGLM_INLINE mat4s   glms_mat4_swap_row(mat4s mat, int row1, int row2);
X   CGLM_INLINE float   glms_mat4_rmc(vec4s r, mat4s m, vec4s c);
X   CGLM_INLINE mat4s   glms_mat4_make(float * __restrict src);
X */
X
X#ifndef cglms_mat4s_h
X#define cglms_mat4s_h
X
X#include "../common.h"
X#include "../types-struct.h"
X#include "../mat4.h"
X#include "vec4.h"
X#include "vec3.h"
X
X/* api definition */ 
X#define glms_mat4_(NAME) CGLM_STRUCTAPI(mat4, NAME)
X
X#define GLMS_MAT4_IDENTITY_INIT  {GLM_MAT4_IDENTITY_INIT}
X#define GLMS_MAT4_ZERO_INIT      {GLM_MAT4_ZERO_INIT}
X
X/* for C only */
X#define GLMS_MAT4_IDENTITY ((mat4s)GLMS_MAT4_IDENTITY_INIT)
X#define GLMS_MAT4_ZERO     ((mat4s)GLMS_MAT4_ZERO_INIT)
X
X/*!
X * @brief copy all members of [mat] to [dest]
X *
X * matrix may not be aligned, u stands for unaligned, this may be useful when
X * copying a matrix from external source e.g. asset importer...
X *
X * @param[in]  mat  source
X * @returns         destination
X */
XCGLM_INLINE
Xmat4s
Xglms_mat4_(ucopy)(mat4s mat) {
X  mat4s r;
X  glm_mat4_ucopy(mat.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief copy all members of [mat] to [dest]
X *
X * @param[in]  mat  source
X * @returns         destination
X */
XCGLM_INLINE
Xmat4s
Xglms_mat4_(copy)(mat4s mat) {
X  mat4s r;
X  glm_mat4_copy(mat.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief make given matrix identity. It is identical with below, 
X *        but it is more easy to do that with this func especially for members
X *        e.g. glm_mat4_identity(aStruct->aMatrix);
X *
X * @code
X * glm_mat4_copy(GLM_MAT4_IDENTITY, mat); // C only
X *
X * // or
X * mat4 mat = GLM_MAT4_IDENTITY_INIT;
X * @endcode
X *
X * @retuns  destination
X */
XCGLM_INLINE
Xmat4s
Xglms_mat4_(identity)(void) {
X  mat4s r;
X  glm_mat4_identity(r.raw);
X  return r;
X}
X
X/*!
X * @brief make given matrix array's each element identity matrix
X *
X * @param[in, out]  mat   matrix array (must be aligned (16/32)
X *                        if alignment is not disabled)
X *
X * @param[in]       count count of matrices
X */
XCGLM_INLINE
Xvoid
Xglms_mat4_(identity_array)(mat4s * __restrict mat, size_t count) {
X  CGLM_ALIGN_MAT mat4s t = GLMS_MAT4_IDENTITY_INIT;
X  size_t i;
X
X  for (i = 0; i < count; i++) {
X    glm_mat4_copy(t.raw, mat[i].raw);
X  }
X}
X
X/*!
X * @brief make given matrix zero.
X *
X * @returns  matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_mat4_(zero)(void) {
X  mat4s r;
X  glm_mat4_zero(r.raw);
X  return r;
X}
X
X/*!
X * @brief copy upper-left of mat4 to mat3
X *
X * @param[in]  mat  source
X * @returns         destination
X */
XCGLM_INLINE
Xmat3s
Xglms_mat4_(pick3)(mat4s mat) {
X  mat3s r;
X  glm_mat4_pick3(mat.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief copy upper-left of mat4 to mat3 (transposed)
X *
X * the postfix t stands for transpose
X *
X * @param[in]  mat  source
X * @returns         destination
X */
XCGLM_INLINE
Xmat3s
Xglms_mat4_(pick3t)(mat4s mat) {
X  mat3s r;
X  glm_mat4_pick3t(mat.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief copy mat3 to mat4's upper-left
X *
X * @param[in]  mat  source
X * @param[in]  dest destination
X * @returns         destination
X */
XCGLM_INLINE
Xmat4s
Xglms_mat4_(ins3)(mat3s mat, mat4s dest) {
X  glm_mat4_ins3(mat.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief multiply m1 and m2 to dest
X *
X * m1, m2 and dest matrices can be same matrix, it is possible to write this:
X *
X * @code
X * mat4 m = GLM_MAT4_IDENTITY_INIT;
X * r = glms_mat4_mul(m, m);
X * @endcode
X *
X * @param[in]  m1   left matrix
X * @param[in]  m2   right matrix
X * @returns destination matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_mat4_(mul)(mat4s m1, mat4s m2) {
X  mat4s r;
X  glm_mat4_mul(m1.raw, m2.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief mupliply N mat4 matrices and store result in dest
X *
X * this function lets you multiply multiple (more than two or more...) matrices
X * <br><br>multiplication will be done in loop, this may reduce instructions
X * size but if <b>len</b> is too small then compiler may unroll whole loop,
X * usage:
X * @code
X * mat m1, m2, m3, m4, res;
X *
X * res = glm_mat4_mulN((mat4 *[]){&m1, &m2, &m3, &m4}, 4);
X * @endcode
X *
X * @warning matrices parameter is pointer array not mat4 array!
X *
X * @param[in]  matrices mat4 * array
X * @param[in]  len      matrices count
X * @returns             result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_mat4_(mulN)(mat4s * __restrict matrices[], uint32_t len) {
X  CGLM_ALIGN_MAT mat4s r = GLMS_MAT4_IDENTITY_INIT;
X  size_t i;
X
X  for (i = 0; i < len; i++) {
X    r = glms_mat4_(mul)(r, *matrices[i]);
X  }
X  
X  return r;
X}
X
X/*!
X * @brief multiply mat4 with vec4 (column vector) and store in dest vector
X *
X * @param[in]  m    mat4 (left)
X * @param[in]  v    vec4 (right, column vector)
X * @returns         vec4 (result, column vector)
X */
XCGLM_INLINE
Xvec4s
Xglms_mat4_(mulv)(mat4s m, vec4s v) {
X  vec4s r;
X  glm_mat4_mulv(m.raw, v.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief trace of matrix
X *
X * sum of the elements on the main diagonal from upper left to the lower right
X *
X * @param[in]  m matrix
X */
XCGLM_INLINE
Xfloat
Xglms_mat4_(trace)(mat4s m) {
X  return glm_mat4_trace(m.raw);
X}
X
X/*!
X * @brief trace of matrix (rotation part)
X *
X * sum of the elements on the main diagonal from upper left to the lower right
X *
X * @param[in]  m matrix
X */
XCGLM_INLINE
Xfloat
Xglms_mat4_(trace3)(mat4s m) {
X  return glm_mat4_trace3(m.raw);
X}
X
X/*!
X * @brief convert mat4's rotation part to quaternion
X *
X * @param[in]  m    affine matrix
X * @returns         destination quaternion
X */
XCGLM_INLINE
Xversors
Xglms_mat4_(quat)(mat4s m) {
X  versors r;
X  glm_mat4_quat(m.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief multiply vector with mat4
X *
X * @param[in]  m    mat4(affine transform)
X * @param[in]  v    vec3
X * @param[in]  last 4th item to make it vec4
X * @returns         result vector (vec3)
X */
XCGLM_INLINE
Xvec3s
Xglms_mat4_(mulv3)(mat4s m, vec3s v, float last) {
X  vec3s r;
X  glm_mat4_mulv3(m.raw, v.raw, last, r.raw);
X  return r;
X}
X
X/*!
X * @brief tranpose mat4 and store result in same matrix
X *
X * @param[in] m source
X * @returns     result
X */
XCGLM_INLINE
Xmat4s
Xglms_mat4_(transpose)(mat4s m) {
X  glm_mat4_transpose(m.raw);
X  return m;
X}
X
X/*!
X * @brief scale (multiply with scalar) matrix without simd optimization
X *
X * multiply matrix with scalar
X *
X * @param[in] m matrix
X * @param[in] s scalar
X * @returns     matrix    
X */
XCGLM_INLINE
Xmat4s
Xglms_mat4_(scale_p)(mat4s m, float s) {
X  glm_mat4_scale_p(m.raw, s);
X  return m;
X}
X
X/*!
X * @brief scale (multiply with scalar) matrix
X *
X * multiply matrix with scalar
X *
X * @param[in] m matrix
X * @param[in] s scalar
X * @returns     matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_mat4_(scale)(mat4s m, float s) {
X  glm_mat4_scale(m.raw, s);
X  return m;
X}
X
X/*!
X * @brief mat4 determinant
X *
X * @param[in] mat matrix
X *
X * @return determinant
X */
XCGLM_INLINE
Xfloat
Xglms_mat4_(det)(mat4s mat) {
X  return glm_mat4_det(mat.raw);
X}
X
X/*!
X * @brief inverse mat4 and store in dest
X *
X * @param[in]  mat  matrix
X * @returns         inverse matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_mat4_(inv)(mat4s mat) {
X  mat4s r;
X  glm_mat4_inv(mat.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief inverse mat4 and store in dest
X *
X * this func uses reciprocal approximation without extra corrections
X * e.g Newton-Raphson. this should work faster than normal,
X * to get more precise use glm_mat4_inv version.
X *
X * NOTE: You will lose precision, glm_mat4_inv is more accurate
X *
X * @param[in]  mat  matrix
X * @returns         inverse matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_mat4_(inv_fast)(mat4s mat) {
X  mat4s r;
X  glm_mat4_inv_fast(mat.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief swap two matrix columns
X *
X * @param[in] mat  matrix
X * @param[in] col1 col1
X * @param[in] col2 col2
X * @returns        matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_mat4_(swap_col)(mat4s mat, int col1, int col2) {
X  glm_mat4_swap_col(mat.raw, col1, col2);
X  return mat;
X}
X
X/*!
X * @brief swap two matrix rows
X *
X * @param[in] mat  matrix
X * @param[in] row1 row1
X * @param[in] row2 row2
X * @returns        matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_mat4_(swap_row)(mat4s mat, int row1, int row2) {
X  glm_mat4_swap_row(mat.raw, row1, row2);
X  return mat;
X}
X
X/*!
X * @brief helper for  R (row vector) * M (matrix) * C (column vector)
X *
X * rmc stands for Row * Matrix * Column
X *
X * the result is scalar because R * M = Matrix1x4 (row vector),
X * then Matrix1x4 * Vec4 (column vector) = Matrix1x1 (Scalar)
X *
X * @param[in]  r   row vector or matrix1x4
X * @param[in]  m   matrix4x4
X * @param[in]  c   column vector or matrix4x1
X *
X * @return scalar value e.g. B(s)
X */
XCGLM_INLINE
Xfloat
Xglms_mat4_(rmc)(vec4s r, mat4s m, vec4s c) {
X  return glm_mat4_rmc(r.raw, m.raw, c.raw);
X}
X
X/*!
X * @brief Create mat4 matrix from pointer
X *
X * @param[in]  src  pointer to an array of floats
X * @return constructed matrix from raw pointer
X */
XCGLM_INLINE
Xmat4s
Xglms_mat4_(make)(float * __restrict src) {
X  mat4s r;
X  glm_mat4_make(src, r.raw);
X  return r;
X}
X
X#endif /* cglms_mat4s_h */
70d9775a551f5d6f28b21cec23b6874e
echo x - cglm/struct/mat4x2.h
sed 's/^X//' >cglm/struct/mat4x2.h << 'f7d9c1d7aca0670299deb07c27f8ea6d'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Macros:
X   GLMS_MAT4X2_ZERO_INIT
X   GLMS_MAT4X2_ZERO
X
X Functions:
X   CGLM_INLINE mat4x2s glms_mat4x2_zero(void);
X   CGLM_INLINE mat4x2s glms_mat4x2_make(float * __restrict src);
X   CGLM_INLINE mat4s   glms_mat4x2_mul(mat4x2s m1, mat2x4s m2);
X   CGLM_INLINE vec4s   glms_mat4x2_mulv(mat4x2s m, vec2s v);
X   CGLM_INLINE mat2x4s glms_mat4x2_transpose(mat4x2s m);
X   CGLM_INLINE mat4x2s glms_mat4x2_scale(mat4x2s m, float s);
X */
X
X#ifndef cglms_mat4x2_h
X#define cglms_mat4x2_h
X
X#include "../common.h"
X#include "../types-struct.h"
X#include "../mat4x2.h"
X
X/* api definition */
X#define glms_mat4x2_(NAME) CGLM_STRUCTAPI(mat4x2, NAME)
X
X#define GLMS_MAT4X2_ZERO_INIT {GLM_MAT4X2_ZERO_INIT}
X
X/* for C only */
X#define GLMS_MAT4X2_ZERO ((mat4x2s)GLMS_MAT4X2_ZERO_INIT)
X
X
X/*!
X * @brief make given matrix zero.
X *
X * @param[in, out]  mat  matrix
X */
XCGLM_INLINE
Xmat4x2s
Xglms_mat4x2_(zero)(void) {
X  mat4x2s r;
X  glm_mat4x2_zero(r.raw);
X  return r;
X}
X
X/*!
X * @brief Create mat4x2 matrix from pointer
X *
X * @param[in]  src  pointer to an array of floats
X * @return constructed matrix from raw pointer
X */
XCGLM_INLINE
Xmat4x2s
Xglms_mat4x2_(make)(float * __restrict src) {
X  mat4x2s r;
X  glm_mat4x2_make(src, r.raw);
X  return r;
X}
X
X/*!
X * @brief multiply m1 and m2 to dest
X *
X * @code
X * r = glms_mat4x2_mul(mat4x2s, mat2x4s);
X * @endcode
X *
X * @param[in]  m1   left matrix (mat4x2s)
X * @param[in]  m2   right matrix (mat2x4s)
X * @returns destination matrix (mat4s)
X */
XCGLM_INLINE
Xmat4s
Xglms_mat4x2_(mul)(mat4x2s m1, mat2x4s m2) {
X  mat4s r;
X  glm_mat4x2_mul(m1.raw, m2.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief multiply matrix with column vector and store in dest vector
X *
X * @param[in]  m    matrix (left)
X * @param[in]  v    vector (right, column vector)
X * @param[out] dest result vector
X */
XCGLM_INLINE
Xvec4s
Xglms_mat4x2_(mulv)(mat4x2s m, vec2s v) {
X  vec4s r;
X  glm_mat4x2_mulv(m.raw, v.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief transpose matrix and store in dest
X *
X * @param[in]  m     matrix
X * @param[out] dest  result
X */
XCGLM_INLINE
Xmat2x4s
Xglms_mat4x2_(transpose)(mat4x2s m) {
X  mat2x4s r;
X  glm_mat4x2_transpose(m.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief scale (multiply with scalar) matrix
X *
X * multiply matrix with scalar
X *
X * @param[in, out] m matrix
X * @param[in]    s scalar
X */
XCGLM_INLINE
Xmat4x2s
Xglms_mat4x2_(scale)(mat4x2s m, float s) {
X  glm_mat4x2_scale(m.raw, s);
X  return m;
X}
X
X#endif /* cglms_mat4x2_h */
f7d9c1d7aca0670299deb07c27f8ea6d
echo x - cglm/struct/mat4x3.h
sed 's/^X//' >cglm/struct/mat4x3.h << '22867ae7a2d9efc91b12d36ffab1ce3f'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Macros:
X   GLMS_MAT4X3_ZERO_INIT
X   GLMS_MAT4X3_ZERO
X
X Functions:
X   CGLM_INLINE mat4x3s glms_mat4x3_zero(void);
X   CGLM_INLINE mat4x3s glms_mat4x3_make(float * __restrict src);
X   CGLM_INLINE mat4s   glms_mat4x3_mul(mat4x3s m1, mat3x4s m2);
X   CGLM_INLINE vec4s   glms_mat4x3_mulv(mat4x3s m, vec3s v);
X   CGLM_INLINE mat3x4s glms_mat4x3_transpose(mat4x3s m);
X   CGLM_INLINE mat4x3s glms_mat4x3_scale(mat4x3s m, float s);
X */
X
X#ifndef cglms_mat4x3_h
X#define cglms_mat4x3_h
X
X#include "../common.h"
X#include "../types-struct.h"
X#include "../mat4x3.h"
X
X/* api definition */
X#define glms_mat4x3_(NAME) CGLM_STRUCTAPI(mat4x3, NAME)
X
X#define GLMS_MAT4X3_ZERO_INIT {GLM_MAT4X3_ZERO_INIT}
X
X/* for C only */
X#define GLMS_MAT4X3_ZERO ((mat4x3s)GLMS_MAT4X3_ZERO_INIT)
X
X/*!
X * @brief make given matrix zero.
X *
X * @param[in, out]  mat  matrix
X */
XCGLM_INLINE
Xmat4x3s
Xglms_mat4x3_(zero)(void) {
X  mat4x3s r;
X  glm_mat4x3_zero(r.raw);
X  return r;
X}
X
X/*!
X * @brief Create mat4x3 matrix from pointer
X *
X * @param[in]  src  pointer to an array of floats
X * @return constructed matrix from raw pointer
X */
XCGLM_INLINE
Xmat4x3s
Xglms_mat4x3_(make)(float * __restrict src) {
X  mat4x3s r;
X  glm_mat4x3_make(src, r.raw);
X  return r;
X}
X
X/*!
X * @brief multiply m1 and m2 to dest
X *
X * @code
X * r = glms_mat4x3_mul(mat4x3s, mat3x4s);
X * @endcode
X *
X * @param[in]  m1   left matrix (mat4x3s)
X * @param[in]  m2   right matrix (mat3x4s)
X * @returns destination matrix (mat4s)
X */
XCGLM_INLINE
Xmat4s
Xglms_mat4x3_(mul)(mat4x3s m1, mat3x4s m2) {
X  mat4s r;
X  glm_mat4x3_mul(m1.raw, m2.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief multiply matrix with column vector and store in dest vector
X *
X * @param[in]  m    matrix (left)
X * @param[in]  v    vector (right, column vector)
X * @param[out] dest result vector
X */
XCGLM_INLINE
Xvec4s
Xglms_mat4x3_(mulv)(mat4x3s m, vec3s v) {
X  vec4s r;
X  glm_mat4x3_mulv(m.raw, v.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief transpose matrix and store in dest
X *
X * @param[in]  m     matrix
X * @param[out] dest  result
X */
XCGLM_INLINE
Xmat3x4s
Xglms_mat4x3_(transpose)(mat4x3s m) {
X  mat3x4s r;
X  glm_mat4x3_transpose(m.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief scale (multiply with scalar) matrix
X *
X * multiply matrix with scalar
X *
X * @param[in, out] m matrix
X * @param[in]    s scalar
X */
XCGLM_INLINE
Xmat4x3s
Xglms_mat4x3_(scale)(mat4x3s m, float s) {
X  glm_mat4x3_scale(m.raw, s);
X  return m;
X}
X
X#endif /* cglms_mat4x3_h */
22867ae7a2d9efc91b12d36ffab1ce3f
echo x - cglm/struct/mat3.h
sed 's/^X//' >cglm/struct/mat3.h << '1a123a2ad7db2666d2dbb9fecacecc2c'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Macros:
X   GLMS_MAT3_IDENTITY_INIT
X   GLMS_MAT3_ZERO_INIT
X   GLMS_MAT3_IDENTITY
X   GLMS_MAT3_ZERO
X
X Functions:
X   CGLM_INLINE mat3s  glms_mat3_copy(mat3s mat);
X   CGLM_INLINE mat3s  glms_mat3_identity(void);
X   CGLM_INLINE void   glms_mat3_identity_array(mat3s * __restrict mat, size_t count);
X   CGLM_INLINE mat3s  glms_mat3_zero(void);
X   CGLM_INLINE mat3s  glms_mat3_mul(mat3s m1, mat3s m2);
X   CGLM_INLINE ma3s   glms_mat3_transpose(mat3s m);
X   CGLM_INLINE vec3s  glms_mat3_mulv(mat3s m, vec3s v);
X   CGLM_INLINE float  glms_mat3_trace(mat3s m);
X   CGLM_INLINE versor glms_mat3_quat(mat3s m);
X   CGLM_INLINE mat3s  glms_mat3_scale(mat3s m, float s);
X   CGLM_INLINE float  glms_mat3_det(mat3s mat);
X   CGLM_INLINE mat3s  glms_mat3_inv(mat3s mat);
X   CGLM_INLINE mat3s  glms_mat3_swap_col(mat3s mat, int col1, int col2);
X   CGLM_INLINE mat3s  glms_mat3_swap_row(mat3s mat, int row1, int row2);
X   CGLM_INLINE float  glms_mat3_rmc(vec3s r, mat3s m, vec3s c);
X   CGLM_INLINE mat3s  glms_mat3_make(float * __restrict src);
X */
X
X#ifndef cglms_mat3s_h
X#define cglms_mat3s_h
X
X#include "../common.h"
X#include "../types-struct.h"
X#include "../mat3.h"
X#include "vec3.h"
X
X/* api definition */
X#define glms_mat3_(NAME) CGLM_STRUCTAPI(mat3, NAME)
X
X#define GLMS_MAT3_IDENTITY_INIT  {GLM_MAT3_IDENTITY_INIT}
X#define GLMS_MAT3_ZERO_INIT      {GLM_MAT3_ZERO_INIT}
X
X/* for C only */
X#define GLMS_MAT3_IDENTITY ((mat3s)GLMS_MAT3_IDENTITY_INIT)
X#define GLMS_MAT3_ZERO     ((mat3s)GLMS_MAT3_ZERO_INIT)
X
X/*!
X * @brief copy all members of [mat] to [dest]
X *
X * @param[in]  mat  source
X * @returns         destination
X */
XCGLM_INLINE
Xmat3s
Xglms_mat3_(copy)(mat3s mat) {
X  mat3s r;
X  glm_mat3_copy(mat.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief make given matrix identity. It is identical with below,
X *        but it is more easy to do that with this func especially for members
X *        e.g. glm_mat3_identity(aStruct->aMatrix);
X *
X * @code
X * glm_mat3_copy(GLM_MAT3_IDENTITY, mat); // C only
X *
X * // or
X * mat3 mat = GLM_MAT3_IDENTITY_INIT;
X * @endcode
X *
X * @returns  destination
X */
XCGLM_INLINE
Xmat3s
Xglms_mat3_(identity)(void) {
X  mat3s r;
X  glm_mat3_identity(r.raw);
X  return r;
X}
X
X/*!
X * @brief make given matrix array's each element identity matrix
X *
X * @param[in, out]  mat   matrix array (must be aligned (16/32)
X *                        if alignment is not disabled)
X *
X * @param[in]       count count of matrices
X */
XCGLM_INLINE
Xvoid
Xglms_mat3_(identity_array)(mat3s * __restrict mat, size_t count) {
X  CGLM_ALIGN_MAT mat3s t = GLMS_MAT3_IDENTITY_INIT;
X  size_t i;
X
X  for (i = 0; i < count; i++) {
X    glm_mat3_copy(t.raw, mat[i].raw);
X  }
X}
X
X/*!
X * @brief make given matrix zero.
X *
X * @returns  matrix
X */
XCGLM_INLINE
Xmat3s
Xglms_mat3_(zero)(void) {
X  mat3s r;
X  glm_mat3_zero(r.raw);
X  return r;
X}
X
X/*!
X * @brief multiply m1 and m2 to dest
X *
X * m1, m2 and dest matrices can be same matrix, it is possible to write this:
X *
X * @code
X * mat3 m = GLM_MAT3_IDENTITY_INIT;
X * r = glms_mat3_mul(m, m);
X * @endcode
X *
X * @param[in]  m1   left matrix
X * @param[in]  m2   right matrix
X * @returns destination matrix
X */
XCGLM_INLINE
Xmat3s
Xglms_mat3_(mul)(mat3s m1, mat3s m2) {
X  mat3s r;
X  glm_mat3_mul(m1.raw, m2.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief tranpose mat3 and store result in same matrix
X *
X * @param[in, out] m source and dest
X */
XCGLM_INLINE
Xmat3s
Xglms_mat3_(transpose)(mat3s m) {
X  glm_mat3_transpose(m.raw);
X  return m;
X}
X
X/*!
X * @brief multiply mat3 with vec3 (column vector) and store in dest vector
X *
X * @param[in]  m    mat3 (left)
X * @param[in]  v    vec3 (right, column vector)
X * @returns         vec3 (result, column vector)
X */
XCGLM_INLINE
Xvec3s
Xglms_mat3_(mulv)(mat3s m, vec3s v) {
X  vec3s r;
X  glm_mat3_mulv(m.raw, v.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief trace of matrix
X *
X * sum of the elements on the main diagonal from upper left to the lower right
X *
X * @param[in]  m matrix
X */
XCGLM_INLINE
Xfloat
Xglms_mat3_(trace)(mat3s m) {
X  return glm_mat3_trace(m.raw);
X}
X
X/*!
X * @brief convert mat3 to quaternion
X *
X * @param[in]  m    rotation matrix
X * @returns         destination quaternion
X */
XCGLM_INLINE
Xversors
Xglms_mat3_(quat)(mat3s m) {
X  versors r;
X  glm_mat3_quat(m.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief scale (multiply with scalar) matrix
X *
X * multiply matrix with scalar
X *
X * @param[in]      m matrix
X * @param[in]      s scalar
X * @returns          scaled matrix
X */
XCGLM_INLINE
Xmat3s
Xglms_mat3_(scale)(mat3s m, float s) {
X  glm_mat3_scale(m.raw, s);
X  return m;
X}
X
X/*!
X * @brief mat3 determinant
X *
X * @param[in] mat matrix
X *
X * @return determinant
X */
XCGLM_INLINE
Xfloat
Xglms_mat3_(det)(mat3s mat) {
X  return glm_mat3_det(mat.raw);
X}
X
X/*!
X * @brief inverse mat3 and store in dest
X *
X * @param[in]  mat  matrix
X * @returns         inverse matrix
X */
XCGLM_INLINE
Xmat3s
Xglms_mat3_(inv)(mat3s mat) {
X  mat3s r;
X  glm_mat3_inv(mat.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief swap two matrix columns
X *
X * @param[in]     mat  matrix
X * @param[in]     col1 col1
X * @param[in]     col2 col2
X * @returns            matrix
X */
XCGLM_INLINE
Xmat3s
Xglms_mat3_(swap_col)(mat3s mat, int col1, int col2) {
X  glm_mat3_swap_col(mat.raw, col1, col2);
X  return mat;
X}
X
X/*!
X * @brief swap two matrix rows
X *
X * @param[in]     mat  matrix
X * @param[in]     row1 row1
X * @param[in]     row2 row2
X * @returns            matrix
X */
XCGLM_INLINE
Xmat3s
Xglms_mat3_(swap_row)(mat3s mat, int row1, int row2) {
X  glm_mat3_swap_row(mat.raw, row1, row2);
X  return mat;
X}
X
X/*!
X * @brief helper for  R (row vector) * M (matrix) * C (column vector)
X *
X * rmc stands for Row * Matrix * Column
X *
X * the result is scalar because R * M = Matrix1x3 (row vector),
X * then Matrix1x3 * Vec3 (column vector) = Matrix1x1 (Scalar)
X *
X * @param[in]  r   row vector or matrix1x3
X * @param[in]  m   matrix3x3
X * @param[in]  c   column vector or matrix3x1
X *
X * @return scalar value e.g. Matrix1x1
X */
XCGLM_INLINE
Xfloat
Xglms_mat3_(rmc)(vec3s r, mat3s m, vec3s c) {
X  return glm_mat3_rmc(r.raw, m.raw, c.raw);
X}
X
X/*!
X * @brief Create mat3 matrix from pointer
X *
X * @param[in]  src  pointer to an array of floats
X * @return constructed matrix from raw pointer
X */
XCGLM_INLINE
Xmat3s
Xglms_mat3_(make)(float * __restrict src) {
X  mat3s r;
X  glm_mat3_make(src, r.raw);
X  return r;
X}
X
X#endif /* cglms_mat3s_h */
1a123a2ad7db2666d2dbb9fecacecc2c
echo x - cglm/struct/mat3x2.h
sed 's/^X//' >cglm/struct/mat3x2.h << '9c12883b5102b0f554fb2ae5e6312eaf'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Macros:
X   GLMS_MAT3X2_ZERO_INIT
X   GLMS_MAT3X2_ZERO
X
X Functions:
X   CGLM_INLINE mat3x2s glms_mat3x2_zero(void);
X   CGLM_INLINE mat3x2s glms_mat3x2_make(float * __restrict src);
X   CGLM_INLINE mat3s   glms_mat3x2_mul(mat3x2s m1, mat2x3s m2);
X   CGLM_INLINE vec3s   glms_mat3x2_mulv(mat3x2s m, vec2s v);
X   CGLM_INLINE mat2x3s glms_mat3x2_transpose(mat3x2s m);
X   CGLM_INLINE mat3x2s glms_mat3x2_scale(mat3x2s m, float s);
X */
X
X#ifndef cglms_mat3x2_h
X#define cglms_mat3x2_h
X
X#include "../common.h"
X#include "../types-struct.h"
X#include "../mat3x2.h"
X
X/* api definition */
X#define glms_mat3x2_(NAME) CGLM_STRUCTAPI(mat3x2, NAME)
X
X#define GLMS_MAT3X2_ZERO_INIT {GLM_MAT3X2_ZERO_INIT}
X
X/* for C only */
X#define GLMS_MAT3X2_ZERO ((mat3x2s)GLMS_MAT3X2_ZERO_INIT)
X
X/*!
X * @brief make given matrix zero.
X *
X * @param[in, out]  mat  matrix
X */
XCGLM_INLINE
Xmat3x2s
Xglms_mat3x2_(zero)(void) {
X  mat3x2s r;
X  glm_mat3x2_zero(r.raw);
X  return r;
X}
X
X/*!
X * @brief Create mat3x2 matrix from pointer
X *
X * @param[in]  src  pointer to an array of floats
X * @return constructed matrix from raw pointer
X */
XCGLM_INLINE
Xmat3x2s
Xglms_mat3x2_(make)(float * __restrict src) {
X  mat3x2s r;
X  glm_mat3x2_make(src, r.raw);
X  return r;
X}
X
X/*!
X * @brief multiply m1 and m2 to dest
X *
X * @code
X * r = glms_mat3x2_mul(mat3x2s, mat2x3s);
X * @endcode
X *
X * @param[in]  m1   left matrix (mat3x2s)
X * @param[in]  m2   right matrix (mat2x3s)
X * @returns destination matrix (mat3s)
X */
XCGLM_INLINE
Xmat3s
Xglms_mat3x2_(mul)(mat3x2s m1, mat2x3s m2) {
X  mat3s r;
X  glm_mat3x2_mul(m1.raw, m2.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief multiply matrix with column vector and store in dest vector
X *
X * @param[in]  m    matrix (left)
X * @param[in]  v    vector (right, column vector)
X * @param[out] dest result vector
X */
XCGLM_INLINE
Xvec3s
Xglms_mat3x2_(mulv)(mat3x2s m, vec2s v) {
X  vec3s r;
X  glm_mat3x2_mulv(m.raw, v.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief transpose matrix and store in dest
X *
X * @param[in]  m     matrix
X * @param[out] dest  result
X */
XCGLM_INLINE
Xmat2x3s
Xglms_mat3x2_(transpose)(mat3x2s m) {
X  mat2x3s r;
X  glm_mat3x2_transpose(m.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief scale (multiply with scalar) matrix
X *
X * multiply matrix with scalar
X *
X * @param[in, out] m matrix
X * @param[in]    s scalar
X */
XCGLM_INLINE
Xmat3x2s
Xglms_mat3x2_(scale)(mat3x2s m, float s) {
X  glm_mat3x2_scale(m.raw, s);
X  return m;
X}
X
X#endif /* cglms_mat3x2_h */
9c12883b5102b0f554fb2ae5e6312eaf
echo x - cglm/struct/mat3x4.h
sed 's/^X//' >cglm/struct/mat3x4.h << '62d60dc27ac3af088ae5f08437d0c2a7'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Macros:
X   GLMS_MAT3X4_ZERO_INIT
X   GLMS_MAT3X4_ZERO
X
X Functions:
X   CGLM_INLINE mat3x4s glms_mat3x4_zero(void);
X   CGLM_INLINE mat3x4s glms_mat3x4_make(float * __restrict src);
X   CGLM_INLINE mat3s   glms_mat3x4_mul(mat3x4s m1, mat4x3s m2);
X   CGLM_INLINE vec3s   glms_mat3x4_mulv(mat3x4s m, vec4s v);
X   CGLM_INLINE mat4x3s glms_mat3x4_transpose(mat3x4s m);
X   CGLM_INLINE mat3x4s glms_mat3x4_scale(mat3x4s m, float s);
X */
X
X#ifndef cglms_mat3x4_h
X#define cglms_mat3x4_h
X
X#include "../common.h"
X#include "../types-struct.h"
X#include "../mat3x4.h"
X
X/* api definition */
X#define glms_mat3x4_(NAME) CGLM_STRUCTAPI(mat3x4, NAME)
X
X#define GLMS_MAT3X4_ZERO_INIT {GLM_MAT3X4_ZERO_INIT}
X
X/* for C only */
X#define GLMS_MAT3X4_ZERO ((mat3x4s)GLMS_MAT3X4_ZERO_INIT)
X
X/*!
X * @brief make given matrix zero.
X *
X * @param[in, out]  mat  matrix
X */
XCGLM_INLINE
Xmat3x4s
Xglms_mat3x4_(zero)(void) {
X  mat3x4s r;
X  glm_mat3x4_zero(r.raw);
X  return r;
X}
X
X/*!
X * @brief Create mat3x4 matrix from pointer
X *
X * @param[in]  src  pointer to an array of floats
X * @return constructed matrix from raw pointer
X */
XCGLM_INLINE
Xmat3x4s
Xglms_mat3x4_(make)(float * __restrict src) {
X  mat3x4s r;
X  glm_mat3x4_make(src, r.raw);
X  return r;
X}
X
X/*!
X * @brief multiply m1 and m2 to dest
X *
X * @code
X * r = glms_mat3x4_mul(mat3x4s, mat4x3s);
X * @endcode
X *
X * @param[in]  m1   left matrix (mat3x4s)
X * @param[in]  m2   right matrix (mat4x3s)
X * @returns destination matrix (mat3s)
X */
XCGLM_INLINE
Xmat3s
Xglms_mat3x4_(mul)(mat3x4s m1, mat4x3s m2) {
X  mat3s r;
X  glm_mat3x4_mul(m1.raw, m2.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief multiply matrix with column vector and store in dest vector
X *
X * @param[in]  m    matrix (left)
X * @param[in]  v    vector (right, column vector)
X * @param[out] dest result vector
X */
XCGLM_INLINE
Xvec3s
Xglms_mat3x4_(mulv)(mat3x4s m, vec4s v) {
X  vec3s r;
X  glm_mat3x4_mulv(m.raw, v.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief transpose matrix and store in dest
X *
X * @param[in]  m     matrix
X * @param[out] dest  result
X */
XCGLM_INLINE
Xmat4x3s
Xglms_mat3x4_(transpose)(mat3x4s m) {
X  mat4x3s r;
X  glm_mat3x4_transpose(m.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief scale (multiply with scalar) matrix
X *
X * multiply matrix with scalar
X *
X * @param[in, out] m matrix
X * @param[in]    s scalar
X */
XCGLM_INLINE
Xmat3x4s
Xglms_mat3x4_(scale)(mat3x4s m, float s) {
X  glm_mat3x4_scale(m.raw, s);
X  return m;
X}
X
X#endif /* cglms_mat3x4_h */
62d60dc27ac3af088ae5f08437d0c2a7
echo x - cglm/struct/mat2.h
sed 's/^X//' >cglm/struct/mat2.h << 'cadcf99b50ea8b6be5af44e58ccf2c62'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Macros:
X   GLM_MAT2_IDENTITY_INIT
X   GLM_MAT2_ZERO_INIT
X   GLM_MAT2_IDENTITY
X   GLM_MAT2_ZERO
X
X Functions:
X   CGLM_INLINE void  glms_mat2_identity(mat2 mat)
X   CGLM_INLINE void  glms_mat2_identity_array(mat2 * restrict mat, size_t count)
X   CGLM_INLINE void  glms_mat2_zero(mat2 mat)
X   CGLM_INLINE void  glms_mat2_mul(mat2 m1, mat2 m2, mat2 dest)
X   CGLM_INLINE void  glms_mat2_transpose_to(mat2 m, mat2 dest)
X   CGLM_INLINE void  glms_mat2_transpose(mat2 m)
X   CGLM_INLINE void  glms_mat2_mulv(mat2 m, vec2 v, vec2 dest)
X   CGLM_INLINE float glms_mat2_trace(mat2 m)
X   CGLM_INLINE void  glms_mat2_scale(mat2 m, float s)
X   CGLM_INLINE float glms_mat2_det(mat2 mat)
X   CGLM_INLINE void  glms_mat2_inv(mat2 mat, mat2 dest)
X   CGLM_INLINE void  glms_mat2_swap_col(mat2 mat, int col1, int col2)
X   CGLM_INLINE void  glms_mat2_swap_row(mat2 mat, int row1, int row2)
X   CGLM_INLINE float glms_mat2_rmc(vec2 r, mat2 m, vec2 c)
X   CGLM_INLINE mat2s glms_mat2_make(float * __restrict src);
X */
X
X#ifndef cglms_mat2_h
X#define cglms_mat2_h
X
X#include "../common.h"
X#include "../types-struct.h"
X#include "../mat2.h"
X
X/* api definition */
X#define glms_mat2_(NAME) CGLM_STRUCTAPI(mat2, NAME)
X
X#define GLMS_MAT2_IDENTITY_INIT {GLM_MAT2_IDENTITY_INIT}
X#define GLMS_MAT2_ZERO_INIT     {GLM_MAT2_ZERO_INIT}
X
X/* for C only */
X#define GLMS_MAT2_IDENTITY ((mat2s)GLMS_MAT2_IDENTITY_INIT)
X#define GLMS_MAT2_ZERO     ((mat2s)GLMS_MAT2_ZERO_INIT)
X
X/*!
X * @brief make given matrix identity. It is identical with below,
X *        but it is more easy to do that with this func especially for members
X *        e.g. glm_mat2_identity(aStruct->aMatrix);
X *
X * @code
X * glm_mat2_copy(GLM_MAT2_IDENTITY, mat); // C only
X *
X * // or
X * mat2 mat = GLM_MAT2_IDENTITY_INIT;
X * @endcode
X *
X * @returns identity matrix
X */
XCGLM_INLINE
Xmat2s
Xglms_mat2_(identity)(void) {
X  mat2s r;
X  glm_mat2_identity(r.raw);
X  return r;
X}
X
X/*!
X * @brief make given matrix array's each element identity matrix
X *
X * @param[in, out]  mat   matrix array (must be aligned (16)
X *                        if alignment is not disabled)
X *
X * @param[in]       count count of matrices
X */
XCGLM_INLINE
Xvoid
Xglms_mat2_(identity_array)(mat2s * __restrict mat, size_t count) {
X  CGLM_ALIGN_MAT mat2s t = GLMS_MAT2_IDENTITY_INIT;
X  size_t i;
X
X  for (i = 0; i < count; i++) {
X    glm_mat2_copy(t.raw, mat[i].raw);
X  }
X}
X
X/*!
X * @brief make given matrix zero.
X *
X * @returns  matrix
X */
XCGLM_INLINE
Xmat2s
Xglms_mat2_(zero)(void) {
X  mat2s r;
X  glm_mat2_zero(r.raw);
X  return r;
X}
X
X/*!
X * @brief multiply m1 and m2 to dest
X *
X * m1, m2 and dest matrices can be same matrix, it is possible to write this:
X *
X * @code
X * mat2 m = GLM_MAT2_IDENTITY_INIT;
X * r = glms_mat2_mul(m, m);
X * @endcode
X *
X * @param[in]  m1   left matrix
X * @param[in]  m2   right matrix
X *
X * @returns destination matrix
X */
XCGLM_INLINE
Xmat2s
Xglms_mat2_(mul)(mat2s m1, mat2s m2) {
X  mat2s r;
X  glm_mat2_mul(m1.raw, m2.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief transpose mat2
X *
X * @param[in] m matrix to transpose
X *
X * @returns transposed matrix
X */
XCGLM_INLINE
Xmat2s
Xglms_mat2_(transpose)(mat2s m) {
X  glm_mat2_transpose(m.raw);
X  return m;
X}
X
X/*!
X * @brief multiply mat2 with vec2 (column vector) and store in dest vector
X *
X * @param[in]  m    mat2 (left)
X * @param[in]  v    vec2 (right, column vector)
X * @returns         vec2 (result, column vector)
X */
XCGLM_INLINE
Xvec2s
Xglms_mat2_(mulv)(mat2s m, vec2s v) {
X  vec2s r;
X  glm_mat2_mulv(m.raw, v.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief trace of matrix
X *
X * sum of the elements on the main diagonal from upper left to the lower right
X *
X * @param[in]  m matrix
X */
XCGLM_INLINE
Xfloat
Xglms_mat2_(trace)(mat2s m) {
X  return glm_mat2_trace(m.raw);
X}
X
X/*!
X * @brief scale (multiply with scalar) matrix
X *
X * multiply matrix with scalar
X *
X * @param[in, out] m matrix
X * @param[in]      s scalar
X * @returns matrix
X */
XCGLM_INLINE
Xmat2s
Xglms_mat2_(scale)(mat2s m, float s) {
X  glm_mat2_scale(m.raw, s);
X  return m;
X}
X
X/*!
X * @brief mat2 determinant
X *
X * @param[in] mat matrix
X *
X * @return determinant
X */
XCGLM_INLINE
Xfloat
Xglms_mat2_(det)(mat2s mat) {
X  return glm_mat2_det(mat.raw);
X}
X
X/*!
X * @brief inverse mat2 and store in dest
X *
X * @param[in]  mat  matrix
X * @returns matrix
X */
XCGLM_INLINE
Xmat2s
Xglms_mat2_(inv)(mat2s mat) {
X  mat2s r;
X  glm_mat2_inv(mat.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief swap two matrix columns
X *
X * @param[in] mat  matrix
X * @param[in] col1 col1
X * @param[in] col2 col2
X * @returns matrix
X */
XCGLM_INLINE
Xmat2s
Xglms_mat2_(swap_col)(mat2s mat, int col1, int col2) {
X  glm_mat2_swap_col(mat.raw, col1, col2);
X  return mat;
X}
X
X/*!
X * @brief swap two matrix rows
X *
X * @param[in] mat  matrix
X * @param[in] row1 row1
X * @param[in] row2 row2
X * @returns matrix
X */
XCGLM_INLINE
Xmat2s
Xglms_mat2_(swap_row)(mat2s mat, int row1, int row2) {
X  glm_mat2_swap_row(mat.raw, row1, row2);
X  return mat;
X}
X
X/*!
X * @brief helper for  R (row vector) * M (matrix) * C (column vector)
X *
X * rmc stands for Row * Matrix * Column
X *
X * the result is scalar because R * M = Matrix1x2 (row vector),
X * then Matrix1x2 * Vec2 (column vector) = Matrix1x1 (Scalar)
X *
X * @param[in]  r   row vector or matrix1x2
X * @param[in]  m   matrix2x2
X * @param[in]  c   column vector or matrix2x1
X *
X * @return scalar value e.g. Matrix1x1
X */
XCGLM_INLINE
Xfloat
Xglms_mat2_(rmc)(vec2s r, mat2s m, vec2s c) {
X  return glm_mat2_rmc(r.raw, m.raw, c.raw);
X}
X
X/*!
X * @brief Create mat2 matrix from pointer
X *
X * @param[in]  src  pointer to an array of floats
X * @return constructed matrix from raw pointer
X */
XCGLM_INLINE
Xmat2s
Xglms_mat2_(make)(float * __restrict src) {
X  mat2s r;
X  glm_mat2_make(src, r.raw);
X  return r;
X}
X
X#endif /* cglms_mat2_h */
cadcf99b50ea8b6be5af44e58ccf2c62
echo x - cglm/struct/mat2x3.h
sed 's/^X//' >cglm/struct/mat2x3.h << 'd5cc76dece792b80449cf7d44941190d'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Macros:
X   GLMS_MAT2X3_ZERO_INIT
X   GLMS_MAT2X3_ZERO
X
X Functions:
X   CGLM_INLINE mat2x3s glms_mat2x3_zero(void);
X   CGLM_INLINE mat2x3s glms_mat2x3_make(float * __restrict src);
X   CGLM_INLINE mat2s   glms_mat2x3_mul(mat2x3s m1, mat3x2s m2);
X   CGLM_INLINE vec2s   glms_mat2x3_mulv(mat2x3s m, vec3s v);
X   CGLM_INLINE mat3x2s glms_mat2x3_transpose(mat2x3s m);
X   CGLM_INLINE mat2x3s glms_mat2x3_scale(mat2x3s m, float s);
X */
X
X#ifndef cglms_mat2x3_h
X#define cglms_mat2x3_h
X
X#include "../common.h"
X#include "../types-struct.h"
X#include "../mat2x3.h"
X
X/* api definition */
X#define glms_mat2x3_(NAME) CGLM_STRUCTAPI(mat2x3, NAME)
X
X#define GLMS_MAT2X3_ZERO_INIT {GLM_MAT2X3_ZERO_INIT}
X
X/* for C only */
X#define GLMS_MAT2X3_ZERO ((mat2x3s)GLMS_MAT2X3_ZERO_INIT)
X
X/*!
X * @brief make given matrix zero.
X *
X * @param[in, out]  mat  matrix
X */
XCGLM_INLINE
Xmat2x3s
Xglms_mat2x3_(zero)(void) {
X  mat2x3s r;
X  glm_mat2x3_zero(r.raw);
X  return r;
X}
X
X/*!
X * @brief Create mat2x3 matrix from pointer
X *
X * @param[in]  src  pointer to an array of floats
X * @return constructed matrix from raw pointer
X */
XCGLM_INLINE
Xmat2x3s
Xglms_mat2x3_(make)(float * __restrict src) {
X  mat2x3s r;
X  glm_mat2x3_make(src, r.raw);
X  return r;
X}
X
X/*!
X * @brief multiply m1 and m2 to dest
X *
X * @code
X * r = glms_mat2x3_mul(mat2x3s, mat3x2s);
X * @endcode
X *
X * @param[in]  m1   left matrix (mat2x3s)
X * @param[in]  m2   right matrix (mat3x2s)
X * @returns destination matrix (mat2s)
X */
XCGLM_INLINE
Xmat2s
Xglms_mat2x3_(mul)(mat2x3s m1, mat3x2s m2) {
X  mat2s r;
X  glm_mat2x3_mul(m1.raw, m2.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief multiply matrix with column vector and store in dest vector
X *
X * @param[in]  m    matrix (left)
X * @param[in]  v    vector (right, column vector)
X * @param[out] dest result vector
X */
XCGLM_INLINE
Xvec2s
Xglms_mat2x3_(mulv)(mat2x3s m, vec3s v) {
X  vec2s r;
X  glm_mat2x3_mulv(m.raw, v.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief transpose matrix and store in dest
X *
X * @param[in]  m     matrix
X * @param[out] dest  result
X */
XCGLM_INLINE
Xmat3x2s
Xglms_mat2x3_(transpose)(mat2x3s m) {
X  mat3x2s r;
X  glm_mat2x3_transpose(m.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief scale (multiply with scalar) matrix
X *
X * multiply matrix with scalar
X *
X * @param[in, out] m matrix
X * @param[in]    s scalar
X */
XCGLM_INLINE
Xmat2x3s
Xglms_mat2x3_(scale)(mat2x3s m, float s) {
X  glm_mat2x3_scale(m.raw, s);
X  return m;
X}
X
X#endif /* cglms_mat2x3_h */
d5cc76dece792b80449cf7d44941190d
echo x - cglm/struct/mat2x4.h
sed 's/^X//' >cglm/struct/mat2x4.h << '88b08a26c2bf12513fbf42edfff69470'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Macros:
X   GLMS_MAT2X4_ZERO_INIT
X   GLMS_MAT2X4_ZERO
X
X Functions:
X   CGLM_INLINE mat2x4s glms_mat2x4_zero(void);
X   CGLM_INLINE mat2x4s glms_mat2x4_make(float * __restrict src);
X   CGLM_INLINE mat2s   glms_mat2x4_mul(mat2x4s m1, mat4x2s m2);
X   CGLM_INLINE vec2s   glms_mat2x4_mulv(mat2x4s m, vec4s v);
X   CGLM_INLINE mat4x2s glms_mat2x4_transpose(mat2x4s m);
X   CGLM_INLINE mat2x4s glms_mat2x4_scale(mat2x4s m, float s);
X */
X
X#ifndef cglms_mat2x4_h
X#define cglms_mat2x4_h
X
X#include "../common.h"
X#include "../types-struct.h"
X#include "../mat2x4.h"
X
X/* api definition */
X#define glms_mat2x4_(NAME) CGLM_STRUCTAPI(mat2x4, NAME)
X
X#define GLMS_MAT2X4_ZERO_INIT {GLM_MAT2X4_ZERO_INIT}
X
X/* for C only */
X#define GLMS_MAT2X4_ZERO ((mat2x4s)GLMS_MAT2X4_ZERO_INIT)
X
X/*!
X * @brief make given matrix zero.
X *
X * @param[in, out]  mat  matrix
X */
XCGLM_INLINE
Xmat2x4s
Xglms_mat2x4_(zero)(void) {
X  mat2x4s r;
X  glm_mat2x4_zero(r.raw);
X  return r;
X}
X
X/*!
X * @brief Create mat2x4 matrix from pointer
X *
X * @param[in]  src  pointer to an array of floats
X * @return constructed matrix from raw pointer
X */
XCGLM_INLINE
Xmat2x4s
Xglms_mat2x4_(make)(float * __restrict src) {
X  mat2x4s r;
X  glm_mat2x4_make(src, r.raw);
X  return r;
X}
X
X/*!
X * @brief multiply m1 and m2 to dest
X *
X * @code
X * r = glms_mat2x4_mul(mat2x4s, mat4x2s);
X * @endcode
X *
X * @param[in]  m1   left matrix (mat2x4s)
X * @param[in]  m2   right matrix (mat4x2s)
X * @returns destination matrix (mat2s)
X */
XCGLM_INLINE
Xmat2s
Xglms_mat2x4_(mul)(mat2x4s m1, mat4x2s m2) {
X  mat2s r;
X  glm_mat2x4_mul(m1.raw, m2.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief multiply matrix with column vector and store in dest vector
X *
X * @param[in]  m    matrix (left)
X * @param[in]  v    vector (right, column vector)
X * @param[out] dest result vector
X */
XCGLM_INLINE
Xvec2s
Xglms_mat2x4_(mulv)(mat2x4s m, vec4s v) {
X  vec2s r;
X  glm_mat2x4_mulv(m.raw, v.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief transpose matrix and store in dest
X *
X * @param[in]  m     matrix
X * @param[out] dest  result
X */
XCGLM_INLINE
Xmat4x2s
Xglms_mat2x4_(transpose)(mat2x4s m) {
X  mat4x2s r;
X  glm_mat2x4_transpose(m.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief scale (multiply with scalar) matrix
X *
X * multiply matrix with scalar
X *
X * @param[in, out] m matrix
X * @param[in]    s scalar
X */
XCGLM_INLINE
Xmat2x4s
Xglms_mat2x4_(scale)(mat2x4s m, float s) {
X  glm_mat2x4_scale(m.raw, s);
X  return m;
X}
X
X#endif /* cglms_mat2x4_h */
88b08a26c2bf12513fbf42edfff69470
echo x - cglm/struct/affine-pre.h
sed 's/^X//' >cglm/struct/affine-pre.h << '07c3fc7300550b29d04fa061d4f29b1e'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Functions:
X   CGLM_INLINE mat4s glms_translate(mat4s m, vec3s v);
X   CGLM_INLINE mat4s glms_translate_x(mat4s m, float x);
X   CGLM_INLINE mat4s glms_translate_y(mat4s m, float y);
X   CGLM_INLINE mat4s glms_translate_z(mat4s m, float z);
X   CGLM_INLINE mat4s glms_rotate_x(mat4s m, float angle);
X   CGLM_INLINE mat4s glms_rotate_y(mat4s m, float angle);
X   CGLM_INLINE mat4s glms_rotate_z(mat4s m, float angle);
X   CGLM_INLINE mat4s glms_rotate(mat4s m, float angle, vec3s axis);
X   CGLM_INLINE mat4s glms_rotate_at(mat4s m, vec3s pivot, float angle, vec3s axis);
X   CGLM_INLINE mat4s glms_spin(mat4s m, float angle, vec3s axis);
X */
X
X#ifndef cglms_affines_pre_h
X#define cglms_affines_pre_h
X
X#include "../common.h"
X#include "../types-struct.h"
X#include "../affine.h"
X#include "vec3.h"
X#include "vec4.h"
X#include "mat4.h"
X
X/*!
X * @brief translate existing transform matrix by v vector
X *        and stores result in same matrix
X *
X * @param[in]       m   affine transfrom
X * @param[in]       v   translate vector [x, y, z]
X * @returns             affine transfrom
X */
XCGLM_INLINE
Xmat4s
Xglms_translate(mat4s m, vec3s v) {
X  glm_translate(m.raw, v.raw);
X  return m;
X}
X
X/*!
X * @brief translate existing transform matrix by x factor
X *
X * @param[in]       m   affine transfrom
X * @param[in]       x   x factor
X * @returns             affine transfrom
X */
XCGLM_INLINE
Xmat4s
Xglms_translate_x(mat4s m, float x) {
X  glm_translate_x(m.raw, x);
X  return m;
X}
X
X/*!
X * @brief translate existing transform matrix by y factor
X *
X * @param[in]       m   affine transfrom
X * @param[in]       y   y factor
X * @returns             affine transfrom
X */
XCGLM_INLINE
Xmat4s
Xglms_translate_y(mat4s m, float y) {
X  glm_translate_y(m.raw, y);
X  return m;
X}
X
X/*!
X * @brief translate existing transform matrix by z factor
X *
X * @param[in]       m   affine transfrom
X * @param[in]       z   z factor
X * @returns             affine transfrom
X */
XCGLM_INLINE
Xmat4s
Xglms_translate_z(mat4s m, float z) {
X  glm_translate_z(m.raw, z);
X  return m;
X}
X
X/*!
X * @brief rotate existing transform matrix around X axis by angle
X *        and store result in dest
X *
X * @param[in]   m       affine transfrom
X * @param[in]   angle   angle (radians)
X * @returns             rotated matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_rotate_x(mat4s m, float angle) {
X  mat4s r;
X  glm_rotate_x(m.raw, angle, r.raw);
X  return r;
X}
X
X/*!
X * @brief rotate existing transform matrix around Y axis by angle
X *        and store result in dest
X *
X * @param[in]   m       affine transfrom
X * @param[in]   angle   angle (radians)
X * @returns             rotated matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_rotate_y(mat4s m, float angle) {
X  mat4s r;
X  glm_rotate_y(m.raw, angle, r.raw);
X  return r;
X}
X
X/*!
X * @brief rotate existing transform matrix around Z axis by angle
X *        and store result in dest
X *
X * @param[in]   m       affine transfrom
X * @param[in]   angle   angle (radians)
X * @returns             rotated matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_rotate_z(mat4s m, float angle) {
X  mat4s r;
X  glm_rotate_z(m.raw, angle, r.raw);
X  return r;
X}
X
X/*!
X * @brief rotate existing transform matrix around given axis by angle
X *
X * @param[in]       m       affine transfrom
X * @param[in]       angle   angle (radians)
X * @param[in]       axis    axis
X * @returns                affine transfrom
X */
XCGLM_INLINE
Xmat4s
Xglms_rotate(mat4s m, float angle, vec3s axis) {
X  glm_rotate(m.raw, angle, axis.raw);
X  return m;
X}
X
X/*!
X * @brief rotate existing transform
X *        around given axis by angle at given pivot point (rotation center)
X *
X * @param[in]       m       affine transfrom
X * @param[in]       pivot   rotation center
X * @param[in]       angle   angle (radians)
X * @param[in]       axis    axis
X * @returns                 affine transfrom
X */
XCGLM_INLINE
Xmat4s
Xglms_rotate_at(mat4s m, vec3s pivot, float angle, vec3s axis) {
X  glm_rotate_at(m.raw, pivot.raw, angle, axis.raw);
X  return m;
X}
X
X/*!
X * @brief rotate existing transform matrix around given axis by angle around self (doesn't affected by position)
X *
X * @param[in]       m       affine transfrom
X * @param[in]       angle   angle (radians)
X * @param[in]       axis    axis
X * @returns                affine transfrom
X */
XCGLM_INLINE
Xmat4s
Xglms_spin(mat4s m, float angle, vec3s axis) {
X  glm_spin(m.raw, angle, axis.raw);
X  return m;
X}
X
X#endif /* cglms_affines_pre_h */
07c3fc7300550b29d04fa061d4f29b1e
echo x - cglm/struct/affine-post.h
sed 's/^X//' >cglm/struct/affine-post.h << 'ebb4bc282dcd88406154f5764b4f7a87'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Functions:
X   CGLM_INLINE mat4s glms_translated(mat4s m, vec3s v);
X   CGLM_INLINE mat4s glms_translated_x(mat4s m, float x);
X   CGLM_INLINE mat4s glms_translated_y(mat4s m, float y);
X   CGLM_INLINE mat4s glms_translated_z(mat4s m, float z);
X   CGLM_INLINE mat4s glms_rotated_x(mat4s m, float angle);
X   CGLM_INLINE mat4s glms_rotated_y(mat4s m, float angle);
X   CGLM_INLINE mat4s glms_rotated_z(mat4s m, float angle);
X   CGLM_INLINE mat4s glms_rotated(mat4s m, float angle, vec3s axis);
X   CGLM_INLINE mat4s glms_rotated_at(mat4s m, vec3s pivot, float angle, vec3s axis);
X   CGLM_INLINE mat4s glms_spinned(mat4s m, float angle, vec3s axis);
X */
X
X#ifndef cglms_affines_post_h
X#define cglms_affines_post_h
X
X#include "../common.h"
X#include "../types-struct.h"
X#include "../affine.h"
X#include "vec3.h"
X#include "vec4.h"
X#include "mat4.h"
X
X/*!
X * @brief translate existing transform matrix by v vector
X *        and stores result in same matrix
X *
X * @param[in]       m   affine transfrom
X * @param[in]       v   translate vector [x, y, z]
X * @returns             affine transfrom
X */
XCGLM_INLINE
Xmat4s
Xglms_translated(mat4s m, vec3s v) {
X  glm_translated(m.raw, v.raw);
X  return m;
X}
X
X/*!
X * @brief translate existing transform matrix by x factor
X *
X * @param[in]       m   affine transfrom
X * @param[in]       x   x factor
X * @returns             affine transfrom
X */
XCGLM_INLINE
Xmat4s
Xglms_translated_x(mat4s m, float x) {
X  glm_translated_x(m.raw, x);
X  return m;
X}
X
X/*!
X * @brief translate existing transform matrix by y factor
X *
X * @param[in]       m   affine transfrom
X * @param[in]       y   y factor
X * @returns             affine transfrom
X */
XCGLM_INLINE
Xmat4s
Xglms_translated_y(mat4s m, float y) {
X  glm_translated_y(m.raw, y);
X  return m;
X}
X
X/*!
X * @brief translate existing transform matrix by z factor
X *
X * @param[in]       m   affine transfrom
X * @param[in]       z   z factor
X * @returns             affine transfrom
X */
XCGLM_INLINE
Xmat4s
Xglms_translated_z(mat4s m, float z) {
X  glm_translated_z(m.raw, z);
X  return m;
X}
X
X/*!
X * @brief rotate existing transform matrix around X axis by angle
X *        and store result in dest
X *
X * @param[in]   m       affine transfrom
X * @param[in]   angle   angle (radians)
X * @returns             rotated matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_rotated_x(mat4s m, float angle) {
X  mat4s r;
X  glm_rotated_x(m.raw, angle, r.raw);
X  return r;
X}
X
X/*!
X * @brief rotate existing transform matrix around Y axis by angle
X *        and store result in dest
X *
X * @param[in]   m       affine transfrom
X * @param[in]   angle   angle (radians)
X * @returns             rotated matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_rotated_y(mat4s m, float angle) {
X  mat4s r;
X  glm_rotated_y(m.raw, angle, r.raw);
X  return r;
X}
X
X/*!
X * @brief rotate existing transform matrix around Z axis by angle
X *        and store result in dest
X *
X * @param[in]   m       affine transfrom
X * @param[in]   angle   angle (radians)
X * @returns             rotated matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_rotated_z(mat4s m, float angle) {
X  mat4s r;
X  glm_rotated_z(m.raw, angle, r.raw);
X  return r;
X}
X
X/*!
X * @brief rotate existing transform matrix around given axis by angle
X *
X * @param[in]       m       affine transfrom
X * @param[in]       angle   angle (radians)
X * @param[in]       axis    axis
X * @returns                affine transfrom
X */
XCGLM_INLINE
Xmat4s
Xglms_rotated(mat4s m, float angle, vec3s axis) {
X  glm_rotated(m.raw, angle, axis.raw);
X  return m;
X}
X
X/*!
X * @brief rotate existing transform
X *        around given axis by angle at given pivot point (rotation center)
X *
X * @param[in]       m       affine transfrom
X * @param[in]       pivot   rotation center
X * @param[in]       angle   angle (radians)
X * @param[in]       axis    axis
X * @returns                 affine transfrom
X */
XCGLM_INLINE
Xmat4s
Xglms_rotated_at(mat4s m, vec3s pivot, float angle, vec3s axis) {
X  glm_rotated_at(m.raw, pivot.raw, angle, axis.raw);
X  return m;
X}
X
X/*!
X * @brief rotate existing transform matrix around given axis by angle around self (doesn't affected by position)
X *
X * @param[in]       m       affine transfrom
X * @param[in]       angle   angle (radians)
X * @param[in]       axis    axis
X * @returns                affine transfrom
X */
XCGLM_INLINE
Xmat4s
Xglms_spinned(mat4s m, float angle, vec3s axis) {
X  glm_spinned(m.raw, angle, axis.raw);
X  return m;
X}
X
X#endif /* cglms_affines_post_h */
ebb4bc282dcd88406154f5764b4f7a87
echo x - cglm/struct/affine-mat.h
sed 's/^X//' >cglm/struct/affine-mat.h << 'e4184d0dbe507ad8880610b996444d9a'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Functions:
X   CGLM_INLINE mat4s glms_mul(mat4 m1, mat4 m2);
X   CGLM_INLINE mat4s glms_mul_rot(mat4 m1, mat4 m2);
X   CGLM_INLINE mat4s glms_inv_tr();
X */
X
X#ifndef cglms_affine_mat_h
X#define cglms_affine_mat_h
X
X#include "../common.h"
X#include "../types-struct.h"
X#include "../affine-mat.h"
X#include "vec3.h"
X#include "vec4.h"
X#include "mat4.h"
X
X/*!
X * @brief this is similar to glms_mat4_mul but specialized to affine transform
X *
X * Matrix format should be:
X *   R  R  R  X
X *   R  R  R  Y
X *   R  R  R  Z
X *   0  0  0  W
X *
X * this reduces some multiplications. It should be faster than mat4_mul.
X * if you are not sure about matrix format then DON'T use this! use mat4_mul
X *
X * @param[in]   m1    affine matrix 1
X * @param[in]   m2    affine matrix 2
X * @returns         destination matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_mul(mat4s m1, mat4s m2){
X  mat4s r;
X  glm_mul(m1.raw, m2.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief this is similar to glm_mat4_mul but specialized to affine transform
X *
X * Right Matrix format should be:
X *   R  R  R  0
X *   R  R  R  0
X *   R  R  R  0
X *   0  0  0  1
X *
X * this reduces some multiplications. It should be faster than mat4_mul.
X * if you are not sure about matrix format then DON'T use this! use mat4_mul
X *
X * @param[in]   m1    affine matrix 1
X * @param[in]   m2    affine matrix 2
X * @returns         destination matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_mul_rot(mat4s m1, mat4s m2){
X  mat4s r;
X  glm_mul_rot(m1.raw, m2.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief inverse orthonormal rotation + translation matrix (ridig-body)
X *
X * @code
X * X = | R  T |   X' = | R' -R'T |
X *     | 0  1 |        | 0     1 |
X * @endcode
X *
X * @param[in]  m  matrix
X * @returns      destination matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_inv_tr(mat4s m){
X  glm_inv_tr(m.raw);
X  return m;
X}
X#endif /* cglms_affine_mat_h */
e4184d0dbe507ad8880610b996444d9a
echo x - cglm/struct/affine.h
sed 's/^X//' >cglm/struct/affine.h << 'e94591641a92571ad5097633a68da5b0'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Functions:
X   CGLM_INLINE mat4s glms_translate(mat4s m, vec3s v);
X   CGLM_INLINE mat4s glms_translate_x(mat4s m, float x);
X   CGLM_INLINE mat4s glms_translate_y(mat4s m, float y);
X   CGLM_INLINE mat4s glms_translate_z(mat4s m, float z);
X   CGLM_INLINE mat4s glms_translate_make(vec3s v);
X   CGLM_INLINE mat4s glms_scale_to(mat4s m, vec3s v);
X   CGLM_INLINE mat4s glms_scale_make(vec3s v);
X   CGLM_INLINE mat4s glms_scale(mat4s m, vec3s v);
X   CGLM_INLINE mat4s glms_scale_uni(mat4s m, float s);
X   CGLM_INLINE mat4s glms_rotate_x(mat4s m, float angle);
X   CGLM_INLINE mat4s glms_rotate_y(mat4s m, float angle);
X   CGLM_INLINE mat4s glms_rotate_z(mat4s m, float angle);
X   CGLM_INLINE mat4s glms_rotate_make(float angle, vec3s axis);
X   CGLM_INLINE mat4s glms_rotate(mat4s m, float angle, vec3s axis);
X   CGLM_INLINE mat4s glms_rotate_at(mat4s m, vec3s pivot, float angle, vec3s axis);
X   CGLM_INLINE mat4s glms_rotate_atm(mat4s m, vec3s pivot, float angle, vec3s axis);
X   CGLM_INLINE mat4s glms_spin(mat4s m, float angle, vec3s axis);
X   CGLM_INLINE vec3s glms_decompose_scalev(mat4s m);
X   CGLM_INLINE bool  glms_uniscaled(mat4s m);
X   CGLM_INLINE void  glms_decompose_rs(mat4s m, mat4s * r, vec3s * s);
X   CGLM_INLINE void  glms_decompose(mat4s m, vec4s t, mat4s * r, vec3s * s);
X */
X
X#ifndef cglms_affines_h
X#define cglms_affines_h
X
X#include "../common.h"
X#include "../types-struct.h"
X#include "../affine.h"
X#include "vec3.h"
X#include "vec4.h"
X#include "mat4.h"
X#include "affine-mat.h"
X
X/*!
X * @brief creates NEW translate transform matrix by v vector
X *
X * @param[in]   v   translate vector [x, y, z]
X * @returns         affine transfrom
X */
XCGLM_INLINE
Xmat4s
Xglms_translate_make(vec3s v) {
X  mat4s m;
X  glm_translate_make(m.raw, v.raw);
X  return m;
X}
X
X/*!
X * @brief creates NEW scale matrix by v vector
X *
X * @param[in]   v  scale vector [x, y, z]
X * @returns affine transfrom
X */
XCGLM_INLINE
Xmat4s
Xglms_scale_make(vec3s v) {
X  mat4s m;
X  glm_scale_make(m.raw, v.raw);
X  return m;
X}
X
X/*!
X * @brief scales existing transform matrix by v vector
X *        and stores result in same matrix
X *
X * @param[in]    m   affine transfrom
X * @param[in]    v   scale vector [x, y, z]
X * @returns          affine transfrom
X */
XCGLM_INLINE
Xmat4s
Xglms_scale(mat4s m, vec3s v) {
X  mat4s r;
X  glm_scale_to(m.raw, v.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief applies uniform scale to existing transform matrix v = [s, s, s]
X *        and stores result in same matrix
X *
X * @param[in]    m   affine transfrom
X * @param[in]    s   scale factor
X * @returns          affine transfrom
X */
XCGLM_INLINE
Xmat4s
Xglms_scale_uni(mat4s m, float s) {
X  glm_scale_uni(m.raw, s);
X  return m;
X}
X
X/*!
X * @brief creates NEW rotation matrix by angle and axis
X *
X * axis will be normalized so you don't need to normalize it
X *
X * @param[in]  angle  angle (radians)
X * @param[in]  axis   axis
X * @returns           affine transfrom
X */
XCGLM_INLINE
Xmat4s
Xglms_rotate_make(float angle, vec3s axis) {
X  mat4s m;
X  glm_rotate_make(m.raw, angle, axis.raw);
X  return m;
X}
X
X/*!
X * @brief creates NEW rotation matrix by angle and axis at given point
X *
X * this creates rotation matrix, it assumes you don't have a matrix
X *
X * this should work faster than glm_rotate_at because it reduces
X * one glm_translate.
X *
X * @param[in]  m      affine transfrom
X * @param[in]  pivot  rotation center
X * @param[in]  angle  angle (radians)
X * @param[in]  axis   axis
X * @returns           affine transfrom
X */
XCGLM_INLINE
Xmat4s
Xglms_rotate_atm(mat4s m, vec3s pivot, float angle, vec3s axis) {
X  glm_rotate_atm(m.raw, pivot.raw, angle, axis.raw);
X  return m;
X}
X
X/*!
X * @brief decompose scale vector
X *
X * @param[in]  m  affine transform
X * @returns       scale vector (Sx, Sy, Sz)
X */
XCGLM_INLINE
Xvec3s
Xglms_decompose_scalev(mat4s m) {
X  vec3s r;
X  glm_decompose_scalev(m.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief returns true if matrix is uniform scaled. This is helpful for
X *        creating normal matrix.
X *
X * @param[in] m m
X *
X * @return boolean
X */
XCGLM_INLINE
Xbool
Xglms_uniscaled(mat4s m) {
X  return glm_uniscaled(m.raw);
X}
X
X/*!
X * @brief decompose rotation matrix (mat4) and scale vector [Sx, Sy, Sz]
X *        DON'T pass projected matrix here
X *
X * @param[in]  m affine transform
X * @param[out] r rotation matrix
X * @param[out] s scale matrix
X */
XCGLM_INLINE
Xvoid
Xglms_decompose_rs(mat4s m, mat4s * __restrict r, vec3s * __restrict s) {
X  glm_decompose_rs(m.raw, r->raw, s->raw);
X}
X
X/*!
X * @brief decompose affine transform, TODO: extract shear factors.
X *        DON'T pass projected matrix here
X *
X * @param[in]  m affine transfrom
X * @param[out] t translation vector
X * @param[out] r rotation matrix (mat4)
X * @param[out] s scaling vector [X, Y, Z]
X */
XCGLM_INLINE
Xvoid
Xglms_decompose(mat4s m, vec4s * __restrict t, mat4s * __restrict r, vec3s * __restrict s) {
X  glm_decompose(m.raw, t->raw, r->raw, s->raw);
X}
X
X#include "affine-pre.h"
X#include "affine-post.h"
X
X#endif /* cglms_affines_h */
e94591641a92571ad5097633a68da5b0
echo x - cglm/struct/affine2d.h
sed 's/^X//' >cglm/struct/affine2d.h << 'a72174a5e181d4c9403a13225713e9db'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Functions:
X   CGLM_INLINE mat3s glms_translate2d(mat3 m, vec2 v)
X   CGLM_INLINE mat3s glms_translate2d_x(mat3s m, float x)
X   CGLM_INLINE mat3s glms_translate2d_y(mat3s m, float y)
X   CGLM_INLINE mat3s glms_translate2d_make(vec2s v)
X   CGLM_INLINE mat3s glms_scale2d_make(vec2s v)
X   CGLM_INLINE mat3s glms_scale2d(mat3s m, vec2s v)
X   CGLM_INLINE mat3s glms_scale2d_uni(mat3s m, float s)
X   CGLM_INLINE mat3s glms_rotate2d_make(float angle)
X   CGLM_INLINE mat3s glms_rotate2d(mat3s m, float angle)
X   CGLM_INLINE mat3s glms_rotate2d_to(mat3s m, float angle)
X */
X
X#ifndef cglms_affine2ds_h
X#define cglms_affine2ds_h
X
X#include "../common.h"
X#include "../types-struct.h"
X#include "../affine2d.h"
X#include "vec3.h"
X#include "mat3.h"
X
X/*!
X * @brief translate existing 2d transform matrix by v vector
X *        and stores result in same matrix
X *
X * @param[in] m  affine transfrom
X * @param[in] v  translate vector [x, y]
X * @returns      affine transfrom
X */
XCGLM_INLINE
Xmat3s
Xglms_translate2d(mat3s m, vec2s v) {
X  glm_translate2d(m.raw, v.raw);
X  return m;
X}
X
X/*!
X * @brief translate existing 2d transform matrix by x factor
X *
X * @param[in] m  affine transfrom
X * @param[in] x  x factor
X * @returns      affine transfrom
X */
XCGLM_INLINE
Xmat3s
Xglms_translate2d_x(mat3s m, float x) {
X  glm_translate2d_x(m.raw, x);
X  return m;
X}
X
X/*!
X * @brief translate existing 2d transform matrix by y factor
X *
X * @param[in] m  affine transfrom
X * @param[in] y  y factor
X * @returns      affine transfrom
X */
XCGLM_INLINE
Xmat3s
Xglms_translate2d_y(mat3s m, float y) {
X  glm_translate2d_y(m.raw, y);
X  return m;
X}
X
X/*!
X * @brief creates NEW translate 2d transform matrix by v vector
X *
X * @param[in] v  translate vector [x, y]
X * @returns      affine transfrom
X */
XCGLM_INLINE
Xmat3s
Xglms_translate2d_make(vec2s v) {
X  mat3s m;
X  glm_translate2d_make(m.raw, v.raw);
X  return m;
X}
X
X/*!
X * @brief creates NEW 2d scale matrix by v vector
X *
X * @param[in]   v  scale vector [x, y]
X * @returns affine transfrom
X */
XCGLM_INLINE
Xmat3s
Xglms_scale2d_make(vec2s v) {
X  mat3s m;
X  glm_scale2d_make(m.raw, v.raw);
X  return m;
X}
X
X/*!
X * @brief scales existing 2d transform matrix by v vector
X *        and stores result in same matrix
X *
X * @param[in]  m  affine transfrom
X * @param[in]  v  scale vector [x, y, z]
X * @returns       affine transfrom
X */
XCGLM_INLINE
Xmat3s
Xglms_scale2d(mat3s m, vec2s v) {
X  mat3s r;
X  glm_scale2d_to(m.raw, v.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief applies uniform scale to existing 2d transform matrix v = [s, s, s]
X *        and stores result in same matrix
X *
X * @param[in] m  affine transfrom
X * @param[in] s  scale factor
X * @returns      affine transfrom
X */
XCGLM_INLINE
Xmat3s
Xglms_scale2d_uni(mat3s m, float s) {
X  glm_scale2d_uni(m.raw, s);
X  return m;
X}
X
X/*!
X * @brief creates NEW 2d rotation matrix by angle and axis
X *
X * axis will be normalized so you don't need to normalize it
X *
X * @param[in]  angle  angle (radians)
X * @returns           affine transfrom
X */
XCGLM_INLINE
Xmat3s
Xglms_rotate2d_make(float angle) {
X  mat3s m;
X  glm_rotate2d_make(m.raw, angle);
X  return m;
X}
X
X/*!
X * @brief rotate existing 2d transform matrix around given axis by angle
X *
X * @param[in] m      affine transfrom
X * @param[in] angle  angle (radians)
X * @returns          affine transfrom
X */
XCGLM_INLINE
Xmat3s
Xglms_rotate2d(mat3s m, float angle) {
X  glm_rotate2d(m.raw, angle);
X  return m;
X}
X
X/*!
X * @brief rotate existing 2d transform matrix around given axis by angle
X *
X * @param[in] m      affine transfrom
X * @param[in] angle  angle (radians)
X * @returns          affine transfrom
X */
XCGLM_INLINE
Xmat3s
Xglms_rotate2d_to(mat3s m, float angle) {
X  glm_rotate2d(m.raw, angle);
X  return m;
X}
X
X#endif /* cglms_affine2ds_h */
a72174a5e181d4c9403a13225713e9db
echo x - cglm/struct/vec2.h
sed 's/^X//' >cglm/struct/vec2.h << 'a1a66918be58eb5ffcb91da0ed261034'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Macros:
X   GLMS_VEC2_ONE_INIT
X   GLMS_VEC2_ZERO_INIT
X   GLMS_VEC2_ONE
X   GLMS_VEC2_ZERO
X
X Functions:
X   CGLM_INLINE vec2s glms_vec2(vec3s v3)
X   CGLM_INLINE void  glms_vec2_pack(vec2s dst[], vec2 src[], size_t len)
X   CGLM_INLINE void  glms_vec2_unpack(vec2 dst[], vec2s src[], size_t len)
X   CGLM_INLINE vec2s glms_vec2_zero(void)
X   CGLM_INLINE vec2s glms_vec2_one(void)
X   CGLM_INLINE float glms_vec2_dot(vec2s a, vec2s b)
X   CGLM_INLINE float glms_vec2_cross(vec2s a, vec2s b)
X   CGLM_INLINE float glms_vec2_norm2(vec2s v)
X   CGLM_INLINE float glms_vec2_norm(vec2s v)
X   CGLM_INLINE vec2s glms_vec2_add(vec2s a, vec2s b)
X   CGLM_INLINE vec2s glms_vec2_adds(vec2s a, float s)
X   CGLM_INLINE vec2s glms_vec2_sub(vec2s a, vec2s b)
X   CGLM_INLINE vec2s glms_vec2_subs(vec2s a, float s)
X   CGLM_INLINE vec2s glms_vec2_mul(vec2s a, vec2s b)
X   CGLM_INLINE vec2s glms_vec2_scale(vec2s v, float s)
X   CGLM_INLINE vec2s glms_vec2_scale_as(vec2s v, float s)
X   CGLM_INLINE vec2s glms_vec2_div(vec2s a, vec2s b)
X   CGLM_INLINE vec2s glms_vec2_divs(vec2s a, float s)
X   CGLM_INLINE vec2s glms_vec2_addadd(vec2s a, vec2s b, vec2s dest)
X   CGLM_INLINE vec2s glms_vec2_subadd(vec2s a, vec2s b, vec2s dest)
X   CGLM_INLINE vec2s glms_vec2_muladd(vec2s a, vec2s b, vec2s dest)
X   CGLM_INLINE vec2s glms_vec2_muladds(vec2s a, float s, vec2s dest)
X   CGLM_INLINE vec2s glms_vec2_maxadd(vec2s a, vec2s b, vec2s dest)
X   CGLM_INLINE vec2s glms_vec2_minadd(vec2s a, vec2s b, vec2s dest)
X   CGLM_INLINE vec2s glms_vec2_subsub(vec2s a, vec2s b, vec2s dest)
X   CGLM_INLINE vec2s glms_vec2_addsub(vec2s a, vec2s b, vec2s dest)
X   CGLM_INLINE vec2s glms_vec2_mulsub(vec2s a, vec2s b, vec2s dest)
X   CGLM_INLINE vec2s glms_vec2_mulsubs(vec2s a, float s, vec2s dest)
X   CGLM_INLINE vec2s glms_vec2_maxsub(vec2s a, vec2s b, vec2s dest)
X   CGLM_INLINE vec2s glms_vec2_minsub(vec2s a, vec2s b, vec2s dest)
X   CGLM_INLINE vec2s glms_vec2_negate(vec2s v)
X   CGLM_INLINE vec2s glms_vec2_normalize(vec2s v)
X   CGLM_INLINE vec2s glms_vec2_rotate(vec2s v, float angle, vec2s axis)
X   CGLM_INLINE vec2s glms_vec2_center(vec2s a, vec2s b)
X   CGLM_INLINE float glms_vec2_distance(vec2s a, vec2s b)
X   CGLM_INLINE float glms_vec2_distance2(vec2s a, vec2s b)
X   CGLM_INLINE vec2s glms_vec2_maxv(vec2s a, vec2s b)
X   CGLM_INLINE vec2s glms_vec2_minv(vec2s a, vec2s b)
X   CGLM_INLINE vec2s glms_vec2_clamp(vec2s v, float minVal, float maxVal)
X   CGLM_INLINE vec2s glms_vec2_lerp(vec2s from, vec2s to, float t)
X   CGLM_INLINE vec2s glms_vec2_make(float * restrict src)
X */
X
X#ifndef cglms_vec2s_h
X#define cglms_vec2s_h
X
X#include "../common.h"
X#include "../types-struct.h"
X#include "../util.h"
X#include "../vec2.h"
X#include "vec2-ext.h"
X
X#define GLMS_VEC2_ONE_INIT   {GLM_VEC2_ONE_INIT}
X#define GLMS_VEC2_ZERO_INIT  {GLM_VEC2_ZERO_INIT}
X
X#define GLMS_VEC2_ONE  ((vec2s)GLMS_VEC2_ONE_INIT)
X#define GLMS_VEC2_ZERO ((vec2s)GLMS_VEC2_ZERO_INIT)
X
X/*!
X * @brief init vec2 using vec2
X *
X * @param[in]  v3   vector3
X * @returns         destination
X */
XCGLM_INLINE
Xvec2s
Xglms_vec2(vec3s v3) {
X  vec2s r;
X  glm_vec2(v3.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief pack an array of vec2 into an array of vec2s
X *
X * @param[out] dst array of vec2
X * @param[in]  src array of vec2s
X * @param[in]  len number of elements
X */
XCGLM_INLINE
Xvoid
Xglms_vec2_(pack)(vec2s dst[], vec2 src[], size_t len) {
X  size_t i;
X
X  for (i = 0; i < len; i++) {
X    glm_vec2_copy(src[i], dst[i].raw);
X  }
X}
X
X/*!
X * @brief unpack an array of vec2s into an array of vec2
X *
X * @param[out] dst array of vec2s
X * @param[in]  src array of vec2
X * @param[in]  len number of elements
X */
XCGLM_INLINE
Xvoid
Xglms_vec2_(unpack)(vec2 dst[], vec2s src[], size_t len) {
X  size_t i;
X
X  for (i = 0; i < len; i++) {
X    glm_vec2_copy(src[i].raw, dst[i]);
X  }
X}
X
X/*!
X * @brief make vector zero
X *
X * @returns zero vector
X */
XCGLM_INLINE
Xvec2s
Xglms_vec2_(zero)(void) {
X  vec2s r;
X  glm_vec2_zero(r.raw);
X  return r;
X}
X
X/*!
X * @brief make vector one
X *
X * @returns one vector
X */
XCGLM_INLINE
Xvec2s
Xglms_vec2_(one)(void) {
X  vec2s r;
X  glm_vec2_one(r.raw);
X  return r;
X}
X
X/*!
X * @brief vec2 dot product
X *
X * @param[in] a vector1
X * @param[in] b vector2
X *
X * @return dot product
X */
XCGLM_INLINE
Xfloat
Xglms_vec2_(dot)(vec2s a, vec2s b) {
X  return glm_vec2_dot(a.raw, b.raw);
X}
X
X/*!
X * @brief vec2 cross product
X *
X * REF: http://allenchou.net/2013/07/cross-product-of-2d-vectors/
X *
X * @param[in]  a vector1
X * @param[in]  b vector2
X *
X * @return Z component of cross product
X */
XCGLM_INLINE
Xfloat
Xglms_vec2_(cross)(vec2s a, vec2s b) {
X  return glm_vec2_cross(a.raw, b.raw);
X}
X
X/*!
X * @brief norm * norm (magnitude) of vec
X *
X * we can use this func instead of calling norm * norm, because it would call
X * sqrtf fuction twice but with this func we can avoid func call, maybe this is
X * not good name for this func
X *
X * @param[in] v vector
X *
X * @return norm * norm
X */
XCGLM_INLINE
Xfloat
Xglms_vec2_(norm2)(vec2s v) {
X  return glm_vec2_norm2(v.raw);
X}
X
X/*!
X * @brief norm (magnitude) of vec2
X *
X * @param[in] v vector
X *
X * @return norm
X */
XCGLM_INLINE
Xfloat
Xglms_vec2_(norm)(vec2s v) {
X  return glm_vec2_norm(v.raw);
X}
X
X/*!
X * @brief add a vector to b vector store result in dest
X *
X * @param[in]  a    vector1
X * @param[in]  b    vector2
X * @returns         destination vector
X */
XCGLM_INLINE
Xvec2s
Xglms_vec2_(add)(vec2s a, vec2s b) {
X  vec2s r;
X  glm_vec2_add(a.raw, b.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief add scalar to v vector store result in dest (d = v + s)
X *
X * @param[in]  a    vector
X * @param[in]  s    scalar
X * @returns         destination vector
X */
XCGLM_INLINE
Xvec2s
Xglms_vec2_(adds)(vec2s a, float s) {
X  vec2s r;
X  glm_vec2_adds(a.raw, s, r.raw);
X  return r;
X}
X
X/*!
X * @brief subtract b vector from a vector store result in dest
X *
X * @param[in]  a    vector1
X * @param[in]  b    vector2
X * @returns         destination vector
X */
XCGLM_INLINE
Xvec2s
Xglms_vec2_(sub)(vec2s a, vec2s b) {
X  vec2s r;
X  glm_vec2_sub(a.raw, b.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief subtract scalar from v vector store result in dest (d = v - s)
X *
X * @param[in]  a    vector
X * @param[in]  s    scalar
X * @returns         destination vector
X */
XCGLM_INLINE
Xvec2s
Xglms_vec2_(subs)(vec2s a, float s) {
X  vec2s r;
X  glm_vec2_subs(a.raw, s, r.raw);
X  return r;
X}
X
X/*!
X * @brief multiply two vectors (component-wise multiplication)
X *
X * @param     a     vector1
X * @param     b     vector2
X * @returns         result = (a[0] * b[0], a[1] * b[1])
X */
XCGLM_INLINE
Xvec2s
Xglms_vec2_(mul)(vec2s a, vec2s b) {
X  vec2s r;
X  glm_vec2_mul(a.raw, b.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief multiply/scale vec2 vector with scalar: result = v * s
X *
X * @param[in]  v    vector
X * @param[in]  s    scalar
X * @returns         destination vector
X */
XCGLM_INLINE
Xvec2s
Xglms_vec2_(scale)(vec2s v, float s) {
X  vec2s r;
X  glm_vec2_scale(v.raw, s, r.raw);
X  return r;
X}
X
X/*!
X * @brief make vec2 vector scale as specified: result = unit(v) * s
X *
X * @param[in]  v    vector
X * @param[in]  s    scalar
X * @returns         destination vector
X */
XCGLM_INLINE
Xvec2s
Xglms_vec2_(scale_as)(vec2s v, float s) {
X  vec2s r;
X  glm_vec2_scale_as(v.raw, s, r.raw);
X  return r;
X}
X
X/*!
X * @brief div vector with another component-wise division: d = a / b
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @returns         result = (a[0]/b[0], a[1]/b[1])
X */
XCGLM_INLINE
Xvec2s
Xglms_vec2_(div)(vec2s a, vec2s b) {
X  vec2s r;
X  glm_vec2_div(a.raw, b.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief div vector with scalar: d = v / s
X *
X * @param[in]  a    vector
X * @param[in]  s    scalar
X * @returns         result = (a[0]/s, a[1]/s)
X */
XCGLM_INLINE
Xvec2s
Xglms_vec2_(divs)(vec2s a, float s) {
X  vec2s r;
X  glm_vec2_divs(a.raw, s, r.raw);
X  return r;
X}
X
X/*!
X * @brief add two vectors and add result to sum
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @returns         dest += (a + b)
X */
XCGLM_INLINE
Xvec2s
Xglms_vec2_(addadd)(vec2s a, vec2s b, vec2s dest) {
X  glm_vec2_addadd(a.raw, b.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief sub two vectors and add result to dest
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @returns         dest += (a + b)
X */
XCGLM_INLINE
Xvec2s
Xglms_vec2_(subadd)(vec2s a, vec2s b, vec2s dest) {
X  glm_vec2_subadd(a.raw, b.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief mul two vectors and add result to dest
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @returns         dest += (a * b)
X */
XCGLM_INLINE
Xvec2s
Xglms_vec2_(muladd)(vec2s a, vec2s b, vec2s dest) {
X  glm_vec2_muladd(a.raw, b.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief mul vector with scalar and add result to sum
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector
X * @param[in]  s    scalar
X * @returns         dest += (a * b)
X */
XCGLM_INLINE
Xvec2s
Xglms_vec2_(muladds)(vec2s a, float s, vec2s dest) {
X  glm_vec2_muladds(a.raw, s, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief add max of two vectors to result/dest
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @returns         dest += max(a, b)
X */
XCGLM_INLINE
Xvec2s
Xglms_vec2_(maxadd)(vec2s a, vec2s b, vec2s dest) {
X  glm_vec2_maxadd(a.raw, b.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief add min of two vectors to result/dest
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @returns         dest += min(a, b)
X */
XCGLM_INLINE
Xvec2s
Xglms_vec2_(minadd)(vec2s a, vec2s b, vec2s dest) {
X  glm_vec2_minadd(a.raw, b.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief sub two vectors and sub result to dest
X *
X * it applies -= operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @returns         dest -= (a - b)
X */
XCGLM_INLINE
Xvec2s
Xglms_vec2_(subsub)(vec2s a, vec2s b, vec2s dest) {
X  glm_vec2_subsub(a.raw, b.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief add two vectors and sub result to dest
X *
X * it applies -= operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @returns         dest -= (a + b)
X */
XCGLM_INLINE
Xvec2s
Xglms_vec2_(addsub)(vec2s a, vec2s b, vec2s dest) {
X  glm_vec2_addsub(a.raw, b.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief mul two vectors and sub result to dest
X *
X * it applies -= operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @returns         dest -= (a * b)
X */
XCGLM_INLINE
Xvec2s
Xglms_vec2_(mulsub)(vec2s a, vec2s b, vec2s dest) {
X  glm_vec2_mulsub(a.raw, b.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief mul vector with scalar and sub result to dest
X *
X * it applies -= operator so dest must be initialized
X *
X * @param[in]  a    vector
X * @param[in]  s    scalar
X * @returns         dest -= (a * b)
X */
XCGLM_INLINE
Xvec2s
Xglms_vec2_(mulsubs)(vec2s a, float s, vec2s dest) {
X  glm_vec2_mulsubs(a.raw, s, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief sub max of two vectors to dest
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @returns         dest -= max(a, b)
X */
XCGLM_INLINE
Xvec2s
Xglms_vec2_(maxsub)(vec2s a, vec2s b, vec2s dest) {
X  glm_vec2_maxsub(a.raw, b.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief sub min of two vectors to dest
X *
X * it applies -= operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @returns         dest -= min(a, b)
X */
XCGLM_INLINE
Xvec2s
Xglms_vec2_(minsub)(vec2s a, vec2s b, vec2s dest) {
X  glm_vec2_minsub(a.raw, b.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief negate vector components
X *
X * @param[in]  v  vector
X * @returns       negated vector
X */
XCGLM_INLINE
Xvec2s
Xglms_vec2_(negate)(vec2s v) {
X  glm_vec2_negate(v.raw);
X  return v;
X}
X
X/*!
X * @brief normalize vec2 and store result in same vec
X *
X * @param[in] v vector
X * @returns     normalized vector
X */
XCGLM_INLINE
Xvec2s
Xglms_vec2_(normalize)(vec2s v) {
X  glm_vec2_normalize(v.raw);
X  return v;
X}
X
X/*!
X * @brief rotate vec2 by angle using Rodrigues' rotation formula
X *
X * @param[in]     v     vector
X * @param[in]     angle angle by radians
X * @returns             rotated vector
X */
XCGLM_INLINE
Xvec2s
Xglms_vec2_(rotate)(vec2s v, float angle) {
X  vec2s r;
X  glm_vec2_rotate(v.raw, angle, r.raw);
X  return r;
X}
X
X/**
X * @brief find center point of two vector
X *
X * @param[in]  a    vector1
X * @param[in]  b    vector2
X * @returns         center point
X */
XCGLM_INLINE
Xvec2s
Xglms_vec2_(center)(vec2s a, vec2s b) {
X  vec2s r;
X  glm_vec2_center(a.raw, b.raw, r.raw);
X  return r;
X}
X
X/**
X * @brief distance between two vectors
X *
X * @param[in] a vector1
X * @param[in] b vector2
X * @return      distance
X */
XCGLM_INLINE
Xfloat
Xglms_vec2_(distance)(vec2s a, vec2s b) {
X  return glm_vec2_distance(a.raw, b.raw);
X}
X
X/**
X * @brief squared distance between two vectors
X *
X * @param[in] a vector1
X * @param[in] b vector2
X * @return      squared distance (distance * distance)
X */
XCGLM_INLINE
Xfloat
Xglms_vec2_(distance2)(vec2s a, vec2s b) {
X  return glm_vec2_distance2(a.raw, b.raw);
X}
X
X/*!
X * @brief max values of vectors
X *
X * @param[in]  a    vector1
X * @param[in]  b    vector2
X * @returns         destination
X */
XCGLM_INLINE
Xvec2s
Xglms_vec2_(maxv)(vec2s a, vec2s b) {
X  vec2s r;
X  glm_vec2_maxv(a.raw, b.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief min values of vectors
X *
X * @param[in]  a    vector1
X * @param[in]  b    vector2
X * @returns         destination
X */
XCGLM_INLINE
Xvec2s
Xglms_vec2_(minv)(vec2s a, vec2s b) {
X  vec2s r;
X  glm_vec2_minv(a.raw, b.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief clamp vector's individual members between min and max values
X *
X * @param[in]       v       vector
X * @param[in]       minVal  minimum value
X * @param[in]       maxVal  maximum value
X * @returns                 clamped vector
X */
XCGLM_INLINE
Xvec2s
Xglms_vec2_(clamp)(vec2s v, float minVal, float maxVal) {
X  glm_vec2_clamp(v.raw, minVal, maxVal);
X  return v;
X}
X
X/*!
X * @brief linear interpolation between two vectors
X *
X * formula:  from + s * (to - from)
X *
X * @param[in]   from  from value
X * @param[in]   to    to value
X * @param[in]   t     interpolant (amount)
X * @returns           destination
X */
XCGLM_INLINE
Xvec2s
Xglms_vec2_(lerp)(vec2s from, vec2s to, float t) {
X  vec2s r;
X  glm_vec2_lerp(from.raw, to.raw, t, r.raw);
X  return r;
X}
X
X/*!
X * @brief Create two dimensional vector from pointer
X *
X * @param[in]  src  pointer to an array of floats
X * @returns constructed 2D vector from raw pointer
X */
XCGLM_INLINE
Xvec2s
Xglms_vec2_(make)(float * __restrict src) {
X  vec2s dest;
X  glm_vec2_make(src, dest.raw);
X  return dest;
X}
X
X#endif /* cglms_vec2s_h */
a1a66918be58eb5ffcb91da0ed261034
echo x - cglm/struct/vec2-ext.h
sed 's/^X//' >cglm/struct/vec2-ext.h << '9fe7ebdb3cc161e6eb07c95c77540fca'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*!
X * @brief SIMD like functions
X */
X
X/*
X Functions:
X   CGLM_INLINE vec2s glms_vec2_fill(float val)
X   CGLM_INLINE bool  glms_vec2_eq(vec2s v, float val)
X   CGLM_INLINE bool  glms_vec2_eq_eps(vec2s v, float val)
X   CGLM_INLINE bool  glms_vec2_eq_all(vec2s v)
X   CGLM_INLINE bool  glms_vec2_eqv(vec2s a, vec2s b)
X   CGLM_INLINE bool  glms_vec2_eqv_eps(vec2s a, vec2s b)
X   CGLM_INLINE float glms_vec2_max(vec2s v)
X   CGLM_INLINE float glms_vec2_min(vec2s v)
X   CGLM_INLINE bool  glms_vec2_isnan(vec2s v)
X   CGLM_INLINE bool  glms_vec2_isinf(vec2s v)
X   CGLM_INLINE bool  glms_vec2_isvalid(vec2s v)
X   CGLM_INLINE vec2s glms_vec2_sign(vec2s v)
X   CGLM_INLINE vec2s glms_vec2_sqrt(vec2s v)
X */
X
X#ifndef cglms_vec2s_ext_h
X#define cglms_vec2s_ext_h
X
X#include "../common.h"
X#include "../types-struct.h"
X#include "../util.h"
X#include "../vec2-ext.h"
X
X/* api definition */
X#define glms_vec2_(NAME) CGLM_STRUCTAPI(vec2, NAME)
X
X/*!
X * @brief fill a vector with specified value
X *
X * @param[in]  val  value
X * @returns         dest
X */
XCGLM_INLINE
Xvec2s
Xglms_vec2_(fill)(float val) {
X  vec2s r;
X  glm_vec2_fill(r.raw, val);
X  return r;
X}
X
X/*!
X * @brief check if vector is equal to value (without epsilon)
X *
X * @param[in] v   vector
X * @param[in] val value
X */
XCGLM_INLINE
Xbool
Xglms_vec2_(eq)(vec2s v, float val) {
X  return glm_vec2_eq(v.raw, val);
X}
X
X/*!
X * @brief check if vector is equal to value (with epsilon)
X *
X * @param[in] v   vector
X * @param[in] val value
X */
XCGLM_INLINE
Xbool
Xglms_vec2_(eq_eps)(vec2s v, float val) {
X  return glm_vec2_eq_eps(v.raw, val);
X}
X
X/*!
X * @brief check if vector members are equal (without epsilon)
X *
X * @param[in] v   vector
X */
XCGLM_INLINE
Xbool
Xglms_vec2_(eq_all)(vec2s v) {
X  return glm_vec2_eq_all(v.raw);
X}
X
X/*!
X * @brief check if vector is equal to another (without epsilon)
X *
X * @param[in] a vector
X * @param[in] b vector
X */
XCGLM_INLINE
Xbool
Xglms_vec2_(eqv)(vec2s a, vec2s b) {
X  return glm_vec2_eqv(a.raw, b.raw);
X}
X
X/*!
X * @brief check if vector is equal to another (with epsilon)
X *
X * @param[in] a vector
X * @param[in] b vector
X */
XCGLM_INLINE
Xbool
Xglms_vec2_(eqv_eps)(vec2s a, vec2s b) {
X  return glm_vec2_eqv_eps(a.raw, b.raw);
X}
X
X/*!
X * @brief max value of vector
X *
X * @param[in] v vector
X */
XCGLM_INLINE
Xfloat
Xglms_vec2_(max)(vec2s v) {
X  return glm_vec2_max(v.raw);
X}
X
X/*!
X * @brief min value of vector
X *
X * @param[in] v vector
X */
XCGLM_INLINE
Xfloat
Xglms_vec2_min(vec2s v) {
X  return glm_vec2_min(v.raw);
X}
X
X/*!
X * @brief check if all items are NaN (not a number)
X *        you should only use this in DEBUG mode or very critical asserts
X *
X * @param[in] v vector
X */
XCGLM_INLINE
Xbool
Xglms_vec2_(isnan)(vec2s v) {
X  return glm_vec2_isnan(v.raw);
X}
X
X/*!
X * @brief check if all items are INFINITY
X *        you should only use this in DEBUG mode or very critical asserts
X *
X * @param[in] v vector
X */
XCGLM_INLINE
Xbool
Xglms_vec2_(isinf)(vec2s v) {
X  return glm_vec2_isinf(v.raw);
X}
X
X/*!
X * @brief check if all items are valid number
X *        you should only use this in DEBUG mode or very critical asserts
X *
X * @param[in] v vector
X */
XCGLM_INLINE
Xbool
Xglms_vec2_isvalid(vec2s v) {
X  return glm_vec2_isvalid(v.raw);
X}
X
X/*!
X * @brief get sign of 32 bit float as +1, -1, 0
X *
X * Important: It returns 0 for zero/NaN input
X *
X * @param   v   vector
X * @returns     sign vector
X */
XCGLM_INLINE
Xvec2s
Xglms_vec2_(sign)(vec2s v) {
X  vec2s r;
X  glm_vec2_sign(v.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief square root of each vector item
X *
X * @param[in]  v    vector
X * @returns         destination vector
X */
XCGLM_INLINE
Xvec2s
Xglms_vec2_(sqrt)(vec2s v) {
X  vec2s r;
X  glm_vec2_sqrt(v.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief treat vectors as complex numbers and multiply them as such.
X *
X * @param[in]  a    left number
X * @param[in]  b    right number
X * @param[out] dest destination number
X */
XCGLM_INLINE
Xvec2s
Xglms_vec2_(complex_mul)(vec2s a, vec2s b, vec2s dest) {
X  glm_vec2_complex_mul(a.raw, b.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief treat vectors as complex numbers and divide them as such.
X *
X * @param[in]  a    left number (numerator)
X * @param[in]  b    right number (denominator)
X * @param[out] dest destination number
X */
XCGLM_INLINE
Xvec2s
Xglms_vec2_(complex_div)(vec2s a, vec2s b, vec2s dest) {
X  glm_vec2_complex_div(a.raw, b.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief treat the vector as a complex number and conjugate it as such.
X *
X * @param[in]  a    the number
X * @param[out] dest destination number
X */
XCGLM_INLINE
Xvec2s
Xglms_vec2_(complex_conjugate)(vec2s a, vec2s dest) {
X  glm_vec2_complex_conjugate(a.raw, dest.raw);
X  return dest;
X}
X
X#endif /* cglms_vec2s_ext_h */
9fe7ebdb3cc161e6eb07c95c77540fca
echo x - cglm/struct/vec3.h
sed 's/^X//' >cglm/struct/vec3.h << '2b28b2853bd04cae97aa27342ff40c44'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Macros:
X   GLMS_VEC3_ONE_INIT
X   GLMS_VEC3_ZERO_INIT
X   GLMS_VEC3_ONE
X   GLMS_VEC3_ZERO
X   GLMS_YUP
X   GLMS_ZUP
X   GLMS_XUP
X
X Functions:
X   CGLM_INLINE vec3s glms_vec3(vec4s v4);
X   CGLM_INLINE void  glms_vec3_pack(vec3s dst[], vec3 src[], size_t len);
X   CGLM_INLINE void  glms_vec3_unpack(vec3 dst[], vec3s src[], size_t len);
X   CGLM_INLINE vec3s glms_vec3_zero(void);
X   CGLM_INLINE vec3s glms_vec3_one(void);
X   CGLM_INLINE float glms_vec3_dot(vec3s a, vec3s b);
X   CGLM_INLINE float glms_vec3_norm2(vec3s v);
X   CGLM_INLINE float glms_vec3_norm(vec3s v);
X   CGLM_INLINE float glms_vec3_norm_one(vec3s v);
X   CGLM_INLINE float glms_vec3_norm_inf(vec3s v);
X   CGLM_INLINE vec3s glms_vec3_add(vec3s a, vec3s b);
X   CGLM_INLINE vec3s glms_vec3_adds(vec3s a, float s);
X   CGLM_INLINE vec3s glms_vec3_sub(vec3s a, vec3s b);
X   CGLM_INLINE vec3s glms_vec3_subs(vec3s a, float s);
X   CGLM_INLINE vec3s glms_vec3_mul(vec3s a, vec3s b);
X   CGLM_INLINE vec3s glms_vec3_scale(vec3s v, float s);
X   CGLM_INLINE vec3s glms_vec3_scale_as(vec3s v, float s);
X   CGLM_INLINE vec3s glms_vec3_div(vec3s a, vec3s b);
X   CGLM_INLINE vec3s glms_vec3_divs(vec3s a, float s);
X   CGLM_INLINE vec3s glms_vec3_addadd(vec3s a, vec3s b, vec3s dest);
X   CGLM_INLINE vec3s glms_vec3_subadd(vec3s a, vec3s b, vec3s dest);
X   CGLM_INLINE vec3s glms_vec3_muladd(vec3s a, vec3s b, vec3s dest);
X   CGLM_INLINE vec3s glms_vec3_muladds(vec3s a, float s, vec3s dest);
X   CGLM_INLINE vec3s glms_vec3_maxadd(vec3s a, vec3s b, vec3s dest);
X   CGLM_INLINE vec3s glms_vec3_minadd(vec3s a, vec3s b, vec3s dest);
X   CGLM_INLINE vec3s glms_vec3_subsub(vec3s a, vec3s b, vec3s dest);
X   CGLM_INLINE vec3s glms_vec3_addsub(vec3s a, vec3s b, vec3s dest);
X   CGLM_INLINE vec3s glms_vec3_mulsub(vec3s a, vec3s b, vec3s dest);
X   CGLM_INLINE vec3s glms_vec3_mulsubs(vec3s a, float s, vec3s dest);
X   CGLM_INLINE vec3s glms_vec3_maxsub(vec3s a, vec3s b, vec3s dest);
X   CGLM_INLINE vec3s glms_vec3_minsub(vec3s a, vec3s b, vec3s dest);
X   CGLM_INLINE vec3s glms_vec3_flipsign(vec3s v);
X   CGLM_INLINE vec3s glms_vec3_negate(vec3s v);
X   CGLM_INLINE vec3s glms_vec3_normalize(vec3s v);
X   CGLM_INLINE vec3s glms_vec3_cross(vec3s a, vec3s b);
X   CGLM_INLINE vec3s glms_vec3_crossn(vec3s a, vec3s b);
X   CGLM_INLINE float glms_vec3_angle(vec3s a, vec3s b);
X   CGLM_INLINE vec3s glms_vec3_rotate(vec3s v, float angle, vec3s axis);
X   CGLM_INLINE vec3s glms_vec3_rotate_m4(mat4s m, vec3s v);
X   CGLM_INLINE vec3s glms_vec3_rotate_m3(mat3s m, vec3s v);
X   CGLM_INLINE vec3s glms_vec3_proj(vec3s a, vec3s b);
X   CGLM_INLINE vec3s glms_vec3_center(vec3s a, vec3s b);
X   CGLM_INLINE float glms_vec3_distance(vec3s a, vec3s b);
X   CGLM_INLINE float glms_vec3_distance2(vec3s a, vec3s b);
X   CGLM_INLINE vec3s glms_vec3_maxv(vec3s a, vec3s b);
X   CGLM_INLINE vec3s glms_vec3_minv(vec3s a, vec3s b);
X   CGLM_INLINE vec3s glms_vec3_ortho(vec3s v);
X   CGLM_INLINE vec3s glms_vec3_clamp(vec3s v, float minVal, float maxVal);
X   CGLM_INLINE vec3s glms_vec3_lerp(vec3s from, vec3s to, float t);
X   CGLM_INLINE vec3s glms_vec3_lerpc(vec3s from, vec3s to, float t);
X   CGLM_INLINE vec3s glms_vec3_mix(vec3s from, vec3s to, float t);
X   CGLM_INLINE vec3s glms_vec3_mixc(vec3s from, vec3s to, float t);
X   CGLM_INLINE vec3s glms_vec3_step_uni(float edge, vec3s x);
X   CGLM_INLINE vec3s glms_vec3_step(vec3s edge, vec3s x);
X   CGLM_INLINE vec3s glms_vec3_smoothstep_uni(float edge0, float edge1, vec3s x);
X   CGLM_INLINE vec3s glms_vec3_smoothstep(vec3s edge0, vec3s edge1, vec3s x);
X   CGLM_INLINE vec3s glms_vec3_smoothinterp(vec3s from, vec3s to, float t);
X   CGLM_INLINE vec3s glms_vec3_smoothinterpc(vec3s from, vec3s to, float t);
X   CGLM_INLINE vec3s glms_vec3_swizzle(vec3s v, int mask);
X   CGLM_INLINE vec3s glms_vec3_make(float * restrict src);
X
X Convenient:
X   CGLM_INLINE vec3s glms_cross(vec3s a, vec3s b);
X   CGLM_INLINE float glms_dot(vec3s a, vec3s b);
X   CGLM_INLINE vec3s glms_normalize(vec3s v);
X */
X
X#ifndef cglms_vec3s_h
X#define cglms_vec3s_h
X
X#include "../common.h"
X#include "../types-struct.h"
X#include "../util.h"
X#include "../vec3.h"
X#include "vec3-ext.h"
X
X#define GLMS_VEC3_ONE_INIT   {GLM_VEC3_ONE_INIT}
X#define GLMS_VEC3_ZERO_INIT  {GLM_VEC3_ZERO_INIT}
X
X#define GLMS_VEC3_ONE  ((vec3s)GLMS_VEC3_ONE_INIT)
X#define GLMS_VEC3_ZERO ((vec3s)GLMS_VEC3_ZERO_INIT)
X
X#define GLMS_YUP  ((vec3s){{0.0f, 1.0f, 0.0f}})
X#define GLMS_ZUP  ((vec3s){{0.0f, 0.0f, 1.0f}})
X#define GLMS_XUP  ((vec3s){{1.0f, 0.0f, 0.0f}})
X
X/*!
X * @brief init vec3 using vec4
X *
X * @param[in]  v4   vector4
X * @returns         destination
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3(vec4s v4) {
X  vec3s r;
X  glm_vec3(v4.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief pack an array of vec3 into an array of vec3s
X *
X * @param[out] dst array of vec3
X * @param[in]  src array of vec3s
X * @param[in]  len number of elements
X */
XCGLM_INLINE
Xvoid
Xglms_vec3_(pack)(vec3s dst[], vec3 src[], size_t len) {
X  size_t i;
X
X  for (i = 0; i < len; i++) {
X    glm_vec3_copy(src[i], dst[i].raw);
X  }
X}
X
X/*!
X * @brief unpack an array of vec3s into an array of vec3
X *
X * @param[out] dst array of vec3s
X * @param[in]  src array of vec3
X * @param[in]  len number of elements
X */
XCGLM_INLINE
Xvoid
Xglms_vec3_(unpack)(vec3 dst[], vec3s src[], size_t len) {
X  size_t i;
X
X  for (i = 0; i < len; i++) {
X    glm_vec3_copy(src[i].raw, dst[i]);
X  }
X}
X
X/*!
X * @brief make vector zero
X *
X * @returns       zero vector
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_(zero)(void) {
X  vec3s r;
X  glm_vec3_zero(r.raw);
X  return r;
X}
X
X/*!
X * @brief make vector one
X *
X * @returns       one vector
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_(one)(void) {
X  vec3s r;
X  glm_vec3_one(r.raw);
X  return r;
X}
X
X/*!
X * @brief vec3 dot product
X *
X * @param[in] a vector1
X * @param[in] b vector2
X *
X * @return dot product
X */
XCGLM_INLINE
Xfloat
Xglms_vec3_(dot)(vec3s a, vec3s b) {
X  return glm_vec3_dot(a.raw, b.raw);
X}
X
X/*!
X * @brief norm * norm (magnitude) of vec
X *
X * we can use this func instead of calling norm * norm, because it would call
X * sqrtf fuction twice but with this func we can avoid func call, maybe this is
X * not good name for this func
X *
X * @param[in] v vector
X *
X * @return norm * norm
X */
XCGLM_INLINE
Xfloat
Xglms_vec3_(norm2)(vec3s v) {
X  return glm_vec3_norm2(v.raw);
X}
X
X/*!
X * @brief norm (magnitude) of vec3
X *
X * @param[in] v vector
X *
X * @return norm
X */
XCGLM_INLINE
Xfloat
Xglms_vec3_(norm)(vec3s v) {
X  return glm_vec3_norm(v.raw);
X}
X
X/*!
X * @brief L1 norm of vec3
X * Also known as Manhattan Distance or Taxicab norm.
X * L1 Norm is the sum of the magnitudes of the vectors in a space.
X * It is calculated as the sum of the absolute values of the vector components.
X * In this norm, all the components of the vector are weighted equally.
X *
X * This computes:
X * R = |v[0]| + |v[1]| + |v[2]|
X *
X * @param[in] v vector
X *
X * @return L1 norm
X */
XCGLM_INLINE
Xfloat
Xglms_vec3_(norm_one)(vec3s v) {
X  return glm_vec3_norm_one(v.raw);
X}
X
X/*!
X * @brief Infinity norm of vec3
X * Also known as Maximum norm.
X * Infinity Norm is the largest magnitude among each element of a vector.
X * It is calculated as the maximum of the absolute values of the vector components.
X *
X * This computes:
X * inf norm = max(|v[0]|, |v[1]|, |v[2]|)
X *
X * @param[in] v vector
X *
X * @return Infinity norm
X */
XCGLM_INLINE
Xfloat
Xglms_vec3_(norm_inf)(vec3s v) {
X  return glm_vec3_norm_inf(v.raw);
X}
X
X/*!
X * @brief add a vector to b vector store result in dest
X *
X * @param[in]  a    vector1
X * @param[in]  b    vector2
X * @returns         destination vector
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_(add)(vec3s a, vec3s b) {
X  vec3s r;
X  glm_vec3_add(a.raw, b.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief add scalar to v vector store result in dest (d = v + s)
X *
X * @param[in]  a    vector
X * @param[in]  s    scalar
X * @returns         destination vector
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_(adds)(vec3s a, float s) {
X  vec3s r;
X  glm_vec3_adds(a.raw, s, r.raw);
X  return r;
X}
X
X/*!
X * @brief subtract b vector from a vector store result in dest
X *
X * @param[in]  a    vector1
X * @param[in]  b    vector2
X * @returns         destination vector
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_(sub)(vec3s a, vec3s b) {
X  vec3s r;
X  glm_vec3_sub(a.raw, b.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief subtract scalar from v vector store result in dest (d = v - s)
X *
X * @param[in]  a    vector
X * @param[in]  s    scalar
X * @returns         destination vector
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_(subs)(vec3s a, float s) {
X  vec3s r;
X  glm_vec3_subs(a.raw, s, r.raw);
X  return r;
X}
X
X/*!
X * @brief multiply two vectors (component-wise multiplication)
X *
X * @param     a     vector1
X * @param     b     vector2
X * @returns         v3 = (a[0] * b[0], a[1] * b[1], a[2] * b[2])
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_(mul)(vec3s a, vec3s b) {
X  vec3s r;
X  glm_vec3_mul(a.raw, b.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief multiply/scale vec3 vector with scalar: result = v * s
X *
X * @param[in]  v    vector
X * @param[in]  s    scalar
X * @returns         destination vector
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_(scale)(vec3s v, float s) {
X  vec3s r;
X  glm_vec3_scale(v.raw, s, r.raw);
X  return r;
X}
X
X/*!
X * @brief make vec3 vector scale as specified: result = unit(v) * s
X *
X * @param[in]  v    vector
X * @param[in]  s    scalar
X * @returns         destination vector
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_(scale_as)(vec3s v, float s) {
X  vec3s r;
X  glm_vec3_scale_as(v.raw, s, r.raw);
X  return r;
X}
X
X/*!
X * @brief div vector with another component-wise division: d = a / b
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @returns         result = (a[0]/b[0], a[1]/b[1], a[2]/b[2])
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_(div)(vec3s a, vec3s b) {
X  vec3s r;
X  glm_vec3_div(a.raw, b.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief div vector with scalar: d = v / s
X *
X * @param[in]  a    vector
X * @param[in]  s    scalar
X * @returns         result = (a[0]/s, a[1]/s, a[2]/s)
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_(divs)(vec3s a, float s) {
X  vec3s r;
X  glm_vec3_divs(a.raw, s, r.raw);
X  return r;
X}
X
X/*!
X * @brief add two vectors and add result to sum
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @returns         dest += (a + b)
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_(addadd)(vec3s a, vec3s b, vec3s dest) {
X  glm_vec3_addadd(a.raw, b.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief sub two vectors and add result to dest
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @returns         dest += (a + b)
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_(subadd)(vec3s a, vec3s b, vec3s dest) {
X  glm_vec3_subadd(a.raw, b.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief mul two vectors and add result to dest
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @returns         dest += (a * b)
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_(muladd)(vec3s a, vec3s b, vec3s dest) {
X  glm_vec3_muladd(a.raw, b.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief mul vector with scalar and add result to sum
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector
X * @param[in]  s    scalar
X * @returns         dest += (a * b)
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_(muladds)(vec3s a, float s, vec3s dest) {
X  glm_vec3_muladds(a.raw, s, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief add max of two vectors to result/dest
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @returns         dest += max(a, b)
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_(maxadd)(vec3s a, vec3s b, vec3s dest) {
X  glm_vec3_maxadd(a.raw, b.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief add min of two vectors to result/dest
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @returns         dest += min(a, b)
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_(minadd)(vec3s a, vec3s b, vec3s dest) {
X  glm_vec3_minadd(a.raw, b.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief sub two vectors and sub result to dest
X *
X * it applies -= operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @returns         dest -= (a - b)
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_(subsub)(vec3s a, vec3s b, vec3s dest) {
X  glm_vec3_subsub(a.raw, b.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief add two vectors and sub result to dest
X *
X * it applies -= operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @returns         dest -= (a + b)
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_(addsub)(vec3s a, vec3s b, vec3s dest) {
X  glm_vec3_addsub(a.raw, b.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief mul two vectors and sub result to dest
X *
X * it applies -= operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @returns         dest -= (a * b)
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_(mulsub)(vec3s a, vec3s b, vec3s dest) {
X  glm_vec3_mulsub(a.raw, b.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief mul vector with scalar and sub result to dest
X *
X * it applies -= operator so dest must be initialized
X *
X * @param[in]  a    vector
X * @param[in]  s    scalar
X * @returns         dest -= (a * b)
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_(mulsubs)(vec3s a, float s, vec3s dest) {
X  glm_vec3_mulsubs(a.raw, s, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief sub max of two vectors to dest
X *
X * it applies -= operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @returns         dest -= max(a, b)
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_(maxsub)(vec3s a, vec3s b, vec3s dest) {
X  glm_vec3_maxsub(a.raw, b.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief sub min of two vectors to dest
X *
X * it applies -= operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @returns         dest -= min(a, b)
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_(minsub)(vec3s a, vec3s b, vec3s dest) {
X  glm_vec3_minsub(a.raw, b.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief negate vector components and store result in dest
X *
X * @param[in]   v     vector
X * @returns           result vector
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_(flipsign)(vec3s v) {
X  glm_vec3_flipsign(v.raw);
X  return v;
X}
X
X/*!
X * @brief negate vector components
X *
X * @param[in]  v  vector
X * @returns       negated vector
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_(negate)(vec3s v) {
X  glm_vec3_negate(v.raw);
X  return v;
X}
X
X/*!
X * @brief normalize vec3 and store result in same vec
X *
X * @param[in] v vector
X * @returns     normalized vector
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_(normalize)(vec3s v) {
X  glm_vec3_normalize(v.raw);
X  return v;
X}
X
X/*!
X * @brief cross product of two vector (RH)
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @returns         destination
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_(cross)(vec3s a, vec3s b) {
X  vec3s r;
X  glm_vec3_cross(a.raw, b.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief cross product of two vector (RH) and normalize the result
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @returns         destination
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_(crossn)(vec3s a, vec3s b) {
X  vec3s r;
X  glm_vec3_crossn(a.raw, b.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief angle betwen two vector
X *
X * @param[in] a  vector1
X * @param[in] b  vector2
X *
X * @return angle as radians
X */
XCGLM_INLINE
Xfloat
Xglms_vec3_(angle)(vec3s a, vec3s b) {
X  return glm_vec3_angle(a.raw, b.raw);
X}
X
X/*!
X * @brief rotate vec3 around axis by angle using Rodrigues' rotation formula
X *
X * @param[in]     v     vector
X * @param[in]     axis  axis vector (must be unit vector)
X * @param[in]     angle angle by radians
X * @returns             rotated vector
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_(rotate)(vec3s v, float angle, vec3s axis) {
X  glm_vec3_rotate(v.raw, angle, axis.raw);
X  return v;
X}
X
X/*!
X * @brief apply rotation matrix to vector
X *
X *  matrix format should be (no perspective):
X *   a  b  c  x
X *   e  f  g  y
X *   i  j  k  z
X *   0  0  0  w
X *
X * @param[in]  m    affine matrix or rot matrix
X * @param[in]  v    vector
X * @returns         rotated vector
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_(rotate_m4)(mat4s m, vec3s v) {
X  vec3s r;
X  glm_vec3_rotate_m4(m.raw, v.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief apply rotation matrix to vector
X *
X * @param[in]  m    affine matrix or rot matrix
X * @param[in]  v    vector
X * @returns         rotated vector
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_(rotate_m3)(mat3s m, vec3s v) {
X  vec3s r;
X  glm_vec3_rotate_m3(m.raw, v.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief project a vector onto b vector
X *
X * @param[in]  a    vector1
X * @param[in]  b    vector2
X * @returns         projected vector
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_(proj)(vec3s a, vec3s b) {
X  vec3s r;
X  glm_vec3_proj(a.raw, b.raw, r.raw);
X  return r;
X}
X
X/**
X * @brief find center point of two vector
X *
X * @param[in]  a    vector1
X * @param[in]  b    vector2
X * @returns         center point
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_(center)(vec3s a, vec3s b) {
X  vec3s r;
X  glm_vec3_center(a.raw, b.raw, r.raw);
X  return r;
X}
X
X/**
X * @brief distance between two vectors
X *
X * @param[in] a vector1
X * @param[in] b vector2
X * @return      distance
X */
XCGLM_INLINE
Xfloat
Xglms_vec3_(distance)(vec3s a, vec3s b) {
X  return glm_vec3_distance(a.raw, b.raw);
X}
X
X/**
X * @brief squared distance between two vectors
X *
X * @param[in] a vector1
X * @param[in] b vector2
X * @return      squared distance (distance * distance)
X */
XCGLM_INLINE
Xfloat
Xglms_vec3_(distance2)(vec3s a, vec3s b) {
X  return glm_vec3_distance2(a.raw, b.raw);
X}
X
X/*!
X * @brief max values of vectors
X *
X * @param[in]  a    vector1
X * @param[in]  b    vector2
X * @returns         destination
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_(maxv)(vec3s a, vec3s b) {
X  vec3s r;
X  glm_vec3_maxv(a.raw, b.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief min values of vectors
X *
X * @param[in]  a    vector1
X * @param[in]  b    vector2
X * @returns         destination
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_(minv)(vec3s a, vec3s b) {
X  vec3s r;
X  glm_vec3_minv(a.raw, b.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief possible orthogonal/perpendicular vector
X *
X * @param[in]  v    vector
X * @returns         orthogonal/perpendicular vector
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_(ortho)(vec3s v) {
X  vec3s r;
X  glm_vec3_ortho(v.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief clamp vector's individual members between min and max values
X *
X * @param[in]       v       vector
X * @param[in]       minVal  minimum value
X * @param[in]       maxVal  maximum value
X * @returns                 clamped vector
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_(clamp)(vec3s v, float minVal, float maxVal) {
X  glm_vec3_clamp(v.raw, minVal, maxVal);
X  return v;
X}
X
X/*!
X * @brief linear interpolation between two vectors
X *
X * formula:  from + s * (to - from)
X *
X * @param[in]   from  from value
X * @param[in]   to    to value
X * @param[in]   t     interpolant (amount)
X * @returns           destination
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_(lerp)(vec3s from, vec3s to, float t) {
X  vec3s r;
X  glm_vec3_lerp(from.raw, to.raw, t, r.raw);
X  return r;
X}
X
X/*!
X * @brief linear interpolation between two vectors (clamped)
X *
X * formula:  from + s * (to - from)
X *
X * @param[in]   from  from value
X * @param[in]   to    to value
X * @param[in]   t     interpolant (amount) clamped between 0 and 1
X * @returns           destination
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_(lerpc)(vec3s from, vec3s to, float t) {
X  vec3s r;
X  glm_vec3_lerpc(from.raw, to.raw, t, r.raw);
X  return r;
X}
X
X/*!
X * @brief linear interpolation between two vectors
X *
X * formula:  from + s * (to - from)
X *
X * @param[in]   from  from value
X * @param[in]   to    to value
X * @param[in]   t     interpolant (amount)
X * @returns           destination
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_(mix)(vec3s from, vec3s to, float t) {
X  vec3s r;
X  glm_vec3_mix(from.raw, to.raw, t, r.raw);
X  return r;
X}
X
X/*!
X * @brief linear interpolation between two vectors (clamped)
X *
X * formula:  from + s * (to - from)
X *
X * @param[in]   from  from value
X * @param[in]   to    to value
X * @param[in]   t     interpolant (amount) clamped between 0 and 1
X * @returns           destination
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_(mixc)(vec3s from, vec3s to, float t) {
X  vec3s r;
X  glm_vec3_mixc(from.raw, to.raw, t, r.raw);
X  return r;
X}
X
X/*!
X * @brief threshold function (unidimensional)
X *
X * @param[in]   edge    threshold
X * @param[in]   x       value to test against threshold
X * @returns             0.0 if x < edge, else 1.0
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_(step_uni)(float edge, vec3s x) {
X  vec3s r;
X  glm_vec3_step_uni(edge, x.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief threshold function
X *
X * @param[in]   edge    threshold
X * @param[in]   x       value to test against threshold
X * @returns             0.0 if x < edge, else 1.0
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_(step)(vec3s edge, vec3s x) {
X  vec3s r;
X  glm_vec3_step(edge.raw, x.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief threshold function with a smooth transition (unidimensional)
X *
X * @param[in]   edge0   low threshold
X * @param[in]   edge1   high threshold
X * @param[in]   x       value to test against threshold
X * @returns             destination
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_(smoothstep_uni)(float edge0, float edge1, vec3s x) {
X  vec3s r;
X  glm_vec3_smoothstep_uni(edge0, edge1, x.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief threshold function with a smooth transition
X *
X * @param[in]   edge0   low threshold
X * @param[in]   edge1   high threshold
X * @param[in]   x       value to test against threshold
X * @returns             destination
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_(smoothstep)(vec3s edge0, vec3s edge1, vec3s x) {
X  vec3s r;
X  glm_vec3_smoothstep(edge0.raw, edge1.raw, x.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief smooth Hermite interpolation between two vectors
X *
X * formula:  from + s * (to - from)
X *
X * @param[in]   from    from value
X * @param[in]   to      to value
X * @param[in]   t       interpolant (amount)
X * @returns             destination
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_(smoothinterp)(vec3s from, vec3s to, float t) {
X  vec3s r;
X  glm_vec3_smoothinterp(from.raw, to.raw, t, r.raw);
X  return r;
X}
X
X/*!
X * @brief smooth Hermite interpolation between two vectors (clamped)
X *
X * formula:  from + s * (to - from)
X *
X * @param[in]   from    from value
X * @param[in]   to      to value
X * @param[in]   t       interpolant (amount) clamped between 0 and 1
X * @returns             destination
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_(smoothinterpc)(vec3s from, vec3s to, float t) {
X  vec3s r;
X  glm_vec3_smoothinterpc(from.raw, to.raw, t, r.raw);
X  return r;
X}
X
X/*!
X * @brief vec3 cross product
X *
X * this is just convenient wrapper
X *
X * @param[in]  a  source 1
X * @param[in]  b  source 2
X * @returns       destination
X */
XCGLM_INLINE
Xvec3s
Xglms_cross(vec3s a, vec3s b) {
X  vec3s r;
X  glm_cross(a.raw, b.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief vec3 dot product
X *
X * this is just convenient wrapper
X *
X * @param[in] a vector1
X * @param[in] b vector2
X * @return      dot product
X */
XCGLM_INLINE
Xfloat
Xglms_dot(vec3s a, vec3s b) {
X  return glm_dot(a.raw, b.raw);
X}
X
X/*!
X * @brief normalize vec3 and store result in same vec
X *
X * this is just convenient wrapper
X *
X * @param[in]   v   vector
X * @returns         normalized vector
X */
XCGLM_INLINE
Xvec3s
Xglms_normalize(vec3s v) {
X  glm_normalize(v.raw);
X  return v;
X}
X
X/*!
X * @brief swizzle vector components
X *
X * you can use existin masks e.g. GLM_XXX, GLM_ZYX
X *
X * @param[in]  v    source
X * @param[in]  mask mask
X * @returns swizzled vector
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_(swizzle)(vec3s v, int mask) {
X  vec3s dest;
X  glm_vec3_swizzle(v.raw, mask, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief Create three dimensional vector from pointer
X *
X * @param[in]  src  pointer to an array of floats
X * @returns constructed 3D vector from raw pointer
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_(make)(float * __restrict src) {
X  vec3s dest;
X  glm_vec3_make(src, dest.raw);
X  return dest;
X}
X
X#endif /* cglms_vec3s_h */
2b28b2853bd04cae97aa27342ff40c44
echo x - cglm/struct/vec3-ext.h
sed 's/^X//' >cglm/struct/vec3-ext.h << 'e21395184c02ef8dd90484943a2eb658'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*!
X * @brief SIMD like functions
X */
X
X/*
X Functions:
X   CGLM_INLINE vec3s glms_vec3_broadcast(float val);
X   CGLM_INLINE vec3s glms_vec3_fill(float val);
X   CGLM_INLINE bool  glms_vec3_eq(vec3s v, float val);
X   CGLM_INLINE bool  glms_vec3_eq_eps(vec3s v, float val);
X   CGLM_INLINE bool  glms_vec3_eq_all(vec3s v);
X   CGLM_INLINE bool  glms_vec3_eqv(vec3s a, vec3s b);
X   CGLM_INLINE bool  glms_vec3_eqv_eps(vec3s a, vec3s b);
X   CGLM_INLINE float glms_vec3_max(vec3s v);
X   CGLM_INLINE float glms_vec3_min(vec3s v);
X   CGLM_INLINE bool  glms_vec3_isnan(vec3s v);
X   CGLM_INLINE bool  glms_vec3_isinf(vec3s v);
X   CGLM_INLINE bool  glms_vec3_isvalid(vec3s v);
X   CGLM_INLINE vec3s glms_vec3_sign(vec3s v);
X   CGLM_INLINE vec3s glms_vec3_abs(vec3s v);
X   CGLM_INLINE vec3s glms_vec3_fract(vec3s v);
X   CGLM_INLINE float glms_vec3_hadd(vec3s v);
X   CGLM_INLINE vec3s glms_vec3_sqrt(vec3s v);
X */
X
X#ifndef cglms_vec3s_ext_h
X#define cglms_vec3s_ext_h
X
X#include "../common.h"
X#include "../types-struct.h"
X#include "../util.h"
X#include "../vec3-ext.h"
X
X/* api definition */
X#define glms_vec3_(NAME) CGLM_STRUCTAPI(vec3, NAME)
X
X/*!
X * @brief fill a vector with specified value
X *
X * @param[in]  val  value
X * @returns         dest
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_(broadcast)(float val) {
X  vec3s r;
X  glm_vec3_broadcast(val, r.raw);
X  return r;
X}
X
X/*!
X * @brief fill a vector with specified value
X *
X * @param[in]  val  value
X * @returns         dest
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_(fill)(float val) {
X  vec3s r;
X  glm_vec3_fill(r.raw, val);
X  return r;
X}
X
X/*!
X * @brief check if vector is equal to value (without epsilon)
X *
X * @param[in] v   vector
X * @param[in] val value
X */
XCGLM_INLINE
Xbool
Xglms_vec3_(eq)(vec3s v, float val) {
X  return glm_vec3_eq(v.raw, val);
X}
X
X/*!
X * @brief check if vector is equal to value (with epsilon)
X *
X * @param[in] v   vector
X * @param[in] val value
X */
XCGLM_INLINE
Xbool
Xglms_vec3_(eq_eps)(vec3s v, float val) {
X  return glm_vec3_eq_eps(v.raw, val);
X}
X
X/*!
X * @brief check if vector members are equal (without epsilon)
X *
X * @param[in] v   vector
X */
XCGLM_INLINE
Xbool
Xglms_vec3_(eq_all)(vec3s v) {
X  return glm_vec3_eq_all(v.raw);
X}
X
X/*!
X * @brief check if vector is equal to another (without epsilon)
X *
X * @param[in] a vector
X * @param[in] b vector
X */
XCGLM_INLINE
Xbool
Xglms_vec3_(eqv)(vec3s a, vec3s b) {
X  return glm_vec3_eqv(a.raw, b.raw);
X}
X
X/*!
X * @brief check if vector is equal to another (with epsilon)
X *
X * @param[in] a vector
X * @param[in] b vector
X */
XCGLM_INLINE
Xbool
Xglms_vec3_(eqv_eps)(vec3s a, vec3s b) {
X  return glm_vec3_eqv_eps(a.raw, b.raw);
X}
X
X/*!
X * @brief max value of vector
X *
X * @param[in] v vector
X */
XCGLM_INLINE
Xfloat
Xglms_vec3_(max)(vec3s v) {
X  return glm_vec3_max(v.raw);
X}
X
X/*!
X * @brief min value of vector
X *
X * @param[in] v vector
X */
XCGLM_INLINE
Xfloat
Xglms_vec3_(min)(vec3s v) {
X  return glm_vec3_min(v.raw);
X}
X
X/*!
X * @brief check if all items are NaN (not a number)
X *        you should only use this in DEBUG mode or very critical asserts
X *
X * @param[in] v vector
X */
XCGLM_INLINE
Xbool
Xglms_vec3_(isnan)(vec3s v) {
X  return glm_vec3_isnan(v.raw);
X}
X
X/*!
X * @brief check if all items are INFINITY
X *        you should only use this in DEBUG mode or very critical asserts
X *
X * @param[in] v vector
X */
XCGLM_INLINE
Xbool
Xglms_vec3_(isinf)(vec3s v) {
X  return glm_vec3_isinf(v.raw);
X}
X
X/*!
X * @brief check if all items are valid number
X *        you should only use this in DEBUG mode or very critical asserts
X *
X * @param[in] v vector
X */
XCGLM_INLINE
Xbool
Xglms_vec3_(isvalid)(vec3s v) {
X  return glm_vec3_isvalid(v.raw);
X}
X
X/*!
X * @brief get sign of 32 bit float as +1, -1, 0
X *
X * Important: It returns 0 for zero/NaN input
X *
X * @param   v   vector
X * @returns     sign vector
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_(sign)(vec3s v) {
X  vec3s r;
X  glm_vec3_sign(v.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief absolute value of each vector item
X *
X * @param[in]  v    vector
X * @return          destination vector
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_(abs)(vec3s v) {
X  vec3s r;
X  glm_vec3_abs(v.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief fractional part of each vector item
X *
X * @param[in]  v    vector
X * @return          dest destination vector
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_(fract)(vec3s v) {
X  vec3s r;
X  glm_vec3_fract(v.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief vector reduction by summation
X * @warning could overflow
X *
X * @param[in]  v    vector
X * @return     sum of all vector's elements
X */
XCGLM_INLINE
Xfloat
Xglms_vec3_(hadd)(vec3s v) {
X  return glm_vec3_hadd(v.raw);
X}
X
X/*!
X * @brief square root of each vector item
X *
X * @param[in]  v    vector
X * @returns         destination vector
X */
XCGLM_INLINE
Xvec3s
Xglms_vec3_(sqrt)(vec3s v) {
X  vec3s r;
X  glm_vec3_sqrt(v.raw, r.raw);
X  return r;
X}
X
X#endif /* cglms_vec3s_ext_h */
e21395184c02ef8dd90484943a2eb658
echo x - cglm/struct/vec4.h
sed 's/^X//' >cglm/struct/vec4.h << 'af370160563352b49a30483f4593453d'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Macros:
X   GLMS_VEC4_ONE_INIT
X   GLMS_VEC4_BLACK_INIT
X   GLMS_VEC4_ZERO_INIT
X   GLMS_VEC4_ONE
X   GLMS_VEC4_BLACK
X   GLMS_VEC4_ZERO
X
X Functions:
X   CGLM_INLINE vec4s glms_vec4(vec3s v3, float last);
X   CGLM_INLINE vec3s glms_vec4_copy3(vec4s v);
X   CGLM_INLINE vec4s glms_vec4_copy(vec4s v);
X   CGLM_INLINE vec4s glms_vec4_ucopy(vec4s v);
X   CGLM_INLINE void  glms_vec4_pack(vec4s dst[], vec4 src[], size_t len);
X   CGLM_INLINE void  glms_vec4_unpack(vec4 dst[], vec4s src[], size_t len);
X   CGLM_INLINE float glms_vec4_dot(vec4s a, vec4s b);
X   CGLM_INLINE float glms_vec4_norm2(vec4s v);
X   CGLM_INLINE float glms_vec4_norm(vec4s v);
X   CGLM_INLINE float glms_vec4_norm_one(vec4s v);
X   CGLM_INLINE float glms_vec4_norm_inf(vec4s v);
X   CGLM_INLINE vec4s glms_vec4_add(vec4s a, vec4s b);
X   CGLM_INLINE vec4s glms_vec4_adds(vec4s v, float s);
X   CGLM_INLINE vec4s glms_vec4_sub(vec4s a, vec4s b);
X   CGLM_INLINE vec4s glms_vec4_subs(vec4s v, float s);
X   CGLM_INLINE vec4s glms_vec4_mul(vec4s a, vec4s b);
X   CGLM_INLINE vec4s glms_vec4_scale(vec4s v, float s);
X   CGLM_INLINE vec4s glms_vec4_scale_as(vec4s v, float s);
X   CGLM_INLINE vec4s glms_vec4_div(vec4s a, vec4s b);
X   CGLM_INLINE vec4s glms_vec4_divs(vec4s v, float s);
X   CGLM_INLINE vec4s glms_vec4_addadd(vec4s a, vec4s b, vec4s dest);
X   CGLM_INLINE vec4s glms_vec4_subadd(vec4s a, vec4s b, vec4s dest);
X   CGLM_INLINE vec4s glms_vec4_muladd(vec4s a, vec4s b, vec4s dest);
X   CGLM_INLINE vec4s glms_vec4_muladds(vec4s a, float s, vec4s dest);
X   CGLM_INLINE vec4s glms_vec4_maxadd(vec4s a, vec4s b, vec4s dest);
X   CGLM_INLINE vec4s glms_vec4_minadd(vec4s a, vec4s b, vec4s dest);
X   CGLM_INLINE vec4s glms_vec4_subsub(vec4s a, vec4s b, vec4s dest);
X   CGLM_INLINE vec4s glms_vec4_addsub(vec4s a, vec4s b, vec4s dest);
X   CGLM_INLINE vec4s glms_vec4_mulsub(vec4s a, vec4s b, vec4s dest);
X   CGLM_INLINE vec4s glms_vec4_mulsubs(vec4s a, float s, vec4s dest);
X   CGLM_INLINE vec4s glms_vec4_maxsub(vec4s a, vec4s b, vec4s dest);
X   CGLM_INLINE vec4s glms_vec4_minsub(vec4s a, vec4s b, vec4s dest);
X   CGLM_INLINE vec4s glms_vec4_negate(vec4s v);
X   CGLM_INLINE vec4s glms_vec4_normalize(vec4s v);
X   CGLM_INLINE float glms_vec4_distance(vec4s a, vec4s b);
X   CGLM_INLINE float glms_vec4_distance2(vec4s a, vec4s b);
X   CGLM_INLINE vec4s glms_vec4_maxv(vec4s a, vec4s b);
X   CGLM_INLINE vec4s glms_vec4_minv(vec4s a, vec4s b);
X   CGLM_INLINE vec4s glms_vec4_clamp(vec4s v, float minVal, float maxVal);
X   CGLM_INLINE vec4s glms_vec4_lerp(vec4s from, vec4s to, float t);
X   CGLM_INLINE vec4s glms_vec4_lerpc(vec4s from, vec4s to, float t);
X   CGLM_INLINE vec4s glms_vec4_mix(vec4s from, vec4s to, float t);
X   CGLM_INLINE vec4s glms_vec4_mixc(vec4s from, vec4s to, float t);
X   CGLM_INLINE vec4s glms_vec4_step_uni(float edge, vec4s x);
X   CGLM_INLINE vec4s glms_vec4_step(vec4s edge, vec4s x);
X   CGLM_INLINE vec4s glms_vec4_smoothstep_uni(float edge0, float edge1, vec4s x);
X   CGLM_INLINE vec4s glms_vec4_smoothstep(vec4s edge0, vec4s edge1, vec4s x);
X   CGLM_INLINE vec4s glms_vec4_smoothinterp(vec4s from, vec4s to, float t);
X   CGLM_INLINE vec4s glms_vec4_smoothinterpc(vec4s from, vec4s to, float t);
X   CGLM_INLINE vec4s glms_vec4_cubic(float s);
X   CGLM_INLINE vec4s glms_vec4_swizzle(vec4s v, int mask);
X   CGLM_INLINE vec4s glms_vec4_make(float * restrict src);
X */
X
X#ifndef cglms_vec4s_h
X#define cglms_vec4s_h
X
X#include "../common.h"
X#include "../types-struct.h"
X#include "../util.h"
X#include "../vec4.h"
X#include "vec4-ext.h"
X
X#define GLMS_VEC4_ONE_INIT   {GLM_VEC4_ONE_INIT}
X#define GLMS_VEC4_BLACK_INIT {GLM_VEC4_BLACK_INIT}
X#define GLMS_VEC4_ZERO_INIT  {GLM_VEC4_ZERO_INIT}
X
X#define GLMS_VEC4_ONE        ((vec4s)GLM_VEC4_ONE_INIT)
X#define GLMS_VEC4_BLACK      ((vec4s)GLM_VEC4_BLACK_INIT)
X#define GLMS_VEC4_ZERO       ((vec4s)GLM_VEC4_ZERO_INIT)
X
X/*!
X * @brief init vec4 using vec3
X *
X * @param[in]  v3   vector3
X * @param[in]  last last item
X * @returns         destination
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4(vec3s v3, float last) {
X  vec4s r;
X  glm_vec4(v3.raw, last, r.raw);
X  return r;
X}
X
X/*!
X * @brief copy first 3 members of [a] to [dest]
X *
X * @param[in]  v    source
X * @returns         vec3
X */
XCGLM_INLINE
Xvec3s
Xglms_vec4_(copy3)(vec4s v) {
X  vec3s r;
X  glm_vec4_copy3(v.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief copy all members of [a] to [dest]
X *
X * @param[in]  v    source
X * @returns         destination
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_(copy)(vec4s v) {
X  vec4s r;
X  glm_vec4_copy(v.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief copy all members of [a] to [dest]
X *
X * alignment is not required
X *
X * @param[in]  v    source
X * @returns         destination
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_(ucopy)(vec4s v) {
X  vec4s r;
X  glm_vec4_ucopy(v.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief pack an array of vec4 into an array of vec4s
X *
X * @param[out] dst array of vec4
X * @param[in]  src array of vec4s
X * @param[in]  len number of elements
X */
XCGLM_INLINE
Xvoid
Xglms_vec4_(pack)(vec4s dst[], vec4 src[], size_t len) {
X  size_t i;
X
X  for (i = 0; i < len; i++) {
X    glm_vec4_copy(src[i], dst[i].raw);
X  }
X}
X
X/*!
X * @brief unpack an array of vec4s into an array of vec4
X *
X * @param[out] dst array of vec4s
X * @param[in]  src array of vec4
X * @param[in]  len number of elements
X */
XCGLM_INLINE
Xvoid
Xglms_vec4_(unpack)(vec4 dst[], vec4s src[], size_t len) {
X  size_t i;
X
X  for (i = 0; i < len; i++) {
X    glm_vec4_copy(src[i].raw, dst[i]);
X  }
X}
X
X/*!
X * @brief make vector zero
X *
X * @returns      zero vector
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_(zero)(void) {
X  vec4s r;
X  glm_vec4_zero(r.raw);
X  return r;
X}
X
X/*!
X * @brief make vector one
X *
X * @returns      one vector
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_(one)(void) {
X  vec4s r;
X  glm_vec4_one(r.raw);
X  return r;
X}
X
X/*!
X * @brief vec4 dot product
X *
X * @param[in] a vector1
X * @param[in] b vector2
X *
X * @return dot product
X */
XCGLM_INLINE
Xfloat
Xglms_vec4_(dot)(vec4s a, vec4s b) {
X  return glm_vec4_dot(a.raw, b.raw);
X}
X
X/*!
X * @brief norm * norm (magnitude) of vec
X *
X * we can use this func instead of calling norm * norm, because it would call
X * sqrtf fuction twice but with this func we can avoid func call, maybe this is
X * not good name for this func
X *
X * @param[in] v vec4
X *
X * @return norm * norm
X */
XCGLM_INLINE
Xfloat
Xglms_vec4_(norm2)(vec4s v) {
X  return glm_vec4_norm2(v.raw);
X}
X
X/*!
X * @brief norm (magnitude) of vec4
X *
X * @param[in] v vector
X *
X * @return norm
X */
XCGLM_INLINE
Xfloat
Xglms_vec4_(norm)(vec4s v) {
X  return glm_vec4_norm(v.raw);
X}
X
X/*!
X * @brief L1 norm of vec4
X * Also known as Manhattan Distance or Taxicab norm.
X * L1 Norm is the sum of the magnitudes of the vectors in a space.
X * It is calculated as the sum of the absolute values of the vector components.
X * In this norm, all the components of the vector are weighted equally.
X *
X * This computes:
X * R = |v[0]| + |v[1]| + |v[2]| + |v[3]|
X *
X * @param[in] v vector
X *
X * @return L1 norm
X */
XCGLM_INLINE
Xfloat
Xglms_vec4_(norm_one)(vec4s v) {
X  return glm_vec4_norm_one(v.raw);
X}
X
X/*!
X * @brief Infinity norm of vec4
X * Also known as Maximum norm.
X * Infinity Norm is the largest magnitude among each element of a vector.
X * It is calculated as the maximum of the absolute values of the vector components.
X *
X * This computes:
X * inf norm = max(|v[0]|, |v[1]|, |v[2]|, |v[3]|)
X *
X * @param[in] v vector
X *
X * @return Infinity norm
X */
XCGLM_INLINE
Xfloat
Xglms_vec4_(norm_inf)(vec4s v) {
X  return glm_vec4_norm_inf(v.raw);
X}
X
X/*!
X * @brief add b vector to a vector store result in dest
X *
X * @param[in]  a    vector1
X * @param[in]  b    vector2
X * @returns         destination vector
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_(add)(vec4s a, vec4s b) {
X  vec4s r;
X  glm_vec4_add(a.raw, b.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief add scalar to v vector store result in dest (d = v + vec(s))
X *
X * @param[in]  v    vector
X * @param[in]  s    scalar
X * @returns         destination vector
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_(adds)(vec4s v, float s) {
X  vec4s r;
X  glm_vec4_adds(v.raw, s, r.raw);
X  return r;
X}
X
X/*!
X * @brief subtract b vector from a vector store result in dest (d = a - b)
X *
X * @param[in]  a    vector1
X * @param[in]  b    vector2
X * @returns         destination vector
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_(sub)(vec4s a, vec4s b) {
X  vec4s r;
X  glm_vec4_sub(a.raw, b.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief subtract scalar from v vector store result in dest (d = v - vec(s))
X *
X * @param[in]  v    vector
X * @param[in]  s    scalar
X * @returns         destination vector
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_(subs)(vec4s v, float s) {
X  vec4s r;
X  glm_vec4_subs(v.raw, s, r.raw);
X  return r;
X}
X
X/*!
X * @brief multiply two vectors (component-wise multiplication)
X *
X * @param a    vector1
X * @param b    vector2
X * @returns    dest = (a[0] * b[0], a[1] * b[1], a[2] * b[2], a[3] * b[3])
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_(mul)(vec4s a, vec4s b) {
X  vec4s r;
X  glm_vec4_mul(a.raw, b.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief multiply/scale vec4 vector with scalar: result = v * s
X *
X * @param[in]  v    vector
X * @param[in]  s    scalar
X * @returns         destination vector
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_(scale)(vec4s v, float s) {
X  vec4s r;
X  glm_vec4_scale(v.raw, s, r.raw);
X  return r;
X}
X
X/*!
X * @brief make vec4 vector scale as specified: result = unit(v) * s
X *
X * @param[in]  v    vector
X * @param[in]  s    scalar
X * @returns         destination vector
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_(scale_as)(vec4s v, float s) {
X  vec4s r;
X  glm_vec4_scale_as(v.raw, s, r.raw);
X  return r;
X}
X
X/*!
X * @brief div vector with another component-wise division: d = a / b
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @returns         result = (a[0]/b[0], a[1]/b[1], a[2]/b[2], a[3]/b[3])
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_(div)(vec4s a, vec4s b) {
X  vec4s r;
X  glm_vec4_div(a.raw, b.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief div vec4 vector with scalar: d = v / s
X *
X * @param[in]  v    vector
X * @param[in]  s    scalar
X * @returns         destination vector
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_(divs)(vec4s v, float s) {
X  vec4s r;
X  glm_vec4_divs(v.raw, s, r.raw);
X  return r;
X}
X
X/*!
X * @brief add two vectors and add result to sum
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @returns         dest += (a + b)
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_(addadd)(vec4s a, vec4s b, vec4s dest) {
X  glm_vec4_addadd(a.raw, b.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief sub two vectors and add result to dest
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @returns         dest += (a - b)
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_(subadd)(vec4s a, vec4s b, vec4s dest) {
X  glm_vec4_subadd(a.raw, b.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief mul two vectors and add result to dest
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @returns         dest += (a * b)
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_(muladd)(vec4s a, vec4s b, vec4s dest) {
X  glm_vec4_muladd(a.raw, b.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief mul vector with scalar and add result to sum
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector
X * @param[in]  s    scalar
X * @returns         dest += (a * b)
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_(muladds)(vec4s a, float s, vec4s dest) {
X  glm_vec4_muladds(a.raw, s, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief add max of two vectors to result/dest
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @returns         dest += max(a, b)
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_(maxadd)(vec4s a, vec4s b, vec4s dest) {
X  glm_vec4_maxadd(a.raw, b.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief add min of two vectors to result/dest
X *
X * it applies += operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @returns         dest += min(a, b)
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_(minadd)(vec4s a, vec4s b, vec4s dest) {
X  glm_vec4_minadd(a.raw, b.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief sub two vectors and sub result to dest
X *
X * it applies -= operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @returns         dest -= (a + b)
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_(subsub)(vec4s a, vec4s b, vec4s dest) {
X  glm_vec4_subsub(a.raw, b.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief add two vectors and sub result to dest
X *
X * it applies -= operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @returns         dest -= (a + b)
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_(addsub)(vec4s a, vec4s b, vec4s dest) {
X  glm_vec4_addsub(a.raw, b.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief mul two vectors and sub result to dest
X *
X * it applies -= operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @returns         dest -= (a * b)
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_(mulsub)(vec4s a, vec4s b, vec4s dest) {
X  glm_vec4_mulsub(a.raw, b.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief mul vector with scalar and sub result to dest
X *
X * it applies -= operator so dest must be initialized
X *
X * @param[in]  a    vector
X * @param[in]  s    scalar
X * @returns         dest -= (a * b)
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_(mulsubs)(vec4s a, float s, vec4s dest) {
X  glm_vec4_mulsubs(a.raw, s, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief sub max of two vectors to dest
X *
X * it applies -= operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @returns         dest -= max(a, b)
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_(maxsub)(vec4s a, vec4s b, vec4s dest) {
X  glm_vec4_maxsub(a.raw, b.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief sub min of two vectors to dest
X *
X * it applies -= operator so dest must be initialized
X *
X * @param[in]  a    vector 1
X * @param[in]  b    vector 2
X * @returns         dest -= min(a, b)
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_(minsub)(vec4s a, vec4s b, vec4s dest) {
X  glm_vec4_minsub(a.raw, b.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief negate vector components and store result in dest
X *
X * @param[in]  v     vector
X * @returns          result vector
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_(negate)(vec4s v) {
X  glm_vec4_negate(v.raw);
X  return v;
X}
X
X/*!
X * @brief normalize vec4 and store result in same vec
X *
X * @param[in] v   vector
X * @returns       normalized vector
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_(normalize)(vec4s v) {
X  glm_vec4_normalize(v.raw);
X  return v;
X}
X
X/**
X * @brief distance between two vectors
X *
X * @param[in] a vector1
X * @param[in] b vector2
X * @return returns distance
X */
XCGLM_INLINE
Xfloat
Xglms_vec4_(distance)(vec4s a, vec4s b) {
X  return glm_vec4_distance(a.raw, b.raw);
X}
X
X/**
X * @brief squared distance between two vectors
X *
X * @param[in] a vector1
X * @param[in] b vector2
X * @return returns squared distance
X */
XCGLM_INLINE
Xfloat
Xglms_vec4_(distance2)(vec4s a, vec4s b) {
X  return glm_vec4_distance2(a.raw, b.raw);
X}
X
X/*!
X * @brief max values of vectors
X *
X * @param[in]  a    vector1
X * @param[in]  b    vector2
X * @returns         destination
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_(maxv)(vec4s a, vec4s b) {
X  vec4s r;
X  glm_vec4_maxv(a.raw, b.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief min values of vectors
X *
X * @param[in]  a    vector1
X * @param[in]  b    vector2
X * @returns         destination
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_(minv)(vec4s a, vec4s b) {
X  vec4s r;
X  glm_vec4_minv(a.raw, b.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief clamp vector's individual members between min and max values
X *
X * @param[in]       v       vector
X * @param[in]       minVal  minimum value
X * @param[in]       maxVal  maximum value
X * @returns                 clamped vector
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_(clamp)(vec4s v, float minVal, float maxVal) {
X  glm_vec4_clamp(v.raw, minVal, maxVal);
X  return v;
X}
X
X/*!
X * @brief linear interpolation between two vectors
X *
X * formula:  from + s * (to - from)
X *
X * @param[in]   from  from value
X * @param[in]   to    to value
X * @param[in]   t     interpolant (amount)
X * @returns           destination
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_(lerp)(vec4s from, vec4s to, float t) {
X  vec4s r;
X  glm_vec4_lerp(from.raw, to.raw, t, r.raw);
X  return r;
X}
X
X/*!
X * @brief linear interpolation between two vectors (clamped)
X *
X * formula:  from + s * (to - from)
X *
X * @param[in]   from  from value
X * @param[in]   to    to value
X * @param[in]   t     interpolant (amount) clamped between 0 and 1
X * @returns           destination
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_(lerpc)(vec4s from, vec4s to, float t) {
X  vec4s r;
X  glm_vec4_lerpc(from.raw, to.raw, t, r.raw);
X  return r;
X}
X
X/*!
X * @brief linear interpolation between two vectors
X *
X * formula:  from + s * (to - from)
X *
X * @param[in]   from  from value
X * @param[in]   to    to value
X * @param[in]   t     interpolant (amount)
X * @returns           destination
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_(mix)(vec4s from, vec4s to, float t) {
X  vec4s r;
X  glm_vec4_mix(from.raw, to.raw, t, r.raw);
X  return r;
X}
X
X/*!
X * @brief linear interpolation between two vectors (clamped)
X *
X * formula:  from + s * (to - from)
X *
X * @param[in]   from  from value
X * @param[in]   to    to value
X * @param[in]   t     interpolant (amount) clamped between 0 and 1
X * @returns           destination
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_(mixc)(vec4s from, vec4s to, float t) {
X  vec4s r;
X  glm_vec4_mixc(from.raw, to.raw, t, r.raw);
X  return r;
X}
X
X/*!
X * @brief threshold function (unidimensional)
X *
X * @param[in]   edge    threshold
X * @param[in]   x       value to test against threshold
X * @returns             0.0 if x < edge, else 1.0
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_(step_uni)(float edge, vec4s x) {
X  vec4s r;
X  glm_vec4_step_uni(edge, x.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief threshold function
X *
X * @param[in]   edge    threshold
X * @param[in]   x       value to test against threshold
X * @returns             0.0 if x < edge, else 1.0
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_(step)(vec4s edge, vec4s x) {
X  vec4s r;
X  glm_vec4_step(edge.raw, x.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief threshold function with a smooth transition (unidimensional)
X *
X * @param[in]   edge0   low threshold
X * @param[in]   edge1   high threshold
X * @param[in]   x       value to test against threshold
X * @returns             destination
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_(smoothstep_uni)(float edge0, float edge1, vec4s x) {
X  vec4s r;
X  glm_vec4_smoothstep_uni(edge0, edge1, x.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief threshold function with a smooth transition
X *
X * @param[in]   edge0   low threshold
X * @param[in]   edge1   high threshold
X * @param[in]   x       value to test against threshold
X * @returns             destination
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_(smoothstep)(vec4s edge0, vec4s edge1, vec4s x) {
X  vec4s r;
X  glm_vec4_smoothstep(edge0.raw, edge1.raw, x.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief smooth Hermite interpolation between two vectors
X *
X * formula:  from + s * (to - from)
X *
X * @param[in]   from    from value
X * @param[in]   to      to value
X * @param[in]   t       interpolant (amount)
X * @returns             destination
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_(smoothinterp)(vec4s from, vec4s to, float t) {
X  vec4s r;
X  glm_vec4_smoothinterp(from.raw, to.raw, t, r.raw);
X  return r;
X}
X
X/*!
X * @brief smooth Hermite interpolation between two vectors (clamped)
X *
X * formula:  from + s * (to - from)
X *
X * @param[in]   from    from value
X * @param[in]   to      to value
X * @param[in]   t       interpolant (amount) clamped between 0 and 1
X * @returns             destination
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_(smoothinterpc)(vec4s from, vec4s to, float t) {
X  vec4s r;
X  glm_vec4_smoothinterpc(from.raw, to.raw, t, r.raw);
X  return r;
X}
X
X/*!
X * @brief helper to fill vec4 as [S^3, S^2, S, 1]
X *
X * @param[in]   s     parameter
X * @returns           destination
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_(cubic)(float s) {
X  vec4s r;
X  glm_vec4_cubic(s, r.raw);
X  return r;
X}
X
X/*!
X * @brief swizzle vector components
X *
X * you can use existin masks e.g. GLM_XXXX, GLM_WZYX
X *
X * @param[in]  v    source
X * @param[in]  mask mask
X * @returns swizzled vector
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_(swizzle)(vec4s v, int mask) {
X  vec4s dest;
X  glm_vec4_swizzle(v.raw, mask, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief Create four dimensional vector from pointer
X *
X * @param[in]  src  pointer to an array of floats
X * @returns constructed 4D vector from raw pointer
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_(make)(float * __restrict src) {
X  vec4s dest;
X  glm_vec4_make(src, dest.raw);
X  return dest;
X}
X
X#endif /* cglms_vec4s_h */
af370160563352b49a30483f4593453d
echo x - cglm/struct/vec4-ext.h
sed 's/^X//' >cglm/struct/vec4-ext.h << '35a8b505207e09af32f5d24001d3d838'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*!
X * @brief SIMD like functions
X */
X
X/*
X Functions:
X   CGLM_INLINE vec4s glms_vec4_broadcast(float val);
X   CGLM_INLINE vec4s glms_vec4_fill(float val);
X   CGLM_INLINE bool  glms_vec4_eq(vec4s v, float val);
X   CGLM_INLINE bool  glms_vec4_eq_eps(vec4s v, float val);
X   CGLM_INLINE bool  glms_vec4_eq_all(vec4s v);
X   CGLM_INLINE bool  glms_vec4_eqv(vec4s a, vec4s b);
X   CGLM_INLINE bool  glms_vec4_eqv_eps(vec4s a, vec4s b);
X   CGLM_INLINE float glms_vec4_max(vec4s v);
X   CGLM_INLINE float glms_vec4_min(vec4s v);
X   CGLM_INLINE bool  glms_vec4_isnan(vec4s v);
X   CGLM_INLINE bool  glms_vec4_isinf(vec4s v);
X   CGLM_INLINE bool  glms_vec4_isvalid(vec4s v);
X   CGLM_INLINE vec4s glms_vec4_sign(vec4s v);
X   CGLM_INLINE vec4s glms_vec4_abs(vec4s v);
X   CGLM_INLINE vec4s glms_vec4_fract(vec4s v);
X   CGLM_INLINE float glms_vec4_hadd(vec4s v);
X   CGLM_INLINE vec4s glms_vec4_sqrt(vec4s v);
X */
X
X#ifndef cglms_vec4s_ext_h
X#define cglms_vec4s_ext_h
X
X#include "../common.h"
X#include "../types-struct.h"
X#include "../util.h"
X#include "../vec4-ext.h"
X
X/* api definition */
X#define glms_vec4_(NAME) CGLM_STRUCTAPI(vec4, NAME)
X
X/*!
X * @brief fill a vector with specified value
X *
X * @param val value
X * @returns   dest
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_(broadcast)(float val) {
X  vec4s r;
X  glm_vec4_broadcast(val, r.raw);
X  return r;
X}
X
X/*!
X * @brief fill a vector with specified value
X *
X * @param val value
X * @returns   dest
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_(fill)(float val) {
X  vec4s r;
X  glm_vec4_fill(r.raw, val);
X  return r;
X}
X
X/*!
X * @brief check if vector is equal to value (without epsilon)
X *
X * @param v   vector
X * @param val value
X */
XCGLM_INLINE
Xbool
Xglms_vec4_(eq)(vec4s v, float val) {
X  return glm_vec4_eq(v.raw, val);
X}
X
X/*!
X * @brief check if vector is equal to value (with epsilon)
X *
X * @param v   vector
X * @param val value
X */
XCGLM_INLINE
Xbool
Xglms_vec4_(eq_eps)(vec4s v, float val) {
X  return glm_vec4_eq_eps(v.raw, val);
X}
X
X/*!
X * @brief check if vector members are equal (without epsilon)
X *
X * @param v   vector
X */
XCGLM_INLINE
Xbool
Xglms_vec4_(eq_all)(vec4s v) {
X  return glm_vec4_eq_all(v.raw);
X}
X
X/*!
X * @brief check if vector is equal to another (without epsilon)
X *
X * @param a vector
X * @param b vector
X */
XCGLM_INLINE
Xbool
Xglms_vec4_(eqv)(vec4s a, vec4s b) {
X  return glm_vec4_eqv(a.raw, b.raw);
X}
X
X/*!
X * @brief check if vector is equal to another (with epsilon)
X *
X * @param a vector
X * @param b vector
X */
XCGLM_INLINE
Xbool
Xglms_vec4_(eqv_eps)(vec4s a, vec4s b) {
X  return glm_vec4_eqv_eps(a.raw, b.raw);
X}
X
X/*!
X * @brief max value of vector
X *
X * @param v vector
X */
XCGLM_INLINE
Xfloat
Xglms_vec4_(max)(vec4s v) {
X  return glm_vec4_max(v.raw);
X}
X
X/*!
X * @brief min value of vector
X *
X * @param v vector
X */
XCGLM_INLINE
Xfloat
Xglms_vec4_(min)(vec4s v) {
X  return glm_vec4_min(v.raw);
X}
X
X/*!
X * @brief check if one of items is NaN (not a number)
X *        you should only use this in DEBUG mode or very critical asserts
X *
X * @param[in] v vector
X */
XCGLM_INLINE
Xbool
Xglms_vec4_(isnan)(vec4s v) {
X  return glm_vec4_isnan(v.raw);
X}
X
X/*!
X * @brief check if one of items is INFINITY
X *        you should only use this in DEBUG mode or very critical asserts
X *
X * @param[in] v vector
X */
XCGLM_INLINE
Xbool
Xglms_vec4_(isinf)(vec4s v) {
X  return glm_vec4_isinf(v.raw);
X}
X
X/*!
X * @brief check if all items are valid number
X *        you should only use this in DEBUG mode or very critical asserts
X *
X * @param[in] v vector
X */
XCGLM_INLINE
Xbool
Xglms_vec4_(isvalid)(vec4s v) {
X  return glm_vec4_isvalid(v.raw);
X}
X
X/*!
X * @brief get sign of 32 bit float as +1, -1, 0
X *
X * Important: It returns 0 for zero/NaN input
X *
X * @param   v   vector
X * @returns     sign vector
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_(sign)(vec4s v) {
X  vec4s r;
X  glm_vec4_sign(v.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief absolute value of each vector item
X *
X * @param[in]  v    vector
X * @returns         destination vector
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_(abs)(vec4s v) {
X  vec4s r;
X  glm_vec4_abs(v.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief fractional part of each vector item
X *
X * @param[in]  v    vector
X * @returns          dest destination vector
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_(fract)(vec4s v) {
X  vec4s r;
X  glm_vec4_fract(v.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief vector reduction by summation
X * @warning could overflow
X *
X * @param[in]  v    vector
X * @return     sum of all vector's elements
X */
XCGLM_INLINE
Xfloat
Xglms_vec4_(hadd)(vec4s v) {
X  return glm_vec4_hadd(v.raw);
X}
X
X/*!
X * @brief square root of each vector item
X *
X * @param[in]  v    vector
X * @returns         destination vector
X */
XCGLM_INLINE
Xvec4s
Xglms_vec4_(sqrt)(vec4s v) {
X  vec4s r;
X  glm_vec4_sqrt(v.raw, r.raw);
X  return r;
X}
X
X#endif /* cglms_vec4s_ext_h */
35a8b505207e09af32f5d24001d3d838
echo x - cglm/struct/io.h
sed 's/^X//' >cglm/struct/io.h << 'c6b60cc3ed20b299e298c2daf5984caa'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Functions:
X   CGLM_INLINE void glm_mat4_print(mat4 matrix, FILE *ostream);
X   CGLM_INLINE void glm_mat3_print(mat3 matrix, FILE *ostream);
X   CGLM_INLINE void glm_vec4_print(vec4 vec, FILE *ostream);
X   CGLM_INLINE void glm_vec3_print(vec3 vec, FILE *ostream);
X   CGLM_INLINE void glm_ivec3_print(ivec3 vec, FILE *ostream);
X   CGLM_INLINE void glm_ivec3_print(ivec3 vec, FILE *ostream);
X
X   CGLM_INLINE void glm_versor_print(versor vec, FILE *ostream);
X */
X
X#ifndef cglms_ios_h
X#define cglms_ios_h
X
X#include "../common.h"
X#include "../io.h"
X#include "mat4.h"
X
X#include <stdio.h>
X#include <stdlib.h>
X
XCGLM_INLINE
Xvoid
Xglms_mat4_print(mat4s             matrix,
X                FILE * __restrict ostream) {
X
X  glm_mat4_print(matrix.raw, ostream);
X}
X
XCGLM_INLINE
Xvoid
Xglms_mat3_print(mat3s             matrix,
X                FILE * __restrict ostream) {
X  glm_mat3_print(matrix.raw, ostream);
X}
X
XCGLM_INLINE
Xvoid
Xglms_vec4_print(vec4s             vec,
X                FILE * __restrict ostream) {
X  glm_vec4_print(vec.raw, ostream);
X}
X
XCGLM_INLINE
Xvoid
Xglms_vec3_print(vec3s             vec,
X                FILE * __restrict ostream) {
X  glm_vec3_print(vec.raw, ostream);
X}
X
XCGLM_INLINE
Xvoid
Xglms_ivec3_print(ivec3s            vec,
X                 FILE * __restrict ostream) {
X  glm_ivec3_print(vec.raw, ostream);
X}
X
XCGLM_INLINE
Xvoid
Xglms_versor_print(versors           vec,
X                  FILE * __restrict ostream) {
X  glm_versor_print(vec.raw, ostream);
X}
X
XCGLM_INLINE
Xvoid
Xglms_aabb_print(vec3s                   bbox[2],
X                const char * __restrict tag,
X                FILE       * __restrict ostream) {
X  vec3 rawBbox[2];
X
X  glms_vec3_(unpack)(rawBbox, bbox, 2);
X  glm_aabb_print(rawBbox, tag, ostream);
X}
X
X#endif /* cglms_ios_h */
c6b60cc3ed20b299e298c2daf5984caa
echo x - cglm/struct/cam.h
sed 's/^X//' >cglm/struct/cam.h << 'd0f41fdfdb1ad1c3e0a84bdeb0e7bd0c'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Functions:
X   CGLM_INLINE mat4s glms_frustum(float left,    float right,
X                                  float bottom,  float top,
X                                  float nearZ,   float farZ)
X   CGLM_INLINE mat4s glms_ortho(float left,    float right,
X                                float bottom,  float top,
X                                float nearZ,   float farZ)
X   CGLM_INLINE mat4s glms_ortho_aabb(vec3s box[2]);
X   CGLM_INLINE mat4s glms_ortho_aabb_p(vec3s box[2],  float padding);
X   CGLM_INLINE mat4s glms_ortho_aabb_pz(vec3s box[2], float padding);
X   CGLM_INLINE mat4s glms_ortho_default(float aspect)
X   CGLM_INLINE mat4s glms_ortho_default_s(float aspect, float size)
X   CGLM_INLINE mat4s glms_perspective(float fovy,
X                                      float aspect,
X                                      float nearZ,
X                                      float farZ)
X   CGLM_INLINE void  glms_persp_move_far(mat4s proj, float deltaFar)
X   CGLM_INLINE mat4s glms_perspective_default(float aspect)
X   CGLM_INLINE void  glms_perspective_resize(mat4s proj, float aspect)
X   CGLM_INLINE mat4s glms_lookat(vec3s eye, vec3s center, vec3s up)
X   CGLM_INLINE mat4s glms_look(vec3s eye, vec3s dir, vec3s up)
X   CGLM_INLINE mat4s glms_look_anyup(vec3s eye, vec3s dir)
X   CGLM_INLINE void  glms_persp_decomp(mat4s  proj,
X                                       float *nearv, float *farv,
X                                       float *top,   float *bottom,
X                                       float *left,  float *right)
X   CGLM_INLINE void  glms_persp_decompv(mat4s proj, float dest[6])
X   CGLM_INLINE void  glms_persp_decomp_x(mat4s proj, float *left, float *right)
X   CGLM_INLINE void  glms_persp_decomp_y(mat4s proj, float *top, float *bottom)
X   CGLM_INLINE void  glms_persp_decomp_z(mat4s proj, float *nearv, float *farv)
X   CGLM_INLINE void  glms_persp_decomp_far(mat4s proj, float *farZ)
X   CGLM_INLINE void  glms_persp_decomp_near(mat4s proj, float *nearZ)
X   CGLM_INLINE float glms_persp_fovy(mat4s proj)
X   CGLM_INLINE float glms_persp_aspect(mat4s proj)
X   CGLM_INLINE vec4s glms_persp_sizes(mat4s proj, float fovy)
X */
X
X#ifndef cglms_cam_h
X#define cglms_cam_h
X
X#include "../common.h"
X#include "../types-struct.h"
X#include "../plane.h"
X#include "../cam.h"
X
X#ifndef CGLM_CLIPSPACE_INCLUDE_ALL
X#  if CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_ZO
X#    include "clipspace/ortho_lh_zo.h"
X#    include "clipspace/persp_lh_zo.h"
X#    include "clipspace/view_lh_zo.h"
X#  elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_NO
X#    include "clipspace/ortho_lh_no.h"
X#    include "clipspace/persp_lh_no.h"
X#    include "clipspace/view_lh_no.h"
X#  elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_ZO
X#    include "clipspace/ortho_rh_zo.h"
X#    include "clipspace/persp_rh_zo.h"
X#    include "clipspace/view_rh_zo.h"
X#  elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_NO
X#    include "clipspace/ortho_rh_no.h"
X#    include "clipspace/persp_rh_no.h"
X#    include "clipspace/view_rh_no.h"
X#  endif
X#else
X#  include "clipspace/ortho_lh_zo.h"
X#  include "clipspace/persp_lh_zo.h"
X#  include "clipspace/ortho_lh_no.h"
X#  include "clipspace/persp_lh_no.h"
X#  include "clipspace/ortho_rh_zo.h"
X#  include "clipspace/persp_rh_zo.h"
X#  include "clipspace/ortho_rh_no.h"
X#  include "clipspace/persp_rh_no.h"
X#  include "clipspace/view_lh_zo.h"
X#  include "clipspace/view_lh_no.h"
X#  include "clipspace/view_rh_zo.h"
X#  include "clipspace/view_rh_no.h"
X#endif
X
X/*!
X * @brief set up perspective peprojection matrix
X *
X * @param[in]  left    viewport.left
X * @param[in]  right   viewport.right
X * @param[in]  bottom  viewport.bottom
X * @param[in]  top     viewport.top
X * @param[in]  nearZ   near clipping plane
X * @param[in]  farZ    far clipping plane
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_frustum(float left,   float right,
X             float bottom, float top,
X             float nearZ,  float farZ) {
X#if CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_ZO
X  return glms_frustum_lh_zo(left, right, bottom, top, nearZ, farZ);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_NO
X  return glms_frustum_lh_no(left, right, bottom, top, nearZ, farZ);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_ZO
X  return glms_frustum_rh_zo(left, right, bottom, top, nearZ, farZ);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_NO
X  return glms_frustum_rh_no(left, right, bottom, top, nearZ, farZ);
X#endif
X}
X
X/*!
X * @brief set up orthographic projection matrix
X *
X * @param[in]  left    viewport.left
X * @param[in]  right   viewport.right
X * @param[in]  bottom  viewport.bottom
X * @param[in]  top     viewport.top
X * @param[in]  nearZ   near clipping plane
X * @param[in]  farZ    far clipping plane
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_ortho(float left,   float right,
X           float bottom, float top,
X           float nearZ,  float farZ) {
X#if CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_ZO
X  return glms_ortho_lh_zo(left, right, bottom, top, nearZ, farZ);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_NO
X  return glms_ortho_lh_no(left, right, bottom, top, nearZ, farZ);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_ZO
X  return glms_ortho_rh_zo(left, right, bottom, top, nearZ, farZ);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_NO
X  return glms_ortho_rh_no(left, right, bottom, top, nearZ, farZ);
X#endif
X}
X
X/*!
X * @brief set up orthographic projection matrix using bounding box
X *
X * bounding box (AABB) must be in view space
X *
X * @param[in]  box   AABB
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_ortho_aabb(vec3s box[2]) {
X#if CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_ZO
X  return glms_ortho_aabb_lh_zo(box);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_NO
X  return glms_ortho_aabb_lh_no(box);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_ZO
X  return glms_ortho_aabb_rh_zo(box);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_NO
X  return glms_ortho_aabb_rh_no(box);
X#endif
X}
X
X/*!
X * @brief set up orthographic projection matrix using bounding box
X *
X * bounding box (AABB) must be in view space
X *
X * @param[in]  box     AABB
X * @param[in]  padding padding
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_ortho_aabb_p(vec3s box[2], float padding) {
X#if CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_ZO
X  return glms_ortho_aabb_p_lh_zo(box, padding);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_NO
X  return glms_ortho_aabb_p_lh_no(box, padding);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_ZO
X  return glms_ortho_aabb_p_rh_zo(box, padding);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_NO
X  return glms_ortho_aabb_p_rh_no(box, padding);
X#endif
X}
X
X/*!
X * @brief set up orthographic projection matrix using bounding box
X *
X * bounding box (AABB) must be in view space
X *
X * @param[in]  box     AABB
X * @param[in]  padding padding for near and far
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_ortho_aabb_pz(vec3s box[2], float padding) {
X#if CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_ZO
X  return glms_ortho_aabb_pz_lh_zo(box, padding);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_NO
X  return glms_ortho_aabb_pz_lh_no(box, padding);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_ZO
X  return glms_ortho_aabb_pz_rh_zo(box, padding);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_NO
X  return glms_ortho_aabb_pz_rh_no(box, padding);
X#endif
X}
X
X/*!
X * @brief set up unit orthographic projection matrix
X *
X * @param[in]  aspect aspect ration ( width / height )
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_ortho_default(float aspect) {
X#if CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_ZO
X  return glms_ortho_default_lh_zo(aspect);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_NO
X  return glms_ortho_default_lh_no(aspect);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_ZO
X  return glms_ortho_default_rh_zo(aspect);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_NO
X  return glms_ortho_default_rh_no(aspect);
X#endif
X}
X
X/*!
X * @brief set up orthographic projection matrix with given CUBE size
X *
X * @param[in]  aspect aspect ratio ( width / height )
X * @param[in]  size   cube size
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_ortho_default_s(float aspect, float size) {
X#if CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_ZO
X  return glms_ortho_default_s_lh_zo(aspect, size);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_NO
X  return glms_ortho_default_s_lh_no(aspect, size);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_ZO
X  return glms_ortho_default_s_rh_zo(aspect, size);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_NO
X  return glms_ortho_default_s_rh_no(aspect, size);
X#endif
X}
X
X/*!
X * @brief set up perspective projection matrix
X *
X * @param[in]  fovy    field of view angle
X * @param[in]  aspect  aspect ratio ( width / height )
X * @param[in]  nearZ   near clipping plane
X * @param[in]  farZ    far clipping planes
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_perspective(float fovy, float aspect, float nearZ, float farZ) {
X#if CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_ZO
X  return glms_perspective_lh_zo(fovy, aspect, nearZ, farZ);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_NO
X  return glms_perspective_lh_no(fovy, aspect, nearZ, farZ);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_ZO
X  return glms_perspective_rh_zo(fovy, aspect, nearZ, farZ);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_NO
X  return glms_perspective_rh_no(fovy, aspect, nearZ, farZ);
X#endif
X}
X
X/*!
X * @brief extend perspective projection matrix's far distance
X *
X * NOTE: if you dodn't want to create new matrix then use array api on struct.raw
X *       like glm_persp_move_far(prooj.raw, deltaFar) to avoid create new mat4
X *       each time
X *
X * this function does not guarantee far >= near, be aware of that!
X *
X * @param[in, out] proj      projection matrix to extend
X * @param[in]      deltaFar  distance from existing far (negative to shink)
X */
XCGLM_INLINE
Xmat4s
Xglms_persp_move_far(mat4s proj, float deltaFar) {
X#if CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_ZO
X  return glms_persp_move_far_lh_zo(proj, deltaFar);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_NO
X  return glms_persp_move_far_lh_no(proj, deltaFar);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_ZO
X  return glms_persp_move_far_rh_zo(proj, deltaFar);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_NO
X  return glms_persp_move_far_rh_no(proj, deltaFar);
X#endif
X}
X
X/*!
X * @brief set up perspective projection matrix with default near/far
X *        and angle values
X *
X * @param[in]  aspect aspect ratio ( width / height )
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_perspective_default(float aspect) {
X#if CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_ZO
X  return glms_perspective_default_lh_zo(aspect);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_NO
X  return glms_perspective_default_lh_no(aspect);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_ZO
X  return glms_perspective_default_rh_zo(aspect);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_NO
X  return glms_perspective_default_rh_no(aspect);
X#endif
X}
X
X/*!
X * @brief resize perspective matrix by aspect ratio ( width / height )
X *        this makes very easy to resize proj matrix when window /viewport
X *        reized
X *
X * NOTE: if you dodn't want to create new matrix then use array api on struct.raw
X *       like glms_perspective_resize(proj.raw, aspect) to avoid create new mat4
X *       each time
X *
X * @param[in, out] proj   perspective projection matrix
X * @param[in]      aspect aspect ratio ( width / height )
X */
XCGLM_INLINE
Xmat4s
Xglms_perspective_resize(mat4s proj, float aspect) {
X#if CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_ZO
X  return glms_perspective_resize_lh_zo(proj, aspect);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_NO
X  return glms_perspective_resize_lh_no(proj, aspect);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_ZO
X  return glms_perspective_resize_rh_zo(proj, aspect);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_NO
X  return glms_perspective_resize_rh_no(proj, aspect);
X#endif
X}
X
X/*!
X * @brief set up view matrix
X *
X * NOTE: The UP vector must not be parallel to the line of sight from
X *       the eye point to the reference point
X *
X * @param[in]  eye    eye vector
X * @param[in]  center center vector
X * @param[in]  up     up vector
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_lookat(vec3s eye, vec3s center, vec3s up) {
X#if CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_ZO
X  return glms_lookat_lh_zo(eye, center, up);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_NO
X  return glms_lookat_lh_no(eye, center, up);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_ZO
X  return glms_lookat_rh_zo(eye, center, up);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_NO
X  return glms_lookat_rh_no(eye, center, up);
X#endif
X}
X
X/*!
X * @brief set up view matrix
X *
X * convenient wrapper for lookat: if you only have direction not target self
X * then this might be useful. Because you need to get target from direction.
X *
X * NOTE: The UP vector must not be parallel to the line of sight from
X *       the eye point to the reference point
X *
X * @param[in]  eye    eye vector
X * @param[in]  dir    direction vector
X * @param[in]  up     up vector
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_look(vec3s eye, vec3s dir, vec3s up) {
X#if CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_ZO
X  return glms_look_lh_zo(eye, dir, up);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_NO
X  return glms_look_lh_no(eye, dir, up);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_ZO
X  return glms_look_rh_zo(eye, dir, up);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_NO
X  return glms_look_rh_no(eye, dir, up);
X#endif
X}
X
X/*!
X * @brief set up view matrix
X *
X * convenient wrapper for look: if you only have direction and if you don't
X * care what UP vector is then this might be useful to create view matrix
X *
X * @param[in]  eye    eye vector
X * @param[in]  dir    direction vector
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_look_anyup(vec3s eye, vec3s dir) {
X#if CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_ZO
X  return glms_look_anyup_lh_zo(eye, dir);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_NO
X  return glms_look_anyup_lh_no(eye, dir);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_ZO
X  return glms_look_anyup_rh_zo(eye, dir);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_NO
X  return glms_look_anyup_rh_no(eye, dir);
X#endif
X}
X
X/*!
X * @brief decomposes frustum values of perspective projection.
X *
X * @param[in]  proj    perspective projection matrix
X * @param[out] nearZ   near
X * @param[out] farZ    far
X * @param[out] top     top
X * @param[out] bottom  bottom
X * @param[out] left    left
X * @param[out] right   right
X */
XCGLM_INLINE
Xvoid
Xglms_persp_decomp(mat4s proj,
X                  float * __restrict nearZ, float * __restrict farZ,
X                  float * __restrict top,   float * __restrict bottom,
X                  float * __restrict left,  float * __restrict right) {
X#if CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_ZO
X  glms_persp_decomp_lh_zo(proj, nearZ, farZ, top, bottom, left, right);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_NO
X  glms_persp_decomp_lh_no(proj, nearZ, farZ, top, bottom, left, right);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_ZO
X  glms_persp_decomp_rh_zo(proj, nearZ, farZ, top, bottom, left, right);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_NO
X  glms_persp_decomp_rh_no(proj, nearZ, farZ, top, bottom, left, right);
X#endif
X}
X
X/*!
X * @brief decomposes frustum values of perspective projection.
X *        this makes easy to get all values at once
X *
X * @param[in]  proj   perspective projection matrix
X * @param[out] dest   array
X */
XCGLM_INLINE
Xvoid
Xglms_persp_decompv(mat4s proj, float dest[6]) {
X#if CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_ZO
X  glms_persp_decompv_lh_zo(proj, dest);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_NO
X  glms_persp_decompv_lh_no(proj, dest);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_ZO
X  glms_persp_decompv_rh_zo(proj, dest);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_NO
X  glms_persp_decompv_rh_no(proj, dest);
X#endif
X}
X
X/*!
X * @brief decomposes left and right values of perspective projection.
X *        x stands for x axis (left / right axis)
X *
X * @param[in]  proj  perspective projection matrix
X * @param[out] left  left
X * @param[out] right right
X */
XCGLM_INLINE
Xvoid
Xglms_persp_decomp_x(mat4s proj,
X                    float * __restrict left,
X                    float * __restrict right) {
X#if CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_ZO
X  glms_persp_decomp_x_lh_zo(proj, left, right);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_NO
X  glms_persp_decomp_x_lh_no(proj, left, right);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_ZO
X  glms_persp_decomp_x_rh_zo(proj, left, right);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_NO
X  glms_persp_decomp_x_rh_no(proj, left, right);
X#endif
X}
X
X/*!
X * @brief decomposes top and bottom values of perspective projection.
X *        y stands for y axis (top / botom axis)
X *
X * @param[in]  proj   perspective projection matrix
X * @param[out] top    top
X * @param[out] bottom bottom
X */
XCGLM_INLINE
Xvoid
Xglms_persp_decomp_y(mat4s proj,
X                    float * __restrict top,
X                    float * __restrict bottom) {
X#if CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_ZO
X  glms_persp_decomp_y_lh_zo(proj, top, bottom);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_NO
X  glms_persp_decomp_y_lh_no(proj, top, bottom);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_ZO
X  glms_persp_decomp_y_rh_zo(proj, top, bottom);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_NO
X  glms_persp_decomp_y_rh_no(proj, top, bottom);
X#endif
X}
X
X/*!
X * @brief decomposes near and far values of perspective projection.
X *        z stands for z axis (near / far axis)
X *
X * @param[in]  proj    perspective projection matrix
X * @param[out] nearZ   near
X * @param[out] farZ    far
X */
XCGLM_INLINE
Xvoid
Xglms_persp_decomp_z(mat4s proj,
X                    float * __restrict nearZ,
X                    float * __restrict farZ) {
X#if CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_ZO
X  glms_persp_decomp_z_lh_zo(proj, nearZ, farZ);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_NO
X  glms_persp_decomp_z_lh_no(proj, nearZ, farZ);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_ZO
X  glms_persp_decomp_z_rh_zo(proj, nearZ, farZ);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_NO
X  glms_persp_decomp_z_rh_no(proj, nearZ, farZ);
X#endif
X}
X
X/*!
X * @brief decomposes far value of perspective projection.
X *
X * @param[in]  proj   perspective projection matrix
X * @param[out] farZ   far
X */
XCGLM_INLINE
Xvoid
Xglms_persp_decomp_far(mat4s proj, float * __restrict farZ) {
X#if CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_ZO
X  glms_persp_decomp_far_lh_zo(proj, farZ);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_NO
X  glms_persp_decomp_far_lh_no(proj, farZ);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_ZO
X  glms_persp_decomp_far_rh_zo(proj, farZ);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_NO
X  glms_persp_decomp_far_rh_no(proj, farZ);
X#endif
X}
X
X/*!
X * @brief decomposes near value of perspective projection.
X *
X * @param[in]  proj  perspective projection matrix
X * @param[out] nearZ near
X */
XCGLM_INLINE
Xvoid
Xglms_persp_decomp_near(mat4s proj, float * __restrict nearZ) {
X#if CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_ZO
X  glms_persp_decomp_near_lh_zo(proj, nearZ);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_NO
X  glms_persp_decomp_near_lh_no(proj, nearZ);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_ZO
X  glms_persp_decomp_near_rh_zo(proj, nearZ);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_NO
X  glms_persp_decomp_near_rh_no(proj, nearZ);
X#endif
X}
X
X/*!
X * @brief returns field of view angle along the Y-axis (in radians)
X *
X * if you need to degrees, use glm_deg to convert it or use this:
X * fovy_deg = glm_deg(glm_persp_fovy(projMatrix))
X *
X * @param[in] proj perspective projection matrix
X */
XCGLM_INLINE
Xfloat
Xglms_persp_fovy(mat4s proj) {
X#if CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_ZO
X  return glms_persp_fovy_lh_zo(proj);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_NO
X  return glms_persp_fovy_lh_no(proj);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_ZO
X  return glms_persp_fovy_rh_zo(proj);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_NO
X  return glms_persp_fovy_rh_no(proj);
X#endif
X}
X
X/*!
X * @brief returns aspect ratio of perspective projection
X *
X * @param[in] proj perspective projection matrix
X */
XCGLM_INLINE
Xfloat
Xglms_persp_aspect(mat4s proj) {
X#if CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_ZO
X  return glms_persp_aspect_lh_zo(proj);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_NO
X  return glms_persp_aspect_lh_no(proj);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_ZO
X  return glms_persp_aspect_rh_zo(proj);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_NO
X  return glms_persp_aspect_rh_no(proj);
X#endif
X}
X
X/*!
X * @brief returns sizes of near and far planes of perspective projection
X *
X * @param[in]  proj perspective projection matrix
X * @param[in]  fovy fovy (see brief)
X * @returns    sizes as vector, sizes order: [Wnear, Hnear, Wfar, Hfar]
X */
XCGLM_INLINE
Xvec4s
Xglms_persp_sizes(mat4s proj, float fovy) {
X#if CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_ZO
X  return glms_persp_sizes_lh_zo(proj, fovy);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_LH_NO
X  return glms_persp_sizes_lh_no(proj, fovy);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_ZO
X  return glms_persp_sizes_rh_zo(proj, fovy);
X#elif CGLM_CONFIG_CLIP_CONTROL == CGLM_CLIP_CONTROL_RH_NO
X  return glms_persp_sizes_rh_no(proj, fovy);
X#endif
X}
X
X#endif /* cglms_cam_h */
d0f41fdfdb1ad1c3e0a84bdeb0e7bd0c
echo x - cglm/struct/quat.h
sed 's/^X//' >cglm/struct/quat.h << '6c776d451d54f4a3135cff51d9eaf38c'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Macros:
X   GLMS_QUAT_IDENTITY_INIT
X   GLMS_QUAT_IDENTITY
X
X Functions:
X   CGLM_INLINE versors glms_quat_identity(void)
X   CGLM_INLINE void    glms_quat_identity_array(versor *q, size_t count)
X   CGLM_INLINE versors glms_quat_init(float x, float y, float z, float w)
X   CGLM_INLINE versors glms_quatv(float angle, vec3s axis)
X   CGLM_INLINE versors glms_quat(float angle, float x, float y, float z)
X   CGLM_INLINE versors glms_quat_from_vecs(vec3s a, vec3s b)
X   CGLM_INLINE float   glms_quat_norm(versors q)
X   CGLM_INLINE versors glms_quat_normalize(versors q)
X   CGLM_INLINE float   glms_quat_dot(versors p, versors q)
X   CGLM_INLINE versors glms_quat_conjugate(versors q)
X   CGLM_INLINE versors glms_quat_inv(versors q)
X   CGLM_INLINE versors glms_quat_add(versors p, versors q)
X   CGLM_INLINE versors glms_quat_sub(versors p, versors q)
X   CGLM_INLINE vec3s   glms_quat_imagn(versors q)
X   CGLM_INLINE float   glms_quat_imaglen(versors q)
X   CGLM_INLINE float   glms_quat_angle(versors q)
X   CGLM_INLINE vec3s   glms_quat_axis(versors q)
X   CGLM_INLINE versors glms_quat_mul(versors p, versors q)
X   CGLM_INLINE mat4s   glms_quat_mat4(versors q)
X   CGLM_INLINE mat4s   glms_quat_mat4t(versors q)
X   CGLM_INLINE mat3s   glms_quat_mat3(versors q)
X   CGLM_INLINE mat3s   glms_quat_mat3t(versors q)
X   CGLM_INLINE versors glms_quat_lerp(versors from, versors to, float t)
X   CGLM_INLINE versors glms_quat_lerpc(versors from, versors to, float t)
X   CGLM_INLINE versors glms_quat_nlerp(versors from, versors to, float t)
X   CGLM_INLINE versors glms_quat_slerp(versors from, versors to, float t)
X   CGLM_INLINE mat4s.  glms_quat_look(vec3s eye, versors ori)
X   CGLM_INLINE versors glms_quat_for(vec3s dir, vec3s fwd, vec3s up)
X   CGLM_INLINE versors glms_quat_forp(vec3s from, vec3s to, vec3s fwd, vec3s up)
X   CGLM_INLINE vec3s   glms_quat_rotatev(versors q, vec3s v)
X   CGLM_INLINE mat4s   glms_quat_rotate(mat4s m, versors q)
X   CGLM_INLINE mat4s   glms_quat_rotate_at(mat4s m, versors q, vec3s pivot)
X   CGLM_INLINE mat4s   glms_quat_rotate_atm(versors q, vec3s pivot)
X   CGLM_INLINE versors glms_quat_make(float * restrict src)
X */
X
X#ifndef cglms_quat_h
X#define cglms_quat_h
X
X#include "../common.h"
X#include "../types-struct.h"
X#include "../plane.h"
X#include "../quat.h"
X
X/* api definition */
X#define glms_quat_(NAME) CGLM_STRUCTAPI(quat, NAME)
X
X/*
X * IMPORTANT:
X * ----------------------------------------------------------------------------
X * cglm stores quat as [x, y, z, w] since v0.3.6
X *
X * it was [w, x, y, z] before v0.3.6 it has been changed to [x, y, z, w]
X * with v0.3.6 version.
X * ----------------------------------------------------------------------------
X */
X
X#define GLMS_QUAT_IDENTITY_INIT  {GLM_QUAT_IDENTITY_INIT}
X#define GLMS_QUAT_IDENTITY       ((versors)GLMS_QUAT_IDENTITY_INIT)
X
X/*!
X * @brief makes given quat to identity
X *
X * @returns identity quaternion
X */
XCGLM_INLINE
Xversors
Xglms_quat_(identity)(void) {
X  versors dest;
X  glm_quat_identity(dest.raw);
X  return dest;
X}
X
X/*!
X * @brief make given quaternion array's each element identity quaternion
X *
X * @param[in, out]  q     quat array (must be aligned (16)
X *                        if alignment is not disabled)
X *
X * @param[in]       count count of quaternions
X */
XCGLM_INLINE
Xvoid
Xglms_quat_(identity_array)(versors * __restrict q, size_t count) {
X  CGLM_ALIGN(16) versor v = GLM_QUAT_IDENTITY_INIT;
X  size_t i;
X
X  for (i = 0; i < count; i++) {
X    glm_vec4_copy(v, q[i].raw);
X  }
X}
X
X/*!
X * @brief inits quaterion with raw values
X *
X * @param[in]   x     x
X * @param[in]   y     y
X * @param[in]   z     z
X * @param[in]   w     w (real part)
X * @returns quaternion
X */
XCGLM_INLINE
Xversors
Xglms_quat_(init)(float x, float y, float z, float w) {
X  versors dest;
X  glm_quat_init(dest.raw, x, y, z, w);
X  return dest;
X}
X
X/*!
X * @brief creates NEW quaternion with axis vector
X *
X * @param[in]   angle angle (radians)
X * @param[in]   axis  axis
X * @returns quaternion
X */
XCGLM_INLINE
Xversors
Xglms_quatv(float angle, vec3s axis) {
X  versors dest;
X  glm_quatv(dest.raw, angle, axis.raw);
X  return dest;
X}
X
X/*!
X * @brief creates NEW quaternion with individual axis components
X *
X * @param[in]   angle angle (radians)
X * @param[in]   x     axis.x
X * @param[in]   y     axis.y
X * @param[in]   z     axis.z
X * @returns quaternion
X */
XCGLM_INLINE
Xversors
Xglms_quat(float angle, float x, float y, float z) {
X  versors dest;
X  glm_quat(dest.raw, angle, x, y, z);
X  return dest;
X}
X
X/*!
X * @brief compute quaternion rotating vector A to vector B
X *
X * @param[in]   a     vec3 (must have unit length)
X * @param[in]   b     vec3 (must have unit length)
X * @returns     quaternion (of unit length)
X */
XCGLM_INLINE
Xversors
Xglms_quat_(from_vecs)(vec3s a, vec3s b) {
X  versors dest;
X  glm_quat_from_vecs(a.raw, b.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief returns norm (magnitude) of quaternion
X *
X * @param[in]  q  quaternion
X */
XCGLM_INLINE
Xfloat
Xglms_quat_(norm)(versors q) {
X  return glm_quat_norm(q.raw);
X}
X
X/*!
X * @brief normalize quaternion
X *
X * @param[in]  q  quaternion
X * @returns    quaternion
X */
XCGLM_INLINE
Xversors
Xglms_quat_(normalize)(versors q) {
X  versors dest;
X  glm_quat_normalize_to(q.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief dot product of two quaternion
X *
X * @param[in]  p  quaternion 1
X * @param[in]  q  quaternion 2
X * @returns    dot product
X */
XCGLM_INLINE
Xfloat
Xglms_quat_(dot)(versors p, versors q) {
X  return glm_quat_dot(p.raw, q.raw);
X}
X
X/*!
X * @brief conjugate of quaternion
X *
X * @param[in]   q     quaternion
X * @returns    conjugate
X */
XCGLM_INLINE
Xversors
Xglms_quat_(conjugate)(versors q) {
X  versors dest;
X  glm_quat_conjugate(q.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief inverse of non-zero quaternion
X *
X * @param[in]  q    quaternion
X * @returns    inverse quaternion
X */
XCGLM_INLINE
Xversors
Xglms_quat_(inv)(versors q) {
X  versors dest;
X  glm_quat_inv(q.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief add (componentwise) two quaternions and store result in dest
X *
X * @param[in]   p    quaternion 1
X * @param[in]   q    quaternion 2
X * @returns result quaternion
X */
XCGLM_INLINE
Xversors
Xglms_quat_(add)(versors p, versors q) {
X  versors dest;
X  glm_quat_add(p.raw, q.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief subtract (componentwise) two quaternions and store result in dest
X *
X * @param[in]   p    quaternion 1
X * @param[in]   q    quaternion 2
X * @returns result quaternion
X */
XCGLM_INLINE
Xversors
Xglms_quat_(sub)(versors p, versors q) {
X  versors dest;
X  glm_quat_sub(p.raw, q.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief returns normalized imaginary part of quaternion
X *
X * @param[in]   q    quaternion
X */
XCGLM_INLINE
Xvec3s
Xglms_quat_(imagn)(versors q) {
X  vec3s dest;
X  glm_normalize_to(q.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief returns length of imaginary part of quaternion
X *
X * @param[in]   q    quaternion
X */
XCGLM_INLINE
Xfloat
Xglms_quat_(imaglen)(versors q) {
X  return glm_quat_imaglen(q.raw);
X}
X
X/*!
X * @brief returns angle of quaternion
X *
X * @param[in]   q    quaternion
X */
XCGLM_INLINE
Xfloat
Xglms_quat_(angle)(versors q) {
X  return glm_quat_angle(q.raw);
X}
X
X/*!
X * @brief axis of quaternion
X *
X * @param[in]   q    quaternion
X * @returns axis of quaternion
X */
XCGLM_INLINE
Xvec3s
Xglms_quat_(axis)(versors q) {
X  vec3s dest;
X  glm_quat_axis(q.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief multiplies two quaternion and stores result in dest
X *        this is also called Hamilton Product
X *
X * According to WikiPedia:
X * The product of two rotation quaternions [clarification needed] will be
X * equivalent to the rotation q followed by the rotation p
X *
X * @param[in]   p     quaternion 1
X * @param[in]   q     quaternion 2
X * @returns  result quaternion
X */
XCGLM_INLINE
Xversors
Xglms_quat_(mul)(versors p, versors q) {
X  versors dest;
X  glm_quat_mul(p.raw, q.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief convert quaternion to mat4
X *
X * @param[in]   q     quaternion
X * @returns  result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_quat_(mat4)(versors q) {
X  mat4s dest;
X  glm_quat_mat4(q.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief convert quaternion to mat4 (transposed)
X *
X * @param[in]   q     quaternion
X * @returns  result matrix as transposed
X */
XCGLM_INLINE
Xmat4s
Xglms_quat_(mat4t)(versors q) {
X  mat4s dest;
X  glm_quat_mat4t(q.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief convert quaternion to mat3
X *
X * @param[in]   q     quaternion
X * @returns  result matrix
X */
XCGLM_INLINE
Xmat3s
Xglms_quat_(mat3)(versors q) {
X  mat3s dest;
X  glm_quat_mat3(q.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief convert quaternion to mat3 (transposed)
X *
X * @param[in]   q     quaternion
X * @returns  result matrix
X */
XCGLM_INLINE
Xmat3s
Xglms_quat_(mat3t)(versors q) {
X  mat3s dest;
X  glm_quat_mat3t(q.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief interpolates between two quaternions
X *        using linear interpolation (LERP)
X *
X * @param[in]   from  from
X * @param[in]   to    to
X * @param[in]   t     interpolant (amount)
X * @returns  result quaternion
X */
XCGLM_INLINE
Xversors
Xglms_quat_(lerp)(versors from, versors to, float t) {
X  versors dest;
X  glm_quat_lerp(from.raw, to.raw, t, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief interpolates between two quaternions
X *        using linear interpolation (LERP)
X *
X * @param[in]   from  from
X * @param[in]   to    to
X * @param[in]   t     interpolant (amount) clamped between 0 and 1
X * @returns  result quaternion
X */
XCGLM_INLINE
Xversors
Xglms_quat_(lerpc)(versors from, versors to, float t) {
X  versors dest;
X  glm_quat_lerpc(from.raw, to.raw, t, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief interpolates between two quaternions
X *        taking the shortest rotation path using
X *        normalized linear interpolation (NLERP)
X *
X * @param[in]   from  from
X * @param[in]   to    to
X * @param[in]   t     interpolant (amount)
X * @returns result quaternion
X */
XCGLM_INLINE
Xversors
Xglms_quat_(nlerp)(versors from, versors to, float t) {
X  versors dest;
X  glm_quat_nlerp(from.raw, to.raw, t, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief interpolates between two quaternions
X *        using spherical linear interpolation (SLERP)
X *
X * @param[in]   from  from
X * @param[in]   to    to
X * @param[in]   t     amout
X * @returns result quaternion
X */
XCGLM_INLINE
Xversors
Xglms_quat_(slerp)(versors from, versors to, float t) {
X  versors dest;
X  glm_quat_slerp(from.raw, to.raw, t, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief creates view matrix using quaternion as camera orientation
X *
X * @param[in]   eye   eye
X * @param[in]   ori   orientation in world space as quaternion
X * @returns  view matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_quat_(look)(vec3s eye, versors ori) {
X  mat4s dest;
X  glm_quat_look(eye.raw, ori.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief creates look rotation quaternion
X *
X * @param[in]   dir   direction to look
X * @param[in]   up    up vector
X * @returns  destination quaternion
X */
XCGLM_INLINE
Xversors
Xglms_quat_(for)(vec3s dir, vec3s up) {
X  versors dest;
X  glm_quat_for(dir.raw, up.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief creates look rotation quaternion using source and
X *        destination positions p suffix stands for position
X *
X * @param[in]   from  source point
X * @param[in]   to    destination point
X * @param[in]   up    up vector
X * @returns  destination quaternion
X */
XCGLM_INLINE
Xversors
Xglms_quat_(forp)(vec3s from, vec3s to, vec3s up) {
X  versors dest;
X  glm_quat_forp(from.raw, to.raw, up.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief rotate vector using using quaternion
X *
X * @param[in]   q     quaternion
X * @param[in]   v     vector to rotate
X * @returns  rotated vector
X */
XCGLM_INLINE
Xvec3s
Xglms_quat_(rotatev)(versors q, vec3s v) {
X  vec3s dest;
X  glm_quat_rotatev(q.raw, v.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief rotate existing transform matrix using quaternion
X *
X * @param[in]   m     existing transform matrix
X * @param[in]   q     quaternion
X * @returns  rotated matrix/transform
X */
XCGLM_INLINE
Xmat4s
Xglms_quat_(rotate)(mat4s m, versors q) {
X  glm_quat_rotate(m.raw, q.raw, m.raw);
X  return m;
X}
X
X/*!
X * @brief rotate existing transform matrix using quaternion at pivot point
X *
X * @param[in, out]   m     existing transform matrix
X * @param[in]        q     quaternion
X * @returns pivot
X */
XCGLM_INLINE
Xmat4s
Xglms_quat_(rotate_at)(mat4s m, versors q, vec3s pivot) {
X  glm_quat_rotate_at(m.raw, q.raw, pivot.raw);
X  return m;
X}
X
X/*!
X * @brief rotate NEW transform matrix using quaternion at pivot point
X *
X * this creates rotation matrix, it assumes you don't have a matrix
X *
X * this should work faster than glm_quat_rotate_at because it reduces
X * one glm_translate.
X *
X * @param[in]   q     quaternion
X * @returns pivot
X */
XCGLM_INLINE
Xmat4s
Xglms_quat_(rotate_atm)(versors q, vec3s pivot) {
X  mat4s dest;
X  glm_quat_rotate_atm(dest.raw, q.raw, pivot.raw);
X  return dest;
X}
X
X/*!
X * @brief Create CGLM quaternion from pointer
X *
X * @param[in]  src  pointer to an array of floats
X * @returns constructed quaternion from raw pointer
X */
XCGLM_INLINE
Xversors
Xglms_quat_(make)(float * __restrict src) {
X  versors dest;
X  glm_quat_make(src, dest.raw);
X  return dest;
X}
X
X#endif /* cglms_quat_h */
6c776d451d54f4a3135cff51d9eaf38c
echo x - cglm/struct/euler.h
sed 's/^X//' >cglm/struct/euler.h << '9644eddca827cfe9ccfca6fd5d309863'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X NOTE:
X  angles must be passed as [X-Angle, Y-Angle, Z-angle] order
X  For instance you don't pass angles as [Z-Angle, X-Angle, Y-angle] to
X  glm_euler_zxy funciton, All RELATED functions accept angles same order
X  which is [X, Y, Z].
X */
X
X/*
X Types:
X   enum glm_euler_seq
X
X Functions:
X   CGLM_INLINE vec3s glms_euler_angles(mat4s m)
X   CGLM_INLINE mat4s glms_euler_xyz(vec3s angles)
X   CGLM_INLINE mat4s glms_euler_xzy(vec3s angles)
X   CGLM_INLINE mat4s glms_euler_yxz(vec3s angles)
X   CGLM_INLINE mat4s glms_euler_yzx(vec3s angles)
X   CGLM_INLINE mat4s glms_euler_zxy(vec3s angles)
X   CGLM_INLINE mat4s glms_euler_zyx(vec3s angles)
X   CGLM_INLINE mat4s glms_euler_by_order(vec3s angles, glm_euler_seq ord)
X */
X
X#ifndef cglms_euler_h
X#define cglms_euler_h
X
X#include "../common.h"
X#include "../types-struct.h"
X#include "../euler.h"
X
X/*!
X * @brief extract euler angles (in radians) using xyz order
X *
X * @param[in]  m    affine transform
X * @returns angles vector [x, y, z]
X */
XCGLM_INLINE
Xvec3s
Xglms_euler_angles(mat4s m) {
X  vec3s dest;
X  glm_euler_angles(m.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief build rotation matrix from euler angles
X *
X * @param[in]  angles angles as vector [Xangle, Yangle, Zangle]
X * @returns rotation matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_euler_xyz(vec3s angles) {
X  mat4s dest;
X  glm_euler_xyz(angles.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief build rotation matrix from euler angles
X *
X * @param[in]  angles angles as vector [Xangle, Yangle, Zangle]
X * @returns rotation matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_euler_xzy(vec3s angles) {
X  mat4s dest;
X  glm_euler_xzy(angles.raw, dest.raw);
X  return dest;
X}
X
X
X/*!
X * @brief build rotation matrix from euler angles
X *
X * @param[in]  angles angles as vector [Xangle, Yangle, Zangle]
X * @returns rotation matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_euler_yxz(vec3s angles) {
X  mat4s dest;
X  glm_euler_yxz(angles.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief build rotation matrix from euler angles
X *
X * @param[in]  angles angles as vector [Xangle, Yangle, Zangle]
X * @returns rotation matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_euler_yzx(vec3s angles) {
X  mat4s dest;
X  glm_euler_yzx(angles.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief build rotation matrix from euler angles
X *
X * @param[in]  angles angles as vector [Xangle, Yangle, Zangle]
X * @returns rotation matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_euler_zxy(vec3s angles) {
X  mat4s dest;
X  glm_euler_zxy(angles.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief build rotation matrix from euler angles
X *
X * @param[in]  angles angles as vector [Xangle, Yangle, Zangle]
X * @returns rotation matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_euler_zyx(vec3s angles) {
X  mat4s dest;
X  glm_euler_zyx(angles.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief build rotation matrix from euler angles
X *
X * @param[in]  angles angles as vector [Xangle, Yangle, Zangle]
X * @param[in]  ord    euler order
X * @returns rotation matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_euler_by_order(vec3s angles, glm_euler_seq ord) {
X  mat4s dest;
X  glm_euler_by_order(angles.raw, ord, dest.raw);
X  return dest;
X}
X
X#endif /* cglms_euler_h */
9644eddca827cfe9ccfca6fd5d309863
echo x - cglm/struct/plane.h
sed 's/^X//' >cglm/struct/plane.h << 'f6526be472b034521a7b938e014ea3f8'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglms_planes_h
X#define cglms_planes_h
X
X#include "../common.h"
X#include "../types-struct.h"
X#include "../plane.h"
X#include "vec4.h"
X
X/*
X Plane equation:  Ax + By + Cz + D = 0;
X
X It stored in vec4 as [A, B, C, D]. (A, B, C) is normal and D is distance
X*/
X
X/*
X Functions:
X   CGLM_INLINE vec4s glms_plane_normalize(vec4s plane);
X */
X
X/*!
X * @brief normalizes a plane
X *
X * @param[in] plane plane to normalize
X * @returns         normalized plane
X */
XCGLM_INLINE
Xvec4s
Xglms_plane_normalize(vec4s plane) {
X  glm_plane_normalize(plane.raw);
X  return plane;
X}
X
X#endif /* cglms_planes_h */
f6526be472b034521a7b938e014ea3f8
echo x - cglm/struct/frustum.h
sed 's/^X//' >cglm/struct/frustum.h << '94ee749c1e6996dcd214cbab40eadf04'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglms_frustums_h
X#define cglms_frustums_h
X
X#include "../common.h"
X#include "../types-struct.h"
X#include "../frustum.h"
X#include "plane.h"
X#include "vec3.h"
X#include "vec4.h"
X#include "mat4.h"
X
X/* you can override clip space coords
X   but you have to provide all with same name
X   e.g.: define GLM_CSCOORD_LBN {0.0f, 0.0f, 1.0f, 1.0f} */
X#ifndef GLM_CUSTOM_CLIPSPACE
X
X/* near */
X#define GLMS_CSCOORD_LBN {-1.0f, -1.0f, -1.0f, 1.0f}
X#define GLMS_CSCOORD_LTN {-1.0f,  1.0f, -1.0f, 1.0f}
X#define GLMS_CSCOORD_RTN { 1.0f,  1.0f, -1.0f, 1.0f}
X#define GLMS_CSCOORD_RBN { 1.0f, -1.0f, -1.0f, 1.0f}
X
X/* far */
X#define GLMS_CSCOORD_LBF {-1.0f, -1.0f,  1.0f, 1.0f}
X#define GLMS_CSCOORD_LTF {-1.0f,  1.0f,  1.0f, 1.0f}
X#define GLMS_CSCOORD_RTF { 1.0f,  1.0f,  1.0f, 1.0f}
X#define GLMS_CSCOORD_RBF { 1.0f, -1.0f,  1.0f, 1.0f}
X
X#endif
X
X/*!
X * @brief extracts view frustum planes
X *
X * planes' space:
X *  1- if m = proj:     View Space
X *  2- if m = viewProj: World Space
X *  3- if m = MVP:      Object Space
X *
X * You probably want to extract planes in world space so use viewProj as m
X * Computing viewProj:
X *   glm_mat4_mul(proj, view, viewProj);
X *
X * Exracted planes order: [left, right, bottom, top, near, far]
X *
X * @param[in]  m    matrix (see brief)
X * @param[out] dest extracted view frustum planes (see brief)
X */
XCGLM_INLINE
Xvoid
Xglms_frustum_planes(mat4s m, vec4s dest[6]) {
X  vec4 rawDest[6];
X  glm_frustum_planes(m.raw, rawDest);
X  glms_vec4_(pack)(dest, rawDest, 6);
X}
X
X/*!
X * @brief extracts view frustum corners using clip-space coordinates
X *
X * corners' space:
X *  1- if m = invViewProj: World Space
X *  2- if m = invMVP:      Object Space
X *
X * You probably want to extract corners in world space so use invViewProj
X * Computing invViewProj:
X *   glm_mat4_mul(proj, view, viewProj);
X *   ...
X *   glm_mat4_inv(viewProj, invViewProj);
X *
X * if you have a near coord at i index, you can get it's far coord by i + 4
X *
X * Find center coordinates:
X *   for (j = 0; j < 4; j++) {
X *     glm_vec3_center(corners[i], corners[i + 4], centerCorners[i]);
X *   }
X *
X * @param[in]  invMat matrix (see brief)
X * @param[out] dest   exracted view frustum corners (see brief)
X */
XCGLM_INLINE
Xvoid
Xglms_frustum_corners(mat4s invMat, vec4s dest[8]) {
X  vec4 rawDest[8];
X  glm_frustum_corners(invMat.raw, rawDest);
X  glms_vec4_(pack)(dest, rawDest, 8);
X}
X
X/*!
X * @brief finds center of view frustum
X *
X * @param[in]  corners view frustum corners
X * @returns            view frustum center
X */
XCGLM_INLINE
Xvec4s
Xglms_frustum_center(vec4s corners[8]) {
X  vec4 rawCorners[8];
X  vec4s r;
X
X  glms_vec4_(unpack)(rawCorners, corners, 8);
X  glm_frustum_center(rawCorners, r.raw);
X  return r;
X}
X
X/*!
X * @brief finds bounding box of frustum relative to given matrix e.g. view mat
X *
X * @param[in]  corners view frustum corners
X * @param[in]  m       matrix to convert existing conners
X * @param[out] box     bounding box as array [min, max]
X */
XCGLM_INLINE
Xvoid
Xglms_frustum_box(vec4s corners[8], mat4s m, vec3s box[2]) {
X  vec4 rawCorners[8];
X  vec3 rawBox[2];
X
X  glms_vec4_(unpack)(rawCorners, corners, 8);
X  glm_frustum_box(rawCorners, m.raw, rawBox);
X  glms_vec3_(pack)(box, rawBox, 2);
X}
X
X/*!
X * @brief finds planes corners which is between near and far planes (parallel)
X *
X * this will be helpful if you want to split a frustum e.g. CSM/PSSM. This will
X * find planes' corners but you will need to one more plane.
X * Actually you have it, it is near, far or created previously with this func ;)
X *
X * @param[in]  corners view  frustum corners
X * @param[in]  splitDist     split distance
X * @param[in]  farDist       far distance (zFar)
X * @param[out] planeCorners  plane corners [LB, LT, RT, RB]
X */
XCGLM_INLINE
Xvoid
Xglms_frustum_corners_at(vec4s corners[8],
X                        float splitDist,
X                        float farDist,
X                        vec4s planeCorners[4]) {
X  vec4 rawCorners[8];
X  vec4 rawPlaneCorners[4];
X
X  glms_vec4_(unpack)(rawCorners, corners, 8);
X  glm_frustum_corners_at(rawCorners, splitDist, farDist, rawPlaneCorners);
X  glms_vec4_(pack)(planeCorners, rawPlaneCorners, 8);
X}
X
X#endif /* cglms_frustums_h */
94ee749c1e6996dcd214cbab40eadf04
echo x - cglm/struct/box.h
sed 's/^X//' >cglm/struct/box.h << '4df42ab649e608dadfbb255c8264d409'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglms_boxs_h
X#define cglms_boxs_h
X
X#include "../common.h"
X#include "../types-struct.h"
X#include "../box.h"
X#include "vec3.h"
X#include "vec4.h"
X#include "mat4.h"
X
X/* api definition */
X#define glms_aabb_(NAME) CGLM_STRUCTAPI(aabb, NAME)
X
X/*!
X * @brief apply transform to Axis-Aligned Bounding Box
X *
X * @param[in]  box  bounding box
X * @param[in]  m    transform matrix
X * @param[out] dest transformed bounding box
X */
XCGLM_INLINE
Xvoid
Xglms_aabb_(transform)(vec3s box[2], mat4s m, vec3s dest[2]) {
X  vec3 rawBox[2];
X  vec3 rawDest[2];
X
X  glms_vec3_(unpack)(rawBox, box, 2);
X  glm_aabb_transform(rawBox, m.raw, rawDest);
X  glms_vec3_(pack)(dest, rawDest, 2);
X}
X
X/*!
X * @brief merges two AABB bounding box and creates new one
X *
X * two box must be in same space, if one of box is in different space then
X * you should consider to convert it's space by glm_box_space
X *
X * @param[in]  box1 bounding box 1
X * @param[in]  box2 bounding box 2
X * @param[out] dest merged bounding box
X */
XCGLM_INLINE
Xvoid
Xglms_aabb_(merge)(vec3s box1[2], vec3s box2[2], vec3s dest[2]) {
X  vec3 rawBox1[2];
X  vec3 rawBox2[2];
X  vec3 rawDest[2];
X
X  glms_vec3_(unpack)(rawBox1, box1, 2);
X  glms_vec3_(unpack)(rawBox2, box2, 2);
X  glm_aabb_merge(rawBox1, rawBox2, rawDest);
X  glms_vec3_(pack)(dest, rawDest, 2);
X}
X
X/*!
X * @brief crops a bounding box with another one.
X *
X * this could be useful for gettng a bbox which fits with view frustum and
X * object bounding boxes. In this case you crop view frustum box with objects
X * box
X *
X * @param[in]  box     bounding box 1
X * @param[in]  cropBox crop box
X * @param[out] dest    cropped bounding box
X */
XCGLM_INLINE
Xvoid
Xglms_aabb_(crop)(vec3s box[2], vec3s cropBox[2], vec3s dest[2]) {
X  vec3 rawBox[2];
X  vec3 rawCropBox[2];
X  vec3 rawDest[2];
X
X  glms_vec3_(unpack)(rawBox, box, 2);
X  glms_vec3_(unpack)(rawCropBox, cropBox, 2);
X  glm_aabb_crop(rawBox, rawCropBox, rawDest);
X  glms_vec3_(pack)(dest, rawDest, 2);
X}
X
X/*!
X * @brief crops a bounding box with another one.
X *
X * this could be useful for gettng a bbox which fits with view frustum and
X * object bounding boxes. In this case you crop view frustum box with objects
X * box
X *
X * @param[in]  box      bounding box
X * @param[in]  cropBox  crop box
X * @param[in]  clampBox miniumum box
X * @param[out] dest     cropped bounding box
X */
XCGLM_INLINE
Xvoid
Xglms_aabb_(crop_until)(vec3s box[2],
X                       vec3s cropBox[2],
X                       vec3s clampBox[2],
X                       vec3s dest[2]) {
X  glms_aabb_(crop)(box, cropBox, dest);
X  glms_aabb_(merge)(clampBox, dest, dest);
X}
X
X/*!
X * @brief check if AABB intersects with frustum planes
X *
X * this could be useful for frustum culling using AABB.
X *
X * OPTIMIZATION HINT:
X *  if planes order is similar to LEFT, RIGHT, BOTTOM, TOP, NEAR, FAR
X *  then this method should run even faster because it would only use two
X *  planes if object is not inside the two planes
X *  fortunately cglm extracts planes as this order! just pass what you got!
X *
X * @param[in]  box     bounding box
X * @param[in]  planes  frustum planes
X */
XCGLM_INLINE
Xbool
Xglms_aabb_(frustum)(vec3s box[2], vec4s planes[6]) {
X  vec3 rawBox[2];
X  vec4 rawPlanes[6];
X
X  glms_vec3_(unpack)(rawBox, box, 2);
X  glms_vec4_(unpack)(rawPlanes, planes, 6);
X  return glm_aabb_frustum(rawBox, rawPlanes);
X}
X
X/*!
X * @brief invalidate AABB min and max values
X *
X * @param[in, out]  box bounding box
X */
XCGLM_INLINE
Xvoid
Xglms_aabb_(invalidate)(vec3s box[2]) {
X  box[0] = glms_vec3_(broadcast)(FLT_MAX);
X  box[1] = glms_vec3_(broadcast)(-FLT_MAX);
X}
X
X/*!
X * @brief check if AABB is valid or not
X *
X * @param[in]  box bounding box
X */
XCGLM_INLINE
Xbool
Xglms_aabb_(isvalid)(vec3s box[2]) {
X  vec3 rawBox[2];
X  glms_vec3_(unpack)(rawBox, box, 2);
X  return glm_aabb_isvalid(rawBox);
X}
X
X/*!
X * @brief distance between of min and max
X *
X * @param[in]  box bounding box
X */
XCGLM_INLINE
Xfloat
Xglms_aabb_(size)(vec3s box[2]) {
X  return glm_vec3_distance(box[0].raw, box[1].raw);
X}
X
X/*!
X * @brief radius of sphere which surrounds AABB
X *
X * @param[in]  box bounding box
X */
XCGLM_INLINE
Xfloat
Xglms_aabb_(radius)(vec3s box[2]) {
X  return glms_aabb_(size)(box) * 0.5f;
X}
X
X/*!
X * @brief computes center point of AABB
X *
X * @param[in]   box  bounding box
X * @returns center of bounding box
X */
XCGLM_INLINE
Xvec3s
Xglms_aabb_(center)(vec3s box[2]) {
X  return glms_vec3_(center)(box[0], box[1]);
X}
X
X/*!
X * @brief check if two AABB intersects
X *
X * @param[in]   box    bounding box
X * @param[in]   other  other bounding box
X */
XCGLM_INLINE
Xbool
Xglms_aabb_(aabb)(vec3s box[2], vec3s other[2]) {
X  vec3 rawBox[2];
X  vec3 rawOther[2];
X
X  glms_vec3_(unpack)(rawBox, box, 2);
X  glms_vec3_(unpack)(rawOther, other, 2);
X  return glm_aabb_aabb(rawBox, rawOther);
X}
X
X/*!
X * @brief check if AABB intersects with sphere
X *
X * https://github.com/erich666/GraphicsGems/blob/master/gems/BoxSphere.c
X * Solid Box - Solid Sphere test.
X *
X * @param[in]   box    solid bounding box
X * @param[in]   s      solid sphere
X */
XCGLM_INLINE
Xbool
Xglms_aabb_(sphere)(vec3s box[2], vec4s s) {
X  vec3 rawBox[2];
X
X  glms_vec3_(unpack)(rawBox, box, 2);
X  return glm_aabb_sphere(rawBox, s.raw);
X}
X
X/*!
X * @brief check if point is inside of AABB
X *
X * @param[in]   box    bounding box
X * @param[in]   point  point
X */
XCGLM_INLINE
Xbool
Xglms_aabb_(point)(vec3s box[2], vec3s point) {
X  vec3 rawBox[2];
X
X  glms_vec3_(unpack)(rawBox, box, 2);
X  return glm_aabb_point(rawBox, point.raw);
X}
X
X/*!
X * @brief check if AABB contains other AABB
X *
X * @param[in]   box    bounding box
X * @param[in]   other  other bounding box
X */
XCGLM_INLINE
Xbool
Xglms_aabb_(contains)(vec3s box[2], vec3s other[2]) {
X  vec3 rawBox[2];
X  vec3 rawOther[2];
X
X  glms_vec3_(unpack)(rawBox, box, 2);
X  glms_vec3_(unpack)(rawOther, other, 2);
X  return glm_aabb_contains(rawBox, rawOther);
X}
X
X#endif /* cglms_boxs_h */
4df42ab649e608dadfbb255c8264d409
echo x - cglm/struct/project.h
sed 's/^X//' >cglm/struct/project.h << '14a0d20e87f21ff6658937b6f294d282'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglms_projects_h
X#define cglms_projects_h
X
X#include "../common.h"
X#include "../types-struct.h"
X#include "../project.h"
X#include "vec3.h"
X#include "vec4.h"
X#include "mat4.h"
X
X/*!
X * @brief maps the specified viewport coordinates into specified space [1]
X *        the matrix should contain projection matrix.
X *
X * if you don't have ( and don't want to have ) an inverse matrix then use
X * glm_unproject version. You may use existing inverse of matrix in somewhere
X * else, this is why glm_unprojecti exists to save save inversion cost
X *
X * [1] space:
X *  1- if m = invProj:     View Space
X *  2- if m = invViewProj: World Space
X *  3- if m = invMVP:      Object Space
X *
X * You probably want to map the coordinates into object space
X * so use invMVP as m
X *
X * Computing viewProj:
X *   glm_mat4_mul(proj, view, viewProj);
X *   glm_mat4_mul(viewProj, model, MVP);
X *   glm_mat4_inv(viewProj, invMVP);
X *
X * @param[in]  pos      point/position in viewport coordinates
X * @param[in]  invMat   matrix (see brief)
X * @param[in]  vp       viewport as [x, y, width, height]
X * @returns             unprojected coordinates
X */
XCGLM_INLINE
Xvec3s
Xglms_unprojecti(vec3s pos, mat4s invMat, vec4s vp) {
X  vec3s r;
X  glm_unprojecti(pos.raw, invMat.raw, vp.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief maps the specified viewport coordinates into specified space [1]
X *        the matrix should contain projection matrix.
X *
X * this is same as glm_unprojecti except this function get inverse matrix for
X * you.
X *
X * [1] space:
X *  1- if m = proj:     View Space
X *  2- if m = viewProj: World Space
X *  3- if m = MVP:      Object Space
X *
X * You probably want to map the coordinates into object space
X * so use MVP as m
X *
X * Computing viewProj and MVP:
X *   glm_mat4_mul(proj, view, viewProj);
X *   glm_mat4_mul(viewProj, model, MVP);
X *
X * @param[in]  pos      point/position in viewport coordinates
X * @param[in]  m        matrix (see brief)
X * @param[in]  vp       viewport as [x, y, width, height]
X * @returns             unprojected coordinates
X */
XCGLM_INLINE
Xvec3s
Xglms_unproject(vec3s pos, mat4s m, vec4s vp) {
X  vec3s r;
X  glm_unproject(pos.raw, m.raw, vp.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief map object coordinates to window coordinates
X *
X * Computing MVP:
X *   glm_mat4_mul(proj, view, viewProj);
X *   glm_mat4_mul(viewProj, model, MVP);
X *
X * @param[in]  pos      object coordinates
X * @param[in]  m        MVP matrix
X * @param[in]  vp       viewport as [x, y, width, height]
X * @returns projected coordinates
X */
XCGLM_INLINE
Xvec3s
Xglms_project(vec3s pos, mat4s m, vec4s vp) {
X  vec3s r;
X  glm_project(pos.raw, m.raw, vp.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief define a picking region
X *
X * @param[in]  center   center [x, y] of a picking region in window coordinates
X * @param[in]  size     size [width, height] of the picking region in window coordinates
X * @param[in]  vp       viewport as [x, y, width, height]
X * @returns projected coordinates
X */
XCGLM_INLINE
Xmat4s
Xglms_pickmatrix(vec2s center, vec2s size, vec4s vp) {
X  mat4s res;
X  glm_pickmatrix(center.raw, size.raw, vp.raw, res.raw);
X  return res;
X}
X
X#endif /* cglms_projects_h */
14a0d20e87f21ff6658937b6f294d282
echo x - cglm/struct/sphere.h
sed 's/^X//' >cglm/struct/sphere.h << '2abf948c73f986f0a1aca8b9fa84a894'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglms_spheres_h
X#define cglms_spheres_h
X
X#include "../common.h"
X#include "../types-struct.h"
X#include "../sphere.h"
X#include "mat4.h"
X
X/*
X  Sphere Representation in cglm: [center.x, center.y, center.z, radii]
X
X  You could use this representation or you can convert it to vec4 before call
X  any function
X */
X
X/*!
X * @brief helper for getting sphere radius
X *
X * @param[in]   s  sphere
X *
X * @return returns radii
X */
XCGLM_INLINE
Xfloat
Xglms_sphere_radii(vec4s s) {
X  return glm_sphere_radii(s.raw);
X}
X
X/*!
X * @brief apply transform to sphere, it is just wrapper for glm_mat4_mulv3
X *
X * @param[in]  s    sphere
X * @param[in]  m    transform matrix
X * @returns         transformed sphere
X */
XCGLM_INLINE
Xvec4s
Xglms_sphere_transform(vec4s s, mat4s m) {
X  vec4s r;
X  glm_sphere_transform(s.raw, m.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief merges two spheres and creates a new one
X *
X * two sphere must be in same space, for instance if one in world space then
X * the other must be in world space too, not in local space.
X *
X * @param[in]  s1   sphere 1
X * @param[in]  s2   sphere 2
X * returns          merged/extended sphere
X */
XCGLM_INLINE
Xvec4s
Xglms_sphere_merge(vec4s s1, vec4s s2) {
X  vec4s r;
X  glm_sphere_merge(s1.raw, s2.raw, r.raw);
X  return r;
X}
X
X/*!
X * @brief check if two sphere intersects
X *
X * @param[in]   s1  sphere
X * @param[in]   s2  other sphere
X */
XCGLM_INLINE
Xbool
Xglms_sphere_sphere(vec4s s1, vec4s s2) {
X  return glm_sphere_sphere(s1.raw, s2.raw);
X}
X
X/*!
X * @brief check if sphere intersects with point
X *
X * @param[in]   s      sphere
X * @param[in]   point  point
X */
XCGLM_INLINE
Xbool
Xglms_sphere_point(vec4s s, vec3s point) {
X  return glm_sphere_point(s.raw, point.raw);
X}
X
X#endif /* cglms_spheres_h */
2abf948c73f986f0a1aca8b9fa84a894
echo x - cglm/struct/color.h
sed 's/^X//' >cglm/struct/color.h << '1cf35cfa709adadd478fa03c8f6474c2'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglms_colors_h
X#define cglms_colors_h
X
X#include "../common.h"
X#include "../types-struct.h"
X#include "../color.h"
X#include "vec3.h"
X
X/*!
X * @brief averages the color channels into one value
X *
X * @param[in]  rgb RGB color
X */
XCGLM_INLINE
Xfloat
Xglms_luminance(vec3s rgb) {
X  return glm_luminance(rgb.raw);
X}
X
X#endif /* cglms_colors_h */
1cf35cfa709adadd478fa03c8f6474c2
echo x - cglm/struct/curve.h
sed 's/^X//' >cglm/struct/curve.h << '27a9d509513b731ffd521d5bd9d02566'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X#ifndef cglms_curves_h
X#define cglms_curves_h
X
X#include "../common.h"
X#include "../types-struct.h"
X#include "../curve.h"
X#include "vec4.h"
X#include "mat4.h"
X
X/*!
X * @brief helper function to calculate S*M*C multiplication for curves
X *
X * This function does not encourage you to use SMC,
X * instead it is a helper if you use SMC.
X *
X * if you want to specify S as vector then use more generic glm_mat4_rmc() func.
X *
X * Example usage:
X *  B(s) = glm_smc(s, GLM_BEZIER_MAT, (vec4){p0, c0, c1, p1})
X *
X * @param[in]  s  parameter between 0 and 1 (this will be [s3, s2, s, 1])
X * @param[in]  m  basis matrix
X * @param[in]  c  position/control vector
X *
X * @return B(s)
X */
XCGLM_INLINE
Xfloat
Xglms_smc(float s, mat4s m, vec4s c) {
X  return glm_smc(s, m.raw, c.raw);
X}
X
X#endif /* cglms_curves_h */
27a9d509513b731ffd521d5bd9d02566
echo c - cglm/struct/clipspace
mkdir -p cglm/struct/clipspace > /dev/null 2>&1
echo x - cglm/struct/clipspace/persp_lh_no.h
sed 's/^X//' >cglm/struct/clipspace/persp_lh_no.h << '73472883099b384a44d0106278a7559e'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Functions:
X   CGLM_INLINE mat4s glms_frustum_lh_no(float left,    float right,
X                                        float bottom,  float top,
X                                        float nearZ,   float farZ)
X   CGLM_INLINE mat4s glms_perspective_lh_no(float fovy,
X                                            float aspect,
X                                            float nearZ,
X                                            float farZ)
X   CGLM_INLINE void  glms_persp_move_far_lh_no(mat4s proj, float deltaFar)
X   CGLM_INLINE mat4s glms_perspective_default_lh_no(float aspect)
X   CGLM_INLINE void  glms_perspective_resize_lh_no(mat4s proj, float aspect)
X   CGLM_INLINE void  glms_persp_decomp_lh_no(mat4s  proj,
X                                             float *nearv, float *farv,
X                                             float *top,   float *bottom,
X                                             float *left,  float *right)
X   CGLM_INLINE void  glms_persp_decompv_lh_no(mat4s proj, float dest[6])
X   CGLM_INLINE void  glms_persp_decomp_x_lh_no(mat4s proj, float *left, float *right)
X   CGLM_INLINE void  glms_persp_decomp_y_lh_no(mat4s proj, float *top, float *bottom)
X   CGLM_INLINE void  glms_persp_decomp_z_lh_no(mat4s proj, float *nearv, float *farv)
X   CGLM_INLINE void  glms_persp_decomp_far_lh_no(mat4s proj, float *farZ)
X   CGLM_INLINE void  glms_persp_decomp_near_lh_no(mat4s proj, float *nearZ)
X   CGLM_INLINE float glms_persp_fovy_lh_no(mat4s proj)
X   CGLM_INLINE float glms_persp_aspect_lh_no(mat4s proj)
X   CGLM_INLINE vec4s glms_persp_sizes_lh_no(mat4s proj, float fovy)
X */
X
X#ifndef cglms_persp_lh_no_h
X#define cglms_persp_lh_no_h
X
X#include "../../common.h"
X#include "../../types-struct.h"
X#include "../../plane.h"
X#include "../../cam.h"
X#include "../../clipspace/persp_lh_no.h"
X
X/*!
X * @brief set up perspective peprojection matrix
X *        with a left-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * @param[in]  left    viewport.left
X * @param[in]  right   viewport.right
X * @param[in]  bottom  viewport.bottom
X * @param[in]  top     viewport.top
X * @param[in]  nearZ   near clipping plane
X * @param[in]  farZ    far clipping plane
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_frustum_lh_no(float left,   float right,
X                   float bottom, float top,
X                   float nearZ,  float farZ) {
X  mat4s dest;
X  glm_frustum_lh_no(left, right, bottom, top, nearZ, farZ, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief set up perspective projection matrix
X *        with a left-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * @param[in]  fovy    field of view angle
X * @param[in]  aspect  aspect ratio ( width / height )
X * @param[in]  nearZ   near clipping plane
X * @param[in]  farZ    far clipping planes
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_perspective_lh_no(float fovy, float aspect, float nearZ, float farZ) {
X  mat4s dest;
X  glm_perspective_lh_no(fovy, aspect, nearZ, farZ, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief extend perspective projection matrix's far distance
X *        with a left-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * NOTE: if you dodn't want to create new matrix then use array api on struct.raw
X *       like glms_persp_move_far_lh_no(prooj.raw, deltaFar) to avoid create new mat4
X *       each time
X *       
X * this function does not guarantee far >= near, be aware of that!
X *
X * @param[in, out] proj      projection matrix to extend
X * @param[in]      deltaFar  distance from existing far (negative to shink)
X */
XCGLM_INLINE
Xmat4s
Xglms_persp_move_far_lh_no(mat4s proj, float deltaFar) {
X  mat4s dest;
X  dest = proj;
X  glm_persp_move_far_lh_no(dest.raw, deltaFar);
X  return dest;
X}
X
X/*!
X * @brief set up perspective projection matrix with default near/far
X *        and angle values with a left-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * @param[in]  aspect aspect ratio ( width / height )
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_perspective_default_lh_no(float aspect) {
X  mat4s dest;
X  glm_perspective_default_lh_no(aspect, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief resize perspective matrix by aspect ratio ( width / height )
X *        this makes very easy to resize proj matrix when window /viewport
X *        reized with a left-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * NOTE: if you dodn't want to create new matrix then use array api on struct.raw
X *       like glm_perspective_resize_lh_no(proj.raw, aspect) to avoid create new mat4
X *       each time
X *       
X * @param[in, out] proj   perspective projection matrix
X * @param[in]      aspect aspect ratio ( width / height )
X */
XCGLM_INLINE
Xmat4s
Xglms_perspective_resize_lh_no(mat4s proj, float aspect) {
X  mat4s dest;
X  dest = proj;
X  glm_perspective_resize_lh_no(aspect, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief decomposes frustum values of perspective projection.
X *        with a left-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * @param[in]  proj    perspective projection matrix
X * @param[out] nearZ   near
X * @param[out] farZ    far
X * @param[out] top     top
X * @param[out] bottom  bottom
X * @param[out] left    left
X * @param[out] right   right
X */
XCGLM_INLINE
Xvoid
Xglms_persp_decomp_lh_no(mat4s proj,
X                        float * __restrict nearZ, float * __restrict farZ,
X                        float * __restrict top,   float * __restrict bottom,
X                        float * __restrict left,  float * __restrict right) {
X  glm_persp_decomp_lh_no(proj.raw, nearZ, farZ, top, bottom, left, right);
X}
X
X/*!
X * @brief decomposes frustum values of perspective projection.
X *        this makes easy to get all values at once
X *        with a left-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * @param[in]  proj   perspective projection matrix
X * @param[out] dest   array
X */
XCGLM_INLINE
Xvoid
Xglms_persp_decompv_lh_no(mat4s proj, float dest[6]) {
X  glm_persp_decompv_lh_no(proj.raw, dest);
X}
X
X/*!
X * @brief decomposes left and right values of perspective projection
X *        with a left-hand coordinate system and a
X *        clip-space of [-1, 1].
X *        x stands for x axis (left / right axis)
X *
X * @param[in]  proj  perspective projection matrix
X * @param[out] left  left
X * @param[out] right right
X */
XCGLM_INLINE
Xvoid
Xglms_persp_decomp_x_lh_no(mat4s proj,
X                          float * __restrict left,
X                          float * __restrict right) {
X  glm_persp_decomp_x_lh_no(proj.raw, left, right);
X}
X
X/*!
X * @brief decomposes top and bottom values of perspective projection
X *        with a left-hand coordinate system and a
X *        clip-space of [-1, 1].
X *        y stands for y axis (top / botom axis)
X *
X * @param[in]  proj   perspective projection matrix
X * @param[out] top    top
X * @param[out] bottom bottom
X */
XCGLM_INLINE
Xvoid
Xglms_persp_decomp_y_lh_no(mat4s proj,
X                          float * __restrict top,
X                          float * __restrict bottom) {
X  glm_persp_decomp_y_lh_no(proj.raw, top, bottom);
X}
X
X/*!
X * @brief decomposes near and far values of perspective projection
X *        with a left-hand coordinate system and a
X *        clip-space of [-1, 1].
X *        z stands for z axis (near / far axis)
X *
X * @param[in]  proj    perspective projection matrix
X * @param[out] nearZ   near
X * @param[out] farZ    far
X */
XCGLM_INLINE
Xvoid
Xglms_persp_decomp_z_lh_no(mat4s proj,
X                          float * __restrict nearZ,
X                          float * __restrict farZ) {
X  glm_persp_decomp_z_lh_no(proj.raw, nearZ, farZ);
X}
X
X/*!
X * @brief decomposes far value of perspective projection
X *        with a left-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * @param[in]  proj   perspective projection matrix
X * @param[out] farZ   far
X */
XCGLM_INLINE
Xvoid
Xglms_persp_decomp_far_lh_no(mat4s proj, float * __restrict farZ) {
X  glm_persp_decomp_far_lh_no(proj.raw, farZ);
X}
X
X/*!
X * @brief decomposes near value of perspective projection
X *        with a left-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * @param[in]  proj  perspective projection matrix
X * @param[out] nearZ near
X */
XCGLM_INLINE
Xvoid
Xglms_persp_decomp_near_lh_no(mat4s proj, float * __restrict nearZ) {
X  glm_persp_decomp_near_lh_no(proj.raw, nearZ);
X}
X
X/*!
X * @brief returns field of view angle along the Y-axis (in radians)
X *        with a left-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * if you need to degrees, use glm_deg to convert it or use this:
X * fovy_deg = glm_deg(glm_persp_fovy(projMatrix))
X *
X * @param[in] proj perspective projection matrix
X */
XCGLM_INLINE
Xfloat
Xglms_persp_fovy_lh_no(mat4s proj) {
X  return glm_persp_fovy_lh_no(proj.raw);
X}
X
X/*!
X * @brief returns aspect ratio of perspective projection
X *        with a left-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * @param[in] proj perspective projection matrix
X */
XCGLM_INLINE
Xfloat
Xglms_persp_aspect_lh_no(mat4s proj) {
X  return glm_persp_aspect_lh_no(proj.raw);
X}
X
X/*!
X * @brief returns sizes of near and far planes of perspective projection
X *        with a left-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * @param[in]  proj perspective projection matrix
X * @param[in]  fovy fovy (see brief)
X * @returns    sizes as vector, sizes order: [Wnear, Hnear, Wfar, Hfar]
X */
XCGLM_INLINE
Xvec4s
Xglms_persp_sizes_lh_no(mat4s proj, float fovy) {
X  vec4s dest;
X  glm_persp_sizes_lh_no(proj.raw, fovy, dest.raw);
X  return dest;
X}
X
X#endif /* cglms_persp_lh_no_h */
73472883099b384a44d0106278a7559e
echo x - cglm/struct/clipspace/persp_lh_zo.h
sed 's/^X//' >cglm/struct/clipspace/persp_lh_zo.h << 'd24ea282296bfebb000cc541488cf126'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Functions:
X   CGLM_INLINE mat4s glms_frustum_lh_zo(float left,    float right,
X                                        float bottom,  float top,
X                                        float nearZ,   float farZ)
X   CGLM_INLINE mat4s glms_perspective_lh_zo(float fovy,
X                                            float aspect,
X                                            float nearZ,
X                                            float farZ)
X   CGLM_INLINE void  glms_persp_move_far_lh_zo(mat4s proj, float deltaFar)
X   CGLM_INLINE mat4s glms_perspective_default_lh_zo(float aspect)
X   CGLM_INLINE void  glms_perspective_resize_lh_zo(mat4s proj, float aspect)
X   CGLM_INLINE void  glms_persp_decomp_lh_zo(mat4s  proj,
X                                             float *nearv, float *farv,
X                                             float *top,   float *bottom,
X                                             float *left,  float *right)
X   CGLM_INLINE void  glms_persp_decompv_lh_zo(mat4s proj, float dest[6])
X   CGLM_INLINE void  glms_persp_decomp_x_lh_zo(mat4s proj, float *left, float *right)
X   CGLM_INLINE void  glms_persp_decomp_y_lh_zo(mat4s proj, float *top, float *bottom)
X   CGLM_INLINE void  glms_persp_decomp_z_lh_zo(mat4s proj, float *nearv, float *farv)
X   CGLM_INLINE void  glms_persp_decomp_far_lh_zo(mat4s proj, float *farZ)
X   CGLM_INLINE void  glms_persp_decomp_near_lh_zo(mat4s proj, float *nearZ)
X   CGLM_INLINE float glms_persp_fovy_lh_zo(mat4s proj)
X   CGLM_INLINE float glms_persp_aspect_lh_zo(mat4s proj)
X   CGLM_INLINE vec4s glms_persp_sizes_lh_zo(mat4s proj, float fovy)
X */
X
X#ifndef cglms_persp_lh_zo_h
X#define cglms_persp_lh_zo_h
X
X#include "../../common.h"
X#include "../../types-struct.h"
X#include "../../plane.h"
X#include "../../cam.h"
X#include "../../clipspace/persp_lh_zo.h"
X
X/*!
X * @brief set up perspective peprojection matrix
X *        with a left-hand coordinate system and a
X *        clip-space of [0, 1].
X *
X * @param[in]  left    viewport.left
X * @param[in]  right   viewport.right
X * @param[in]  bottom  viewport.bottom
X * @param[in]  top     viewport.top
X * @param[in]  nearZ   near clipping plane
X * @param[in]  farZ    far clipping plane
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_frustum_lh_zo(float left,   float right,
X                   float bottom, float top,
X                   float nearZ,  float farZ) {
X  mat4s dest;
X  glm_frustum_lh_zo(left, right, bottom, top, nearZ, farZ, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief set up perspective projection matrix
X *        with a left-hand coordinate system and a
X *        clip-space of [0, 1].
X *
X * @param[in]  fovy    field of view angle
X * @param[in]  aspect  aspect ratio ( width / height )
X * @param[in]  nearZ   near clipping plane
X * @param[in]  farZ    far clipping planes
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_perspective_lh_zo(float fovy, float aspect, float nearZ, float farZ) {
X  mat4s dest;
X  glm_perspective_lh_zo(fovy, aspect, nearZ, farZ, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief extend perspective projection matrix's far distance
X *        with a left-hand coordinate system and a
X *        clip-space of [0, 1].
X *
X * NOTE: if you dodn't want to create new matrix then use array api on struct.raw
X *       like glms_persp_move_far_lh_zo(prooj.raw, deltaFar) to avoid create new mat4
X *       each time
X *
X * this function does not guarantee far >= near, be aware of that!
X *
X * @param[in, out] proj      projection matrix to extend
X * @param[in]      deltaFar  distance from existing far (negative to shink)
X */
XCGLM_INLINE
Xmat4s
Xglms_persp_move_far_lh_zo(mat4s proj, float deltaFar) {
X  mat4s dest;
X  dest = proj;
X  glm_persp_move_far_lh_zo(dest.raw, deltaFar);
X  return dest;
X}
X
X/*!
X * @brief set up perspective projection matrix with default near/far
X *        and angle values with a left-hand coordinate system and a
X *        clip-space of [0, 1].
X *
X * @param[in]  aspect aspect ratio ( width / height )
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_perspective_default_lh_zo(float aspect) {
X  mat4s dest;
X  glm_perspective_default_lh_zo(aspect, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief resize perspective matrix by aspect ratio ( width / height )
X *        this makes very easy to resize proj matrix when window /viewport
X *        reized with a left-hand coordinate system and a
X *        clip-space of [0, 1].
X *
X * NOTE: if you dodn't want to create new matrix then use array api on struct.raw
X *       like glms_perspective_resize_lh_zo(proj.raw, aspect) to avoid create new mat4
X *       each time
X *       
X * @param[in, out] proj   perspective projection matrix
X * @param[in]      aspect aspect ratio ( width / height )
X */
XCGLM_INLINE
Xmat4s
Xglms_perspective_resize_lh_zo(mat4s proj, float aspect) {
X  mat4s dest;
X  dest = proj;
X  glm_perspective_resize_lh_zo(aspect, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief decomposes frustum values of perspective projection.
X *        with a left-hand coordinate system and a
X *        clip-space of [0, 1].
X *
X * @param[in]  proj    perspective projection matrix
X * @param[out] nearZ   near
X * @param[out] farZ    far
X * @param[out] top     top
X * @param[out] bottom  bottom
X * @param[out] left    left
X * @param[out] right   right
X */
XCGLM_INLINE
Xvoid
Xglms_persp_decomp_lh_zo(mat4s proj,
X                        float * __restrict nearZ, float * __restrict farZ,
X                        float * __restrict top,   float * __restrict bottom,
X                        float * __restrict left,  float * __restrict right) {
X  glm_persp_decomp_lh_zo(proj.raw, nearZ, farZ, top, bottom, left, right);
X}
X
X/*!
X * @brief decomposes frustum values of perspective projection.
X *        this makes easy to get all values at once
X *        with a left-hand coordinate system and a
X *        clip-space of [0, 1].
X *
X * @param[in]  proj   perspective projection matrix
X * @param[out] dest   array
X */
XCGLM_INLINE
Xvoid
Xglms_persp_decompv_lh_zo(mat4s proj, float dest[6]) {
X  glm_persp_decompv_lh_zo(proj.raw, dest);
X}
X
X/*!
X * @brief decomposes left and right values of perspective projection
X *        with a left-hand coordinate system and a
X *        clip-space of [0, 1].
X *        x stands for x axis (left / right axis)
X *
X * @param[in]  proj  perspective projection matrix
X * @param[out] left  left
X * @param[out] right right
X */
XCGLM_INLINE
Xvoid
Xglms_persp_decomp_x_lh_zo(mat4s proj,
X                          float * __restrict left,
X                          float * __restrict right) {
X  glm_persp_decomp_x_lh_zo(proj.raw, left, right);
X}
X
X/*!
X * @brief decomposes top and bottom values of perspective projection
X *        with a left-hand coordinate system and a
X *        clip-space of [0, 1].
X *        y stands for y axis (top / botom axis)
X *
X * @param[in]  proj   perspective projection matrix
X * @param[out] top    top
X * @param[out] bottom bottom
X */
XCGLM_INLINE
Xvoid
Xglms_persp_decomp_y_lh_zo(mat4s proj,
X                          float * __restrict top,
X                          float * __restrict bottom) {
X  glm_persp_decomp_y_lh_zo(proj.raw, top, bottom);
X}
X
X/*!
X * @brief decomposes near and far values of perspective projection
X *        with a left-hand coordinate system and a
X *        clip-space of [0, 1].
X *        z stands for z axis (near / far axis)
X *
X * @param[in]  proj    perspective projection matrix
X * @param[out] nearZ   near
X * @param[out] farZ    far
X */
XCGLM_INLINE
Xvoid
Xglms_persp_decomp_z_lh_zo(mat4s proj,
X                          float * __restrict nearZ,
X                          float * __restrict farZ) {
X  glm_persp_decomp_z_lh_zo(proj.raw, nearZ, farZ);
X}
X
X/*!
X * @brief decomposes far value of perspective projection
X *        with a left-hand coordinate system and a
X *        clip-space of [0, 1].
X *
X * @param[in]  proj   perspective projection matrix
X * @param[out] farZ   far
X */
XCGLM_INLINE
Xvoid
Xglms_persp_decomp_far_lh_zo(mat4s proj, float * __restrict farZ) {
X  glm_persp_decomp_far_lh_zo(proj.raw, farZ);
X}
X
X/*!
X * @brief decomposes near value of perspective projection
X *        with a left-hand coordinate system and a
X *        clip-space of [0, 1].
X *
X * @param[in]  proj  perspective projection matrix
X * @param[out] nearZ near
X */
XCGLM_INLINE
Xvoid
Xglms_persp_decomp_near_lh_zo(mat4s proj, float * __restrict nearZ) {
X  glm_persp_decomp_near_lh_zo(proj.raw, nearZ);
X}
X
X/*!
X * @brief returns field of view angle along the Y-axis (in radians)
X *        with a left-hand coordinate system and a
X *        clip-space of [0, 1].
X *
X * if you need to degrees, use glm_deg to convert it or use this:
X * fovy_deg = glm_deg(glm_persp_fovy(projMatrix))
X *
X * @param[in] proj perspective projection matrix
X */
XCGLM_INLINE
Xfloat
Xglms_persp_fovy_lh_zo(mat4s proj) {
X  return glm_persp_fovy_lh_zo(proj.raw);
X}
X
X/*!
X * @brief returns aspect ratio of perspective projection
X *        with a left-hand coordinate system and a
X *        clip-space of [0, 1].
X *
X * @param[in] proj perspective projection matrix
X */
XCGLM_INLINE
Xfloat
Xglms_persp_aspect_lh_zo(mat4s proj) {
X  return glm_persp_aspect_lh_zo(proj.raw);
X}
X
X/*!
X * @brief returns sizes of near and far planes of perspective projection
X *        with a left-hand coordinate system and a
X *        clip-space of [0, 1].
X *
X * @param[in]  proj perspective projection matrix
X * @param[in]  fovy fovy (see brief)
X * @returns    sizes as vector, sizes order: [Wnear, Hnear, Wfar, Hfar]
X */
XCGLM_INLINE
Xvec4s
Xglms_persp_sizes_lh_zo(mat4s proj, float fovy) {
X  vec4s dest;
X  glm_persp_sizes_lh_zo(proj.raw, fovy, dest.raw);
X  return dest;
X}
X
X#endif /* cglms_persp_lh_zo_h */
d24ea282296bfebb000cc541488cf126
echo x - cglm/struct/clipspace/persp_rh_no.h
sed 's/^X//' >cglm/struct/clipspace/persp_rh_no.h << 'e03b74e28c3ea733d7466edeb2d52b81'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Functions:
X   CGLM_INLINE mat4s glms_frustum_rh_no(float left,    float right,
X                                        float bottom,  float top,
X                                        float nearZ,   float farZ)
X   CGLM_INLINE mat4s glms_perspective_rh_no(float fovy,
X                                            float aspect,
X                                            float nearZ,
X                                            float farZ)
X   CGLM_INLINE void  glms_persp_move_far_rh_no(mat4s proj, float deltaFar)
X   CGLM_INLINE mat4s glms_perspective_default_rh_no(float aspect)
X   CGLM_INLINE void  glms_perspective_resize_rh_no(mat4s proj, float aspect)
X   CGLM_INLINE void  glms_persp_decomp_rh_no(mat4s  proj,
X                                             float *nearv, float *farv,
X                                             float *top,   float *bottom,
X                                             float *left,  float *right)
X   CGLM_INLINE void  glms_persp_decompv_rh_no(mat4s proj, float dest[6])
X   CGLM_INLINE void  glms_persp_decomp_x_rh_no(mat4s proj, float *left, float *right)
X   CGLM_INLINE void  glms_persp_decomp_y_rh_no(mat4s proj, float *top, float *bottom)
X   CGLM_INLINE void  glms_persp_decomp_z_rh_no(mat4s proj, float *nearv, float *farv)
X   CGLM_INLINE void  glms_persp_decomp_far_rh_no(mat4s proj, float *farZ)
X   CGLM_INLINE void  glms_persp_decomp_near_rh_no(mat4s proj, float *nearZ)
X   CGLM_INLINE float glms_persp_fovy_rh_no(mat4s proj)
X   CGLM_INLINE float glms_persp_aspect_rh_no(mat4s proj)
X   CGLM_INLINE vec4s glms_persp_sizes_rh_no(mat4s proj, float fovy)
X */
X
X#ifndef cglms_persp_rh_no_h
X#define cglms_persp_rh_no_h
X
X#include "../../common.h"
X#include "../../types-struct.h"
X#include "../../plane.h"
X#include "../../cam.h"
X#include "../../clipspace/persp_rh_no.h"
X
X/*!
X * @brief set up perspective peprojection matrix
X *        with a right-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * @param[in]  left    viewport.left
X * @param[in]  right   viewport.right
X * @param[in]  bottom  viewport.bottom
X * @param[in]  top     viewport.top
X * @param[in]  nearZ   near clipping plane
X * @param[in]  farZ    far clipping plane
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_frustum_rh_no(float left,   float right,
X                   float bottom, float top,
X                   float nearZ,  float farZ) {
X  mat4s dest;
X  glm_frustum_rh_no(left, right, bottom, top, nearZ, farZ, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief set up perspective projection matrix
X *        with a right-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * @param[in]  fovy    field of view angle
X * @param[in]  aspect  aspect ratio ( width / height )
X * @param[in]  nearZ   near clipping plane
X * @param[in]  farZ    far clipping planes
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_perspective_rh_no(float fovy, float aspect, float nearZ, float farZ) {
X  mat4s dest;
X  glm_perspective_rh_no(fovy, aspect, nearZ, farZ, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief extend perspective projection matrix's far distance
X *        with a right-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * NOTE: if you dodn't want to create new matrix then use array api on struct.raw
X *       like glms_persp_move_far_rh_no(prooj.raw, deltaFar) to avoid create new mat4
X *       each time
X *       s
X * this function does not guarantee far >= near, be aware of that!
X *
X * @param[in, out] proj      projection matrix to extend
X * @param[in]      deltaFar  distance from existing far (negative to shink)
X */
XCGLM_INLINE
Xmat4s
Xglms_persp_move_far_rh_no(mat4s proj, float deltaFar) {
X  mat4s dest;
X  dest = proj;
X  glm_persp_move_far_rh_no(dest.raw, deltaFar);
X  return dest;
X}
X
X/*!
X * @brief set up perspective projection matrix with default near/far
X *        and angle values with a right-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * @param[in]  aspect aspect ratio ( width / height )
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_perspective_default_rh_no(float aspect) {
X  mat4s dest;
X  glm_perspective_default_rh_no(aspect, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief resize perspective matrix by aspect ratio ( width / height )
X *        this makes very easy to resize proj matrix when window /viewport
X *        reized with a right-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * NOTE: if you dodn't want to create new matrix then use array api on struct.raw
X *       like glm_perspective_resize_rh_no(proj.raw, aspect) to avoid create new mat4
X *       each time
X *       
X * @param[in, out] proj   perspective projection matrix
X * @param[in]      aspect aspect ratio ( width / height )
X */
XCGLM_INLINE
Xmat4s
Xglms_perspective_resize_rh_no(mat4s proj, float aspect) {
X  mat4s dest;
X  dest = proj;
X  glm_perspective_resize_rh_no(aspect, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief decomposes frustum values of perspective projection.
X *        with a right-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * @param[in]  proj    perspective projection matrix
X * @param[out] nearZ   near
X * @param[out] farZ    far
X * @param[out] top     top
X * @param[out] bottom  bottom
X * @param[out] left    left
X * @param[out] right   right
X */
XCGLM_INLINE
Xvoid
Xglms_persp_decomp_rh_no(mat4s proj,
X                        float * __restrict nearZ, float * __restrict farZ,
X                        float * __restrict top,   float * __restrict bottom,
X                        float * __restrict left,  float * __restrict right) {
X  glm_persp_decomp_rh_no(proj.raw, nearZ, farZ, top, bottom, left, right);
X}
X
X/*!
X * @brief decomposes frustum values of perspective projection.
X *        this makes easy to get all values at once
X *        with a right-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * @param[in]  proj   perspective projection matrix
X * @param[out] dest   array
X */
XCGLM_INLINE
Xvoid
Xglms_persp_decompv_rh_no(mat4s proj, float dest[6]) {
X  glm_persp_decompv_rh_no(proj.raw, dest);
X}
X
X/*!
X * @brief decomposes left and right values of perspective projection
X *        with a right-hand coordinate system and a
X *        clip-space of [-1, 1].
X *        x stands for x axis (left / right axis)
X *
X * @param[in]  proj  perspective projection matrix
X * @param[out] left  left
X * @param[out] right right
X */
XCGLM_INLINE
Xvoid
Xglms_persp_decomp_x_rh_no(mat4s proj,
X                          float * __restrict left,
X                          float * __restrict right) {
X  glm_persp_decomp_x_rh_no(proj.raw, left, right);
X}
X
X/*!
X * @brief decomposes top and bottom values of perspective projection
X *        with a right-hand coordinate system and a
X *        clip-space of [-1, 1].
X *        y stands for y axis (top / botom axis)
X *
X * @param[in]  proj   perspective projection matrix
X * @param[out] top    top
X * @param[out] bottom bottom
X */
XCGLM_INLINE
Xvoid
Xglms_persp_decomp_y_rh_no(mat4s proj,
X                          float * __restrict top,
X                          float * __restrict bottom) {
X  glm_persp_decomp_y_rh_no(proj.raw, top, bottom);
X}
X
X/*!
X * @brief decomposes near and far values of perspective projection
X *        with a right-hand coordinate system and a
X *        clip-space of [-1, 1].
X *        z stands for z axis (near / far axis)
X *
X * @param[in]  proj    perspective projection matrix
X * @param[out] nearZ   near
X * @param[out] farZ    far
X */
XCGLM_INLINE
Xvoid
Xglms_persp_decomp_z_rh_no(mat4s proj,
X                          float * __restrict nearZ,
X                          float * __restrict farZ) {
X  glm_persp_decomp_z_rh_no(proj.raw, nearZ, farZ);
X}
X
X/*!
X * @brief decomposes far value of perspective projection
X *        with a right-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * @param[in]  proj   perspective projection matrix
X * @param[out] farZ   far
X */
XCGLM_INLINE
Xvoid
Xglms_persp_decomp_far_rh_no(mat4s proj, float * __restrict farZ) {
X  glm_persp_decomp_far_rh_no(proj.raw, farZ);
X}
X
X/*!
X * @brief decomposes near value of perspective projection
X *        with a right-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * @param[in]  proj  perspective projection matrix
X * @param[out] nearZ near
X */
XCGLM_INLINE
Xvoid
Xglms_persp_decomp_near_rh_no(mat4s proj, float * __restrict nearZ) {
X  glm_persp_decomp_near_rh_no(proj.raw, nearZ);
X}
X
X/*!
X * @brief returns field of view angle along the Y-axis (in radians)
X *        with a right-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * if you need to degrees, use glm_deg to convert it or use this:
X * fovy_deg = glm_deg(glm_persp_fovy(projMatrix))
X *
X * @param[in] proj perspective projection matrix
X */
XCGLM_INLINE
Xfloat
Xglms_persp_fovy_rh_no(mat4s proj) {
X  return glm_persp_fovy_rh_no(proj.raw);
X}
X
X/*!
X * @brief returns aspect ratio of perspective projection
X *        with a right-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * @param[in] proj perspective projection matrix
X */
XCGLM_INLINE
Xfloat
Xglms_persp_aspect_rh_no(mat4s proj) {
X  return glm_persp_aspect_rh_no(proj.raw);
X}
X
X/*!
X * @brief returns sizes of near and far planes of perspective projection
X *        with a right-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * @param[in]  proj perspective projection matrix
X * @param[in]  fovy fovy (see brief)
X * @returns    sizes as vector, sizes order: [Wnear, Hnear, Wfar, Hfar]
X */
XCGLM_INLINE
Xvec4s
Xglms_persp_sizes_rh_no(mat4s proj, float fovy) {
X  vec4s dest;
X  glm_persp_sizes_rh_no(proj.raw, fovy, dest.raw);
X  return dest;
X}
X
X#endif /* cglms_persp_rh_no_h */
e03b74e28c3ea733d7466edeb2d52b81
echo x - cglm/struct/clipspace/persp_rh_zo.h
sed 's/^X//' >cglm/struct/clipspace/persp_rh_zo.h << 'bd3c93721338049f2f1c174007118e6a'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Functions:
X   CGLM_INLINE mat4s glms_frustum_rh_zo(float left,    float right,
X                                        float bottom,  float top,
X                                        float nearZ,   float farZ)
X   CGLM_INLINE mat4s glms_perspective_rh_zo(float fovy,
X                                            float aspect,
X                                            float nearZ,
X                                            float farZ)
X   CGLM_INLINE void  glms_persp_move_far_rh_zo(mat4s proj, float deltaFar)
X   CGLM_INLINE mat4s glms_perspective_default_rh_zo(float aspect)
X   CGLM_INLINE void  glms_perspective_resize_rh_zo(mat4s proj, float aspect)
X   CGLM_INLINE void  glms_persp_decomp_rh_zo(mat4s  proj,
X                                             float *nearv, float *farv,
X                                             float *top,   float *bottom,
X                                             float *left,  float *right)
X   CGLM_INLINE void  glms_persp_decompv_rh_zo(mat4s proj, float dest[6])
X   CGLM_INLINE void  glms_persp_decomp_x_rh_zo(mat4s proj, float *left, float *right)
X   CGLM_INLINE void  glms_persp_decomp_y_rh_zo(mat4s proj, float *top, float *bottom)
X   CGLM_INLINE void  glms_persp_decomp_z_rh_zo(mat4s proj, float *nearv, float *farv)
X   CGLM_INLINE void  glms_persp_decomp_far_rh_zo(mat4s proj, float *farZ)
X   CGLM_INLINE void  glms_persp_decomp_near_rh_zo(mat4s proj, float *nearZ)
X   CGLM_INLINE float glms_persp_fovy_rh_zo(mat4s proj)
X   CGLM_INLINE float glms_persp_aspect_rh_zo(mat4s proj)
X   CGLM_INLINE vec4s glms_persp_sizes_rh_zo(mat4s proj, float fovy)
X */
X
X#ifndef cglms_persp_rh_zo_h
X#define cglms_persp_rh_zo_h
X
X#include "../../common.h"
X#include "../../types-struct.h"
X#include "../../plane.h"
X#include "../../cam.h"
X#include "../../clipspace/persp_rh_zo.h"
X
X/*!
X * @brief set up perspective peprojection matrix
X *        with a right-hand coordinate system and a
X *        clip-space of [0, 1].
X *
X * @param[in]  left    viewport.left
X * @param[in]  right   viewport.right
X * @param[in]  bottom  viewport.bottom
X * @param[in]  top     viewport.top
X * @param[in]  nearZ   near clipping plane
X * @param[in]  farZ    far clipping plane
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_frustum_rh_zo(float left,   float right,
X                   float bottom, float top,
X                   float nearZ,  float farZ) {
X  mat4s dest;
X  glm_frustum_rh_zo(left, right, bottom, top, nearZ, farZ, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief set up perspective projection matrix
X *        with a right-hand coordinate system and a
X *        clip-space of [0, 1].
X *
X * @param[in]  fovy    field of view angle
X * @param[in]  aspect  aspect ratio ( width / height )
X * @param[in]  nearZ   near clipping plane
X * @param[in]  farZ    far clipping planes
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_perspective_rh_zo(float fovy, float aspect, float nearZ, float farZ) {
X  mat4s dest;
X  glm_perspective_rh_zo(fovy, aspect, nearZ, farZ, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief extend perspective projection matrix's far distance
X *        with a right-hand coordinate system and a
X *        clip-space of [0, 1].
X *
X * NOTE: if you dodn't want to create new matrix then use array api on struct.raw
X *       like glms_persp_move_far_rh_zo(prooj.raw, deltaFar) to avoid create new mat4
X *       each time
X *       
X * this function does not guarantee far >= near, be aware of that!
X *
X * @param[in, out] proj      projection matrix to extend
X * @param[in]      deltaFar  distance from existing far (negative to shink)
X */
XCGLM_INLINE
Xmat4s
Xglms_persp_move_far_rh_zo(mat4s proj, float deltaFar) {
X  mat4s dest;
X  dest = proj;
X  glm_persp_move_far_rh_zo(dest.raw, deltaFar);
X  return dest;
X}
X
X/*!
X * @brief set up perspective projection matrix with default near/far
X *        and angle values with a right-hand coordinate system and a
X *        clip-space of [0, 1].
X *
X * @param[in]  aspect aspect ratio ( width / height )
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_perspective_default_rh_zo(float aspect) {
X  mat4s dest;
X  glm_perspective_default_rh_zo(aspect, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief resize perspective matrix by aspect ratio ( width / height )
X *        this makes very easy to resize proj matrix when window /viewport
X *        reized with a right-hand coordinate system and a
X *        clip-space of [0, 1].
X *
X * NOTE: if you dodn't want to create new matrix then use array api on struct.raw
X *       like glm_perspective_resize_rh_zo(proj.raw, aspect) to avoid create new mat4
X *       each time
X *       
X * @param[in, out] proj   perspective projection matrix
X * @param[in]      aspect aspect ratio ( width / height )
X */
XCGLM_INLINE
Xmat4s
Xglms_perspective_resize_rh_zo(mat4s proj, float aspect) {
X  mat4s dest;
X  dest = proj;
X  glm_perspective_resize_rh_zo(aspect, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief decomposes frustum values of perspective projection.
X *        with a right-hand coordinate system and a
X *        clip-space of [0, 1].
X *
X * @param[in]  proj    perspective projection matrix
X * @param[out] nearZ   near
X * @param[out] farZ    far
X * @param[out] top     top
X * @param[out] bottom  bottom
X * @param[out] left    left
X * @param[out] right   right
X */
XCGLM_INLINE
Xvoid
Xglms_persp_decomp_rh_zo(mat4s proj,
X                        float * __restrict nearZ, float * __restrict farZ,
X                        float * __restrict top,   float * __restrict bottom,
X                        float * __restrict left,  float * __restrict right) {
X  glm_persp_decomp_rh_zo(proj.raw, nearZ, farZ, top, bottom, left, right);
X}
X
X/*!
X * @brief decomposes frustum values of perspective projection.
X *        this makes easy to get all values at once
X *        with a right-hand coordinate system and a
X *        clip-space of [0, 1].
X *
X * @param[in]  proj   perspective projection matrix
X * @param[out] dest   array
X */
XCGLM_INLINE
Xvoid
Xglms_persp_decompv_rh_zo(mat4s proj, float dest[6]) {
X  glm_persp_decompv_rh_zo(proj.raw, dest);
X}
X
X/*!
X * @brief decomposes left and right values of perspective projection
X *        with a right-hand coordinate system and a
X *        clip-space of [0, 1].
X *        x stands for x axis (left / right axis)
X *
X * @param[in]  proj  perspective projection matrix
X * @param[out] left  left
X * @param[out] right right
X */
XCGLM_INLINE
Xvoid
Xglms_persp_decomp_x_rh_zo(mat4s proj,
X                          float * __restrict left,
X                          float * __restrict right) {
X  glm_persp_decomp_x_rh_zo(proj.raw, left, right);
X}
X
X/*!
X * @brief decomposes top and bottom values of perspective projection
X *        with a right-hand coordinate system and a
X *        clip-space of [0, 1].
X *        y stands for y axis (top / botom axis)
X *
X * @param[in]  proj   perspective projection matrix
X * @param[out] top    top
X * @param[out] bottom bottom
X */
XCGLM_INLINE
Xvoid
Xglms_persp_decomp_y_rh_zo(mat4s proj,
X                          float * __restrict top,
X                          float * __restrict bottom) {
X  glm_persp_decomp_y_rh_zo(proj.raw, top, bottom);
X}
X
X/*!
X * @brief decomposes near and far values of perspective projection
X *        with a right-hand coordinate system and a
X *        clip-space of [0, 1].
X *        z stands for z axis (near / far axis)
X *
X * @param[in]  proj    perspective projection matrix
X * @param[out] nearZ   near
X * @param[out] farZ    far
X */
XCGLM_INLINE
Xvoid
Xglms_persp_decomp_z_rh_zo(mat4s proj,
X                          float * __restrict nearZ,
X                          float * __restrict farZ) {
X  glm_persp_decomp_z_rh_zo(proj.raw, nearZ, farZ);
X}
X
X/*!
X * @brief decomposes far value of perspective projection
X *        with a right-hand coordinate system and a
X *        clip-space of [0, 1].
X *
X * @param[in]  proj   perspective projection matrix
X * @param[out] farZ   far
X */
XCGLM_INLINE
Xvoid
Xglms_persp_decomp_far_rh_zo(mat4s proj, float * __restrict farZ) {
X  glm_persp_decomp_far_rh_zo(proj.raw, farZ);
X}
X
X/*!
X * @brief decomposes near value of perspective projection
X *        with a right-hand coordinate system and a
X *        clip-space of [0, 1].
X *
X * @param[in]  proj  perspective projection matrix
X * @param[out] nearZ near
X */
XCGLM_INLINE
Xvoid
Xglms_persp_decomp_near_rh_zo(mat4s proj, float * __restrict nearZ) {
X  glm_persp_decomp_near_rh_zo(proj.raw, nearZ);
X}
X
X/*!
X * @brief returns field of view angle along the Y-axis (in radians)
X *        with a right-hand coordinate system and a
X *        clip-space of [0, 1].
X *
X * if you need to degrees, use glm_deg to convert it or use this:
X * fovy_deg = glm_deg(glm_persp_fovy(projMatrix))
X *
X * @param[in] proj perspective projection matrix
X */
XCGLM_INLINE
Xfloat
Xglms_persp_fovy_rh_zo(mat4s proj) {
X  return glm_persp_fovy_rh_zo(proj.raw);
X}
X
X/*!
X * @brief returns aspect ratio of perspective projection
X *        with a right-hand coordinate system and a
X *        clip-space of [0, 1].
X *
X * @param[in] proj perspective projection matrix
X */
XCGLM_INLINE
Xfloat
Xglms_persp_aspect_rh_zo(mat4s proj) {
X  return glm_persp_aspect_rh_zo(proj.raw);
X}
X
X/*!
X * @brief returns sizes of near and far planes of perspective projection
X *        with a right-hand coordinate system and a
X *        clip-space of [0, 1].
X *
X * @param[in]  proj perspective projection matrix
X * @param[in]  fovy fovy (see brief)
X * @returns    sizes as vector, sizes order: [Wnear, Hnear, Wfar, Hfar]
X */
XCGLM_INLINE
Xvec4s
Xglms_persp_sizes_rh_zo(mat4s proj, float fovy) {
X  vec4s dest;
X  glm_persp_sizes_rh_zo(proj.raw, fovy, dest.raw);
X  return dest;
X}
X
X#endif /* cglms_persp_rh_zo_h */
bd3c93721338049f2f1c174007118e6a
echo x - cglm/struct/clipspace/ortho_lh_no.h
sed 's/^X//' >cglm/struct/clipspace/ortho_lh_no.h << '54b410bf4182c6bcfa1d441723571c81'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Functions:
X   CGLM_INLINE mat4s glms_ortho_lh_no(float left,    float right,
X                                      float bottom,  float top,
X                                      float nearZ,   float farZ)
X   CGLM_INLINE mat4s glms_ortho_aabb_lh_no(vec3s box[2]);
X   CGLM_INLINE mat4s glms_ortho_aabb_p_lh_no(vec3s box[2],  float padding);
X   CGLM_INLINE mat4s glms_ortho_aabb_pz_lh_no(vec3s box[2], float padding);
X   CGLM_INLINE mat4s glms_ortho_default_lh_no(float aspect)
X   CGLM_INLINE mat4s glms_ortho_default_s_lh_no(float aspect, float size)
X */
X
X#ifndef cglms_ortho_lh_no_h
X#define cglms_ortho_lh_no_h
X
X#include "../../common.h"
X#include "../../types-struct.h"
X#include "../../plane.h"
X#include "../../cam.h"
X#include "../vec3.h"
X#include "../../clipspace/ortho_lh_no.h"
X
X/*!
X * @brief set up orthographic projection matrix
X *        with a left-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * @param[in]  left    viewport.left
X * @param[in]  right   viewport.right
X * @param[in]  bottom  viewport.bottom
X * @param[in]  top     viewport.top
X * @param[in]  nearZ   near clipping plane
X * @param[in]  farZ    far clipping plane
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_ortho_lh_no(float left,   float right,
X                 float bottom, float top,
X                 float nearZ,  float farZ) {
X  mat4s dest;
X  glm_ortho_lh_no(left, right, bottom, top, nearZ, farZ, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief set up orthographic projection matrix using bounding box
X *        with a left-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * bounding box (AABB) must be in view space
X *
X * @param[in]  box   AABB
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_ortho_aabb_lh_no(vec3s box[2]) {
X  mat4s dest;
X  vec3  rawBox[2];
X
X  glms_vec3_(unpack)(rawBox, box, 2);
X  glm_ortho_aabb_lh_no(rawBox, dest.raw);
X
X  return dest;
X}
X
X/*!
X * @brief set up orthographic projection matrix using bounding box
X *        with a left-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * bounding box (AABB) must be in view space
X *
X * @param[in]  box     AABB
X * @param[in]  padding padding
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_ortho_aabb_p_lh_no(vec3s box[2], float padding) {
X  mat4s dest;
X  vec3  rawBox[2];
X
X  glms_vec3_(unpack)(rawBox, box, 2);
X  glm_ortho_aabb_p_lh_no(rawBox, padding, dest.raw);
X
X  return dest;
X}
X
X/*!
X * @brief set up orthographic projection matrix using bounding box
X *        with a left-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * bounding box (AABB) must be in view space
X *
X * @param[in]  box     AABB
X * @param[in]  padding padding for near and far
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_ortho_aabb_pz_lh_no(vec3s box[2], float padding) {
X  mat4s dest;
X  vec3  rawBox[2];
X
X  glms_vec3_(unpack)(rawBox, box, 2);
X  glm_ortho_aabb_pz_lh_no(rawBox, padding, dest.raw);
X
X  return dest;
X}
X
X/*!
X * @brief set up unit orthographic projection matrix
X *        with a left-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * @param[in]  aspect aspect ration ( width / height )
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_ortho_default_lh_no(float aspect) {
X  mat4s dest;
X  glm_ortho_default_lh_no(aspect, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief set up orthographic projection matrix with given CUBE size
X *        with a left-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * @param[in]  aspect aspect ratio ( width / height )
X * @param[in]  size   cube size
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_ortho_default_s_lh_no(float aspect, float size) {
X  mat4s dest;
X  glm_ortho_default_s_lh_no(aspect, size, dest.raw);
X  return dest;
X}
X
X#endif /* cglms_ortho_lh_no_h */
54b410bf4182c6bcfa1d441723571c81
echo x - cglm/struct/clipspace/ortho_lh_zo.h
sed 's/^X//' >cglm/struct/clipspace/ortho_lh_zo.h << 'b080732560ed30ec8ae2a11ee714945a'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Functions:
X   CGLM_INLINE mat4s glms_ortho_lh_zo(float left,    float right,
X                                      float bottom,  float top,
X                                      float nearZ,   float farZ)
X   CGLM_INLINE mat4s glms_ortho_aabb_lh_zo(vec3s box[2]);
X   CGLM_INLINE mat4s glms_ortho_aabb_p_lh_zo(vec3s box[2],  float padding);
X   CGLM_INLINE mat4s glms_ortho_aabb_pz_lh_zo(vec3s box[2], float padding);
X   CGLM_INLINE mat4s glms_ortho_default_lh_zo(float aspect)
X   CGLM_INLINE mat4s glms_ortho_default_s_lh_zo(float aspect, float size)
X */
X
X#ifndef cglms_ortho_lh_zo_h
X#define cglms_ortho_lh_zo_h
X
X#include "../../common.h"
X#include "../../types-struct.h"
X#include "../../plane.h"
X#include "../../cam.h"
X#include "../vec3.h"
X#include "../../clipspace/ortho_lh_zo.h"
X
X/*!
X * @brief set up orthographic projection matrix
X *        with a left-hand coordinate system and a
X *        clip-space of [0, 1].
X *
X * @param[in]  left    viewport.left
X * @param[in]  right   viewport.right
X * @param[in]  bottom  viewport.bottom
X * @param[in]  top     viewport.top
X * @param[in]  nearZ   near clipping plane
X * @param[in]  farZ    far clipping plane
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_ortho_lh_zo(float left,   float right,
X                 float bottom, float top,
X                 float nearZ,  float farZ) {
X  mat4s dest;
X  glm_ortho_lh_zo(left, right, bottom, top, nearZ, farZ, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief set up orthographic projection matrix using bounding box
X *        with a left-hand coordinate system and a
X *        clip-space of [0, 1].
X *
X * bounding box (AABB) must be in view space
X *
X * @param[in]  box   AABB
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_ortho_aabb_lh_zo(vec3s box[2]) {
X  mat4s dest;
X  vec3  rawBox[2];
X
X  glms_vec3_(unpack)(rawBox, box, 2);
X  glm_ortho_aabb_lh_zo(rawBox, dest.raw);
X
X  return dest;
X}
X
X/*!
X * @brief set up orthographic projection matrix using bounding box
X *        with a left-hand coordinate system and a
X *        clip-space of [0, 1].
X *
X * bounding box (AABB) must be in view space
X *
X * @param[in]  box     AABB
X * @param[in]  padding padding
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_ortho_aabb_p_lh_zo(vec3s box[2], float padding) {
X  mat4s dest;
X  vec3  rawBox[2];
X
X  glms_vec3_(unpack)(rawBox, box, 2);
X  glm_ortho_aabb_p_lh_zo(rawBox, padding, dest.raw);
X
X  return dest;
X}
X
X/*!
X * @brief set up orthographic projection matrix using bounding box
X *        with a left-hand coordinate system and a
X *        clip-space of [0, 1].
X *
X * bounding box (AABB) must be in view space
X *
X * @param[in]  box     AABB
X * @param[in]  padding padding for near and far
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_ortho_aabb_pz_lh_zo(vec3s box[2], float padding) {
X  mat4s dest;
X  vec3  rawBox[2];
X
X  glms_vec3_(unpack)(rawBox, box, 2);
X  glm_ortho_aabb_pz_lh_zo(rawBox, padding, dest.raw);
X
X  return dest;
X}
X
X/*!
X * @brief set up unit orthographic projection matrix
X *        with a left-hand coordinate system and a
X *        clip-space of [0, 1].
X *
X * @param[in]  aspect aspect ration ( width / height )
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_ortho_default_lh_zo(float aspect) {
X  mat4s dest;
X  glm_ortho_default_lh_zo(aspect, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief set up orthographic projection matrix with given CUBE size
X *        with a left-hand coordinate system and a
X *        clip-space of [0, 1].
X *
X * @param[in]  aspect aspect ratio ( width / height )
X * @param[in]  size   cube size
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_ortho_default_s_lh_zo(float aspect, float size) {
X  mat4s dest;
X  glm_ortho_default_s_lh_zo(aspect, size, dest.raw);
X  return dest;
X}
X
X#endif /* cglms_ortho_lh_zo_h */
b080732560ed30ec8ae2a11ee714945a
echo x - cglm/struct/clipspace/ortho_rh_no.h
sed 's/^X//' >cglm/struct/clipspace/ortho_rh_no.h << '59506ea59d7e067aa8df19285e7f0f6d'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Functions:
X   CGLM_INLINE mat4s glms_ortho_rh_no(float left,    float right,
X                                      float bottom,  float top,
X                                      float nearZ,   float farZ)
X   CGLM_INLINE mat4s glms_ortho_aabb_rh_no(vec3s box[2]);
X   CGLM_INLINE mat4s glms_ortho_aabb_p_rh_no(vec3s box[2],  float padding);
X   CGLM_INLINE mat4s glms_ortho_aabb_pz_rh_no(vec3s box[2], float padding);
X   CGLM_INLINE mat4s glms_ortho_default_rh_no(float aspect)
X   CGLM_INLINE mat4s glms_ortho_default_s_rh_no(float aspect, float size)
X */
X
X#ifndef cglms_ortho_rh_no_h
X#define cglms_ortho_rh_no_h
X
X#include "../../common.h"
X#include "../../types-struct.h"
X#include "../../plane.h"
X#include "../../cam.h"
X#include "../vec3.h"
X#include "../../clipspace/ortho_rh_no.h"
X
X/*!
X * @brief set up orthographic projection matrix
X *        with a right-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * @param[in]  left    viewport.left
X * @param[in]  right   viewport.right
X * @param[in]  bottom  viewport.bottom
X * @param[in]  top     viewport.top
X * @param[in]  nearZ   near clipping plane
X * @param[in]  farZ    far clipping plane
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_ortho_rh_no(float left,   float right,
X                 float bottom, float top,
X                 float nearZ,  float farZ) {
X  mat4s dest;
X  glm_ortho_rh_no(left, right, bottom, top, nearZ, farZ, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief set up orthographic projection matrix using bounding box
X *        with a right-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * bounding box (AABB) must be in view space
X *
X * @param[in]  box   AABB
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_ortho_aabb_rh_no(vec3s box[2]) {
X  mat4s dest;
X  vec3  rawBox[2];
X
X  glms_vec3_(unpack)(rawBox, box, 2);
X  glm_ortho_aabb_rh_no(rawBox, dest.raw);
X
X  return dest;
X}
X
X/*!
X * @brief set up orthographic projection matrix using bounding box
X *        with a right-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * bounding box (AABB) must be in view space
X *
X * @param[in]  box     AABB
X * @param[in]  padding padding
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_ortho_aabb_p_rh_no(vec3s box[2], float padding) {
X  mat4s dest;
X  vec3  rawBox[2];
X
X  glms_vec3_(unpack)(rawBox, box, 2);
X  glm_ortho_aabb_p_rh_no(rawBox, padding, dest.raw);
X
X  return dest;
X}
X
X/*!
X * @brief set up orthographic projection matrix using bounding box
X *        with a right-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * bounding box (AABB) must be in view space
X *
X * @param[in]  box     AABB
X * @param[in]  padding padding for near and far
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_ortho_aabb_pz_rh_no(vec3s box[2], float padding) {
X  mat4s dest;
X  vec3  rawBox[2];
X
X  glms_vec3_(unpack)(rawBox, box, 2);
X  glm_ortho_aabb_pz_rh_no(rawBox, padding, dest.raw);
X
X  return dest;
X}
X
X/*!
X * @brief set up unit orthographic projection matrix
X *        with a right-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * @param[in]  aspect aspect ration ( width / height )
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_ortho_default_rh_no(float aspect) {
X  mat4s dest;
X  glm_ortho_default_rh_no(aspect, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief set up orthographic projection matrix with given CUBE size
X *        with a right-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * @param[in]  aspect aspect ratio ( width / height )
X * @param[in]  size   cube size
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_ortho_default_s_rh_no(float aspect, float size) {
X  mat4s dest;
X  glm_ortho_default_s_rh_no(aspect, size, dest.raw);
X  return dest;
X}
X
X#endif /* cglms_ortho_rh_no_h */
59506ea59d7e067aa8df19285e7f0f6d
echo x - cglm/struct/clipspace/ortho_rh_zo.h
sed 's/^X//' >cglm/struct/clipspace/ortho_rh_zo.h << '9e1e958ba1c4c82131aa987b367839a3'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Functions:
X   CGLM_INLINE mat4s glms_ortho_rh_zo(float left,    float right,
X                                      float bottom,  float top,
X                                      float nearZ,   float farZ)
X   CGLM_INLINE mat4s glms_ortho_aabb_rh_zo(vec3s box[2]);
X   CGLM_INLINE mat4s glms_ortho_aabb_p_rh_zo(vec3s box[2],  float padding);
X   CGLM_INLINE mat4s glms_ortho_aabb_pz_rh_zo(vec3s box[2], float padding);
X   CGLM_INLINE mat4s glms_ortho_default_rh_zo(float aspect)
X   CGLM_INLINE mat4s glms_ortho_default_s_rh_zo(float aspect, float size)
X */
X
X#ifndef cglms_ortho_rh_zo_h
X#define cglms_ortho_rh_zo_h
X
X#include "../../common.h"
X#include "../../types-struct.h"
X#include "../../plane.h"
X#include "../../cam.h"
X#include "../vec3.h"
X#include "../../clipspace/ortho_rh_zo.h"
X
X/*!
X * @brief set up orthographic projection matrix
X *        with a right-hand coordinate system and a
X *        clip-space of [0, 1].
X *
X * @param[in]  left    viewport.left
X * @param[in]  right   viewport.right
X * @param[in]  bottom  viewport.bottom
X * @param[in]  top     viewport.top
X * @param[in]  nearZ   near clipping plane
X * @param[in]  farZ    far clipping plane
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_ortho_rh_zo(float left,   float right,
X                 float bottom, float top,
X                 float nearZ,  float farZ) {
X  mat4s dest;
X  glm_ortho_rh_zo(left, right, bottom, top, nearZ, farZ, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief set up orthographic projection matrix using bounding box
X *        with a right-hand coordinate system and a
X *        clip-space of [0, 1].
X *
X * bounding box (AABB) must be in view space
X *
X * @param[in]  box   AABB
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_ortho_aabb_rh_zo(vec3s box[2]) {
X  mat4s dest;
X  vec3  rawBox[2];
X
X  glms_vec3_(unpack)(rawBox, box, 2);
X  glm_ortho_aabb_rh_zo(rawBox, dest.raw);
X
X  return dest;
X}
X
X/*!
X * @brief set up orthographic projection matrix using bounding box
X *        with a right-hand coordinate system and a
X *        clip-space of [0, 1].
X *
X * bounding box (AABB) must be in view space
X *
X * @param[in]  box     AABB
X * @param[in]  padding padding
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_ortho_aabb_p_rh_zo(vec3s box[2], float padding) {
X  mat4s dest;
X  vec3  rawBox[2];
X
X  glms_vec3_(unpack)(rawBox, box, 2);
X  glm_ortho_aabb_p_rh_zo(rawBox, padding, dest.raw);
X
X  return dest;
X}
X
X/*!
X * @brief set up orthographic projection matrix using bounding box
X *        with a right-hand coordinate system and a
X *        clip-space of [0, 1].
X *
X * bounding box (AABB) must be in view space
X *
X * @param[in]  box     AABB
X * @param[in]  padding padding for near and far
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_ortho_aabb_pz_rh_zo(vec3s box[2], float padding) {
X  mat4s dest;
X  vec3  rawBox[2];
X
X  glms_vec3_(unpack)(rawBox, box, 2);
X  glm_ortho_aabb_pz_rh_zo(rawBox, padding, dest.raw);
X
X  return dest;
X}
X
X/*!
X * @brief set up unit orthographic projection matrix
X *        with a right-hand coordinate system and a
X *        clip-space of [0, 1].
X *
X * @param[in]  aspect aspect ration ( width / height )
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_ortho_default_rh_zo(float aspect) {
X  mat4s dest;
X  glm_ortho_default_rh_zo(aspect, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief set up orthographic projection matrix with given CUBE size
X *        with a right-hand coordinate system and a
X *        clip-space of [0, 1].
X *
X * @param[in]  aspect aspect ratio ( width / height )
X * @param[in]  size   cube size
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_ortho_default_s_rh_zo(float aspect, float size) {
X  mat4s dest;
X  glm_ortho_default_s_rh_zo(aspect, size, dest.raw);
X  return dest;
X}
X
X#endif /* cglms_ortho_rh_zo_h */
9e1e958ba1c4c82131aa987b367839a3
echo x - cglm/struct/clipspace/view_lh_no.h
sed 's/^X//' >cglm/struct/clipspace/view_lh_no.h << 'feb539a10c1225d12fdb981d47f41ed1'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Functions:
X   CGLM_INLINE mat4s glms_lookat_lh_no(vec3s eye, vec3s center, vec3s up)
X   CGLM_INLINE mat4s glms_look_lh_no(vec3s eye, vec3s dir, vec3s up)
X   CGLM_INLINE mat4s glms_look_anyup_lh_no(vec3s eye, vec3s dir)
X */
X
X#ifndef cglms_view_lh_no_h
X#define cglms_view_lh_no_h
X
X#include "../../common.h"
X#include "../../types-struct.h"
X#include "../../plane.h"
X#include "../../cam.h"
X#include "../../clipspace/view_lh_no.h"
X
X/*!
X * @brief set up view matrix
X *        with a left-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * NOTE: The UP vector must not be parallel to the line of sight from
X *       the eye point to the reference point
X *
X * @param[in]  eye    eye vector
X * @param[in]  center center vector
X * @param[in]  up     up vector
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_lookat_lh_no(vec3s eye, vec3s center, vec3s up) {
X  mat4s dest;
X  glm_lookat_lh_no(eye.raw, center.raw, up.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief set up view matrix
X *        with a left-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * convenient wrapper for lookat: if you only have direction not target self
X * then this might be useful. Because you need to get target from direction.
X *
X * NOTE: The UP vector must not be parallel to the line of sight from
X *       the eye point to the reference point
X *
X * @param[in]  eye    eye vector
X * @param[in]  dir    direction vector
X * @param[in]  up     up vector
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_look_lh_no(vec3s eye, vec3s dir, vec3s up) {
X  mat4s dest;
X  glm_look_lh_no(eye.raw, dir.raw, up.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief set up view matrix
X *        with a left-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * convenient wrapper for look: if you only have direction and if you don't
X * care what UP vector is then this might be useful to create view matrix
X *
X * @param[in]  eye    eye vector
X * @param[in]  dir    direction vector
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_look_anyup_lh_no(vec3s eye, vec3s dir) {
X  mat4s dest;
X  glm_look_anyup_lh_no(eye.raw, dir.raw, dest.raw);
X  return dest;
X}
X
X#endif /* cglms_view_lh_no_h */
feb539a10c1225d12fdb981d47f41ed1
echo x - cglm/struct/clipspace/view_lh_zo.h
sed 's/^X//' >cglm/struct/clipspace/view_lh_zo.h << 'f251a241f0efa34b61e7b5e571afc235'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Functions:
X   CGLM_INLINE mat4s glms_lookat_lh_zo(vec3s eye, vec3s center, vec3s up)
X   CGLM_INLINE mat4s glms_look_lh_zo(vec3s eye, vec3s dir, vec3s up)
X   CGLM_INLINE mat4s glms_look_anyup_lh_zo(vec3s eye, vec3s dir)
X */
X
X#ifndef cglms_view_lh_zo_h
X#define cglms_view_lh_zo_h
X
X#include "../../common.h"
X#include "../../types-struct.h"
X#include "../../plane.h"
X#include "../../cam.h"
X#include "../../clipspace/view_lh_zo.h"
X
X/*!
X * @brief set up view matrix
X *        with a left-hand coordinate system and a
X *        clip-space of [0, 1].
X *
X * NOTE: The UP vector must not be parallel to the line of sight from
X *       the eye point to the reference point
X *
X * @param[in]  eye    eye vector
X * @param[in]  center center vector
X * @param[in]  up     up vector
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_lookat_lh_zo(vec3s eye, vec3s center, vec3s up) {
X  mat4s dest;
X  glm_lookat_lh_zo(eye.raw, center.raw, up.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief set up view matrix
X *        with a left-hand coordinate system and a
X *        clip-space of [0, 1].
X *
X * convenient wrapper for lookat: if you only have direction not target self
X * then this might be useful. Because you need to get target from direction.
X *
X * NOTE: The UP vector must not be parallel to the line of sight from
X *       the eye point to the reference point
X *
X * @param[in]  eye    eye vector
X * @param[in]  dir    direction vector
X * @param[in]  up     up vector
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_look_lh_zo(vec3s eye, vec3s dir, vec3s up) {
X  mat4s dest;
X  glm_look_lh_zo(eye.raw, dir.raw, up.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief set up view matrix
X *        with a left-hand coordinate system and a
X *        clip-space of [0, 1].
X *
X * convenient wrapper for look: if you only have direction and if you don't
X * care what UP vector is then this might be useful to create view matrix
X *
X * @param[in]  eye    eye vector
X * @param[in]  dir    direction vector
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_look_anyup_lh_zo(vec3s eye, vec3s dir) {
X  mat4s dest;
X  glm_look_anyup_lh_zo(eye.raw, dir.raw, dest.raw);
X  return dest;
X}
X
X#endif /* cglms_view_lh_zo_h */
f251a241f0efa34b61e7b5e571afc235
echo x - cglm/struct/clipspace/view_rh_no.h
sed 's/^X//' >cglm/struct/clipspace/view_rh_no.h << '19544b13e42c59c522044f42350aa6ce'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Functions:
X   CGLM_INLINE mat4s glms_lookat_rh_no(vec3s eye, vec3s center, vec3s up)
X   CGLM_INLINE mat4s glms_look_rh_no(vec3s eye, vec3s dir, vec3s up)
X   CGLM_INLINE mat4s glms_look_anyup_rh_no(vec3s eye, vec3s dir)
X */
X
X#ifndef cglms_view_rh_no_h
X#define cglms_view_rh_no_h
X
X#include "../../common.h"
X#include "../../types-struct.h"
X#include "../../plane.h"
X#include "../../cam.h"
X#include "../../clipspace/view_rh_no.h"
X
X/*!
X * @brief set up view matrix
X *        with a right-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * NOTE: The UP vector must not be parallel to the line of sight from
X *       the eye point to the reference point
X *
X * @param[in]  eye    eye vector
X * @param[in]  center center vector
X * @param[in]  up     up vector
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_lookat_rh_no(vec3s eye, vec3s center, vec3s up) {
X  mat4s dest;
X  glm_lookat_rh_no(eye.raw, center.raw, up.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief set up view matrix
X *        with a right-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * convenient wrapper for lookat: if you only have direction not target self
X * then this might be useful. Because you need to get target from direction.
X *
X * NOTE: The UP vector must not be parallel to the line of sight from
X *       the eye point to the reference point
X *
X * @param[in]  eye    eye vector
X * @param[in]  dir    direction vector
X * @param[in]  up     up vector
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_look_rh_no(vec3s eye, vec3s dir, vec3s up) {
X  mat4s dest;
X  glm_look_rh_no(eye.raw, dir.raw, up.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief set up view matrix
X *        with a right-hand coordinate system and a
X *        clip-space of [-1, 1].
X *
X * convenient wrapper for look: if you only have direction and if you don't
X * care what UP vector is then this might be useful to create view matrix
X *
X * @param[in]  eye    eye vector
X * @param[in]  dir    direction vector
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_look_anyup_rh_no(vec3s eye, vec3s dir) {
X  mat4s dest;
X  glm_look_anyup_rh_no(eye.raw, dir.raw, dest.raw);
X  return dest;
X}
X
X#endif /* cglms_view_rh_no_h */
19544b13e42c59c522044f42350aa6ce
echo x - cglm/struct/clipspace/view_rh_zo.h
sed 's/^X//' >cglm/struct/clipspace/view_rh_zo.h << 'ed76b570a3f0c81b0d1b12b7a922ff94'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Functions:
X   CGLM_INLINE mat4s glms_lookat_rh_zo(vec3s eye, vec3s center, vec3s up)
X   CGLM_INLINE mat4s glms_look_rh_zo(vec3s eye, vec3s dir, vec3s up)
X   CGLM_INLINE mat4s glms_look_anyup_rh_zo(vec3s eye, vec3s dir)
X */
X
X#ifndef cglms_view_rh_zo_h
X#define cglms_view_rh_zo_h
X
X#include "../../common.h"
X#include "../../types-struct.h"
X#include "../../plane.h"
X#include "../../cam.h"
X#include "../../clipspace/view_rh_zo.h"
X
X/*!
X * @brief set up view matrix
X *        with a right-hand coordinate system and a
X *        clip-space of [0, 1].
X *
X * NOTE: The UP vector must not be parallel to the line of sight from
X *       the eye point to the reference point
X *
X * @param[in]  eye    eye vector
X * @param[in]  center center vector
X * @param[in]  up     up vector
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_lookat_rh_zo(vec3s eye, vec3s center, vec3s up) {
X  mat4s dest;
X  glm_lookat_rh_zo(eye.raw, center.raw, up.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief set up view matrix
X *        with a right-hand coordinate system and a
X *        clip-space of [0, 1].
X *
X * convenient wrapper for lookat: if you only have direction not target self
X * then this might be useful. Because you need to get target from direction.
X *
X * NOTE: The UP vector must not be parallel to the line of sight from
X *       the eye point to the reference point
X *
X * @param[in]  eye    eye vector
X * @param[in]  dir    direction vector
X * @param[in]  up     up vector
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_look_rh_zo(vec3s eye, vec3s dir, vec3s up) {
X  mat4s dest;
X  glm_look_rh_zo(eye.raw, dir.raw, up.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief set up view matrix
X *        with a right-hand coordinate system and a
X *        clip-space of [0, 1].
X *
X * convenient wrapper for look: if you only have direction and if you don't
X * care what UP vector is then this might be useful to create view matrix
X *
X * @param[in]  eye    eye vector
X * @param[in]  dir    direction vector
X * @returns    result matrix
X */
XCGLM_INLINE
Xmat4s
Xglms_look_anyup_rh_zo(vec3s eye, vec3s dir) {
X  mat4s dest;
X  glm_look_anyup_rh_zo(eye.raw, dir.raw, dest.raw);
X  return dest;
X}
X
X#endif /* cglms_view_rh_zo_h */
ed76b570a3f0c81b0d1b12b7a922ff94
echo x - cglm/struct/clipspace/project_no.h
sed 's/^X//' >cglm/struct/clipspace/project_no.h << 'a08fd0f9c8bbb5243f6d17ba6d3fc646'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Functions:
X   CGLM_INLINE vec3s glms_unprojecti_no(vec3s pos, mat4s invMat, vec4s vp)
X   CGLM_INLINE vec3s glms_project_no(vec3s pos, mat4s m, vec4s vp)
X   CGLM_INLINE float glms_project_z_no(vec3s v, mat4s m)
X */
X
X#ifndef cglms_project_no_h
X#define cglms_project_no_h
X
X#include "../../common.h"
X#include "../../types-struct.h"
X#include "../../plane.h"
X#include "../../cam.h"
X#include "../../clipspace/project_no.h"
X
X/*!
X * @brief maps the specified viewport coordinates into specified space [1]
X *        the matrix should contain projection matrix.
X *
X * if you don't have ( and don't want to have ) an inverse matrix then use
X * glm_unproject version. You may use existing inverse of matrix in somewhere
X * else, this is why glm_unprojecti exists to save save inversion cost
X *
X * [1] space:
X *  1- if m = invProj:     View Space
X *  2- if m = invViewProj: World Space
X *  3- if m = invMVP:      Object Space
X *
X * You probably want to map the coordinates into object space
X * so use invMVP as m
X *
X * Computing viewProj:
X *   glm_mat4_mul(proj, view, viewProj);
X *   glm_mat4_mul(viewProj, model, MVP);
X *   glm_mat4_inv(viewProj, invMVP);
X *
X * @param[in]  pos          point/position in viewport coordinates
X * @param[in]  invMat   matrix (see brief)
X * @param[in]  vp            viewport as [x, y, width, height]
X *
X * @returns unprojected coordinates
X */
XCGLM_INLINE
Xvec3s
Xglms_unprojecti_no(vec3s pos, mat4s invMat, vec4s vp) {
X  vec3s dest;
X  glm_unprojecti_no(pos.raw, invMat.raw, vp.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief map object coordinates to window coordinates
X *
X * Computing MVP:
X *   glm_mat4_mul(proj, view, viewProj);
X *   glm_mat4_mul(viewProj, model, MVP);
X *
X * @param[in]  pos      object coordinates
X * @param[in]  m          MVP matrix
X * @param[in]  vp        viewport as [x, y, width, height]
X *
X * @returns projected coordinates
X */
XCGLM_INLINE
Xvec3s
Xglms_project_no(vec3s pos, mat4s m, vec4s vp) {
X  vec3s dest;
X  glm_project_no(pos.raw, m.raw, vp.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief map object's z coordinate to window coordinates
X *
X * Computing MVP:
X *   glm_mat4_mul(proj, view, viewProj);
X *   glm_mat4_mul(viewProj, model, MVP);
X *
X * @param[in]  v object coordinates
X * @param[in]  m MVP matrix
X *
X * @returns projected z coordinate
X */
XCGLM_INLINE
Xfloat
Xglms_project_z_no(vec3s v, mat4s m) {
X  return glm_project_z_no(v.raw, m.raw);
X}
X
X#endif /* cglms_project_rh_no_h */
a08fd0f9c8bbb5243f6d17ba6d3fc646
echo x - cglm/struct/clipspace/project_zo.h
sed 's/^X//' >cglm/struct/clipspace/project_zo.h << '9098f20cb98b25425e916db4d1dbeafb'
X/*
X * Copyright (c), Recep Aslantas.
X *
X * MIT License (MIT), http://opensource.org/licenses/MIT
X * Full license can be found in the LICENSE file
X */
X
X/*
X Functions:
X   CGLM_INLINE vec3s glms_unprojecti_no(vec3s pos, mat4s invMat, vec4s vp)
X   CGLM_INLINE vec3s glms_project_no(vec3s pos, mat4s m, vec4s vp)
X   CGLM_INLINE float glms_project_z_zo(vec3s v, mat4s m)
X */
X
X#ifndef cglms_project_zo_h
X#define cglms_project_zo_h
X
X#include "../../common.h"
X#include "../../types-struct.h"
X#include "../../plane.h"
X#include "../../cam.h"
X#include "../../clipspace/project_zo.h"
X
X/*!
X * @brief maps the specified viewport coordinates into specified space [1]
X *        the matrix should contain projection matrix.
X *
X * if you don't have ( and don't want to have ) an inverse matrix then use
X * glm_unproject version. You may use existing inverse of matrix in somewhere
X * else, this is why glm_unprojecti exists to save save inversion cost
X *
X * [1] space:
X *  1- if m = invProj:     View Space
X *  2- if m = invViewProj: World Space
X *  3- if m = invMVP:      Object Space
X *
X * You probably want to map the coordinates into object space
X * so use invMVP as m
X *
X * Computing viewProj:
X *   glm_mat4_mul(proj, view, viewProj);
X *   glm_mat4_mul(viewProj, model, MVP);
X *   glm_mat4_inv(viewProj, invMVP);
X *
X * @param[in]  pos          point/position in viewport coordinates
X * @param[in]  invMat   matrix (see brief)
X * @param[in]  vp            viewport as [x, y, width, height]
X *
X * @returns unprojected coordinates
X */
XCGLM_INLINE
Xvec3s
Xglms_unprojecti_zo(vec3s pos, mat4s invMat, vec4s vp) {
X  vec3s dest;
X  glm_unprojecti_zo(pos.raw, invMat.raw, vp.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief map object coordinates to window coordinates
X *
X * Computing MVP:
X *   glm_mat4_mul(proj, view, viewProj);
X *   glm_mat4_mul(viewProj, model, MVP);
X *
X * @param[in]  pos      object coordinates
X * @param[in]  m          MVP matrix
X * @param[in]  vp        viewport as [x, y, width, height]
X *
X * @returns projected coordinates
X */
XCGLM_INLINE
Xvec3s
Xglms_project_zo(vec3s pos, mat4s m, vec4s vp) {
X  vec3s dest;
X  glm_project_zo(pos.raw, m.raw, vp.raw, dest.raw);
X  return dest;
X}
X
X/*!
X * @brief map object's z coordinate to window coordinates
X *
X * Computing MVP:
X *   glm_mat4_mul(proj, view, viewProj);
X *   glm_mat4_mul(viewProj, model, MVP);
X *
X * @param[in]  v object coordinates
X * @param[in]  m MVP matrix
X *
X * @returns projected z coordinate
X */
XCGLM_INLINE
Xfloat
Xglms_project_z_zo(vec3s v, mat4s m) {
X  return glm_project_z_zo(v.raw, m.raw);
X}
X
X#endif /* cglm_project_zo_h */
9098f20cb98b25425e916db4d1dbeafb
exit

